File: Reports

Group: Notes from CCNY

Topic: Notes on 5/10/07

* improve HT results.
* improve DP points based on clock-wise and combination of HT and ras2vec.
* compare the slices from the range data, instead of after vectorized lines.

Topic: Notes on 4/26/07

* showing the DP points from both HT and ras2vec results
* some <Reverse Engineering Papers> for similar tasks.
* the manually generated dxf files, which can be imported into SketchUp

Topic: Notes on 3/8/07

* thinning may lose some data for DP algorithm
* Douglas-Peucker Algorihtm
* four <DP Papers> , in particular, the floorplan one.
* Demo programs (DPHull_demo.zip/ras2vec.zip/qgar) and IV viewer
* SGI/Corn3D/Open inventor

Topic: Notes on Meeting 2

* Symmetry paper from SIGGRAPH06
* Qt/CGAL
* Chain Code

Topic: Notes on Meeting 1

* procedual modeling building
* missing data fitting
* SNAKE for boundary detection.
* Parameter HT.

Group: Report from Email

Topic: Meeting 3 notes
Applied recursive HT on real data. 
:
1. Data loading and conversion. 

The image files are generated from the original .bpa files using "hunter_load_data.m" written in Matlab. The images are of size 360x540, which can be set to other size to regenerate the images by changing the parameters in hunter_load_data.m. The coordinate data for images are extracted from column 1 and column 3 in .bpa files and times 5 to be fit into 360x540 resolution. The image files are saved in tiff format.
:
2. Parameters for Hough Transform

	The first parameter as shown in the above figure is the initial threshold for HT and the second one is the iteration divide factor, which determines the pace of decrease of the HT threshold. For example, assuming initial threshold is 40, and divide factor is 1.5. Then, in the first iteration, the HT threshold is 40, and in the second iteration, the threshold is 40/1.5, the third iteration threshold is (40/1.5)/1.5... until all the data have been fitted into lines.
:
3. Pre-processing algorithms.

	Because the images contain a lot of noise, the pre-processing on images is needed in order to apply our recursive HT. Two strategies are implemented to improve the image. The first algorithm is to do thinning on the images, then all the connected components (CC) are computed. Based on these CCs, the noise outside and inside of the building are removed.
	The second algorithm is trickier: After removing the noise pixels outside of the building, a scanning processing is used to find out out-most pixels of the building from four directions (left, right, top, bottom).
	We can choose either algorithm to do the preprocessing by selecting "Algorithm1" or "Algorithms2" from the popup menu.
:
4. Performance improvement.

With the original Matlab HT code, the computing for HT takes more than 20 seconds. In order to speed up this computation, I rewrote the core HT code in C++ and let Matlab code call the HT function generated by the above c++ code (myht.mexw32) to speed up the computing. Now, it takes less than 1 second to do the HT. The two preprocessing algorithms are also implemented in C++ (preprocess.mexw32 & preprocess_2.mexw32)
:
5. The functional buttons.

"Pre-Process": 	- show the pre-processed image.
"Line Fitting": 	- show lines fitted on pre-processed image.
"Clear": 		- clear the red fitted lines.
"Exit": 		- quit the program.

Future work::

- 1. Improve the pre-processing algorithm to improve the image.
- 2. Try to infer the missing data to generate closed shape/polygon.
- 3. Try SNAKE or other algorithms and compare these methods.

<file:../../../Reports/Report_2_12.20.06.doc>

<file:../../../bitwise_Rotated_split_036.bpa_img.tiff>

Topic: Meeting 2 notes
Showed the simulation result using HT on line detection. 
:
1. Created the polygons for grand truth. 

This can be done in two different ways. One is to choose the edge number for polygon from the popup menu to create pre-defined polygons. Another way is to click "ROIPOLY" button to draw an arbitrary polygon on the image using mouse, which is done by calling roipoly() Matlab function. 

:
2. Generate some random simulated data for the polygon.

By clicking on the "Randomized" button to do this. Three parameters are used to control the random data generator. 
- The first parameter is used to determine the noise distribution, which could be either Gaussian or uniform distribution. The default value for the popup menu is Gaussian distribution. 
- The second parameter is used to indicate the density of the random data generated around the edges of the polygon. 
- The third parameter is error range in pixels around the true point coordinates. This error range is the standard deviation for Gaussian distribution and half of the uniform distribution. For example, if the parameter set is ('uniform', 3, 4), this means the distance from random data to the line could be between -4 pixels to 4 pixels (4.0*randn() for Gaussian distribution) and there are 3 points generated for each point (pixel) along each edge of the polygon. 

:
3. After the "Randomized" button is clicked, a set of simulated "Point Cloud" is generated around the edges of the polygon. The point cloud data is used as the input for line fitting to recover the polygon. Right now, I am using Hough Transform (HT) for line fitting. 

:
4. Clicking on the "Fitting" button in the bottom of the image, we can see the result of the line fitting. I have not calculated the intersection points from the fitted lines to get the vertices of the polygon yet, which will be one of my next step tasks.

:

Known bugs::
	- Sometimes, multiple lines are fitted for the random data of the same edge. 
	- When the edge is short, it cannot be detected as a line

<file:../../../Reports/Report_1_10.30.06.doc>

Topic: Meeting 1 notes
Introduction of project; Google SketchUp; 


