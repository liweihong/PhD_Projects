/*  Invariant:
    1. Use HT to control the resolutions.
*/

/*  TODO:
    *. compute the connectivities of the line segments !!!!!!!!! ( BPA algorithm )
    *. how to compute the extrusion of the roof on the building.
    *. tiled to get the boundary of the last few slices, with seperated circles.
    *. missing data inference, e.g.,for HD distance, choose the min one, as well as the landing procedure.

    LONGTERM:
    *. linear HT followed by non-linear data fitting, with linear data removed.

    * Steps for DXF generation:
  
    0: sliced images generated (1000) - _
    1: noise cleaned based on bounding box (1000) - _cleaned
    2: symmetry computation (1000) - _recoverd
    3: boundary computation for key slices detection (1000) - _boundary
       4.0: key slices generation (65/1000) - _result (aaa_xxx.png)
       4.1: boundary vectorization (65/1000) - _result (bbb_xxx.png)
       4.2: manually remove some noise based on result of 4.1, go back to 4.1 again
       4.3: dump the vector into ascii file for dxf generation.
    5: generate dxf file.


*/

#include "project.h"

#define SAVE_FORMAT save_png
#define ASSERT assert

// Field: global_opts
// all global options are saved in this var
char *output_fn = "global_init.png";
char *global_opts = NULL;
GLOBAL_OPTIONS *gbl_opts = NULL;
int image_width = 1024;
int image_height = 392;
int DEBUG_BPA = 0;
avl_tree *avlFlagTable = NULL;

#ifdef MSVC_60
int min(int a, int b)
{
	return a < b? a : b;
}
int max(int a, int b)
{
	return a > b? a : b;
}
#endif

void *my_malloc (size_t size)
{
  void *result = malloc(size) ;

  if ( result == NULL )
    {
      printf ( "run out of memory" ) ;
      exit(0);
    }

  //printf ( "MALLOC of size %d returning pointer %d\n" , size , result ) ; 

  return result ;
}
//#define my_malloc(sz) OBJTRC(void *, my_malloc(sz))

int my_strlen ( const char *s )
{
  if ( s == NULL )
    return 0 ;

  return strlen(s) ; 
}


void my_free ( void *ptr )
{
  if ( ptr )
    {
      //printf ( "FREE pointer %d\n" , ptr ) ;

      free ( ptr ) ;
    }
}

char *str_duplicate ( const char *s )
{
  int length = my_strlen(s) ; 
  char *result = NULL ; 

  if ( length == 0 )
    return NULL ; 

  result = (char *) my_malloc ( (1+length) * sizeof(char) ) ;

  result = strcpy ( result , s ) ;
  assert(result[length] == '\0') ; 

  return result ; 
}


char *str_concat ( const char *s1 , const char *s2 )
{
  char *result ; 

  if ( my_strlen(s1) <= 0 )
    return str_duplicate ( s2 ) ;

  if ( my_strlen(s2) <= 0 )
    return str_duplicate ( s1 ) ;

  result = (char *) my_malloc ( (my_strlen(s1)+my_strlen(s2)+1) * sizeof(char) ) ;
  
  result = strcpy ( result , s1 ) ;
  result = strcat ( result , s2 ) ;
  assert(result[my_strlen(s1)+my_strlen(s2)] == '\0') ; 

  return result ;
}

char *str_concat_freeFirst ( char *s1 , const char *s2 )
{
  char *result = str_concat ( s1 , s2 ) ;
  
  my_free ( s1 ) ;

  return result ;
}


char *str_substring ( const char *s , const int start , const int end )
{
  char *result ;
  int i ;

  ASSERT ( end >= start ) ;

  result = (char *) my_malloc ( (end-start+1) * sizeof(char) ) ;
  for ( i = start ; i < end ; i++ )
    result[i-start] = s[i] ;
  result[i-start] = '\0' ;

  return result ;
}


char *str_replace ( const char *s , const char *pattern , const char *replacement , int startPosition , int occurences ) 
{
  int pos = 0 ;
  int oldPos = 0 ; 
  int i ; 
  char *result = NULL ; 
  int patternLength = my_strlen(pattern) ; 
  int length = my_strlen(s) ; 
  char *tmp ; 
  int performed = 0 ; 

  if ( length <= 0 || patternLength <= 0 || occurences == 0 )
    return str_duplicate ( s ) ;
  
  if ( startPosition > 0 )
    {
      result = str_substring ( s , 0 , startPosition ) ;
      pos = startPosition ;
      oldPos = startPosition ;
    }

  while ( pos + patternLength <= length )
    {
      for ( i = 0 ; i < patternLength ; i++ )
	{
	  if ( s[pos+i] != pattern[i] )
	    break ; 
	}  

      if ( i < patternLength )
	pos++ ;
      else
	{
	  //found match
	  tmp = str_substring ( s , oldPos , pos ) ;
	  result = str_concat_freeFirst ( result , tmp ) ;
	  my_free ( tmp ) ;
	  result = str_concat_freeFirst ( result , replacement ) ;
	  pos += patternLength ;
	  oldPos = pos ; 
	  performed++ ;

	  if ( occurences > 0 && performed >= occurences )
	    break ; 
	}
    }

  //there may be rest that i havent copied yet
  tmp = str_substring ( s , oldPos , length ) ;
  result = str_concat_freeFirst ( result , tmp ) ;
  my_free ( tmp ) ;

  return result ;
}


/*
  Function: str_suffixCheck 
  Find whether a particular string s ends in a suffix string.
*/
bool str_suffixCheck ( const char *s , const char *suffix ) 
{
  if ( suffix == NULL ) 
    return true ; 

  if ( s == NULL )
    return false ;

  int sLength , suffixLength ; 

  sLength = strlen(s) ;
  suffixLength = strlen(suffix) ;

  if ( sLength < suffixLength ) 
    return false ;

  const char *startingPos ;
  
  startingPos = s + (sLength-suffixLength) ;

  if ( strcmp ( startingPos , suffix ) == 0 )
    return true;

  return false;
}



char *str_cutFromLastSubstring ( const char *s , const char *pattern ) 
{
  int pos , lengthOfPattern ; 
  
  if ( s == NULL )
    return NULL ;

  if ( pattern == NULL )
    return str_duplicate ( s ) ;

  lengthOfPattern = strlen(pattern) ;
  pos = strlen(s) - lengthOfPattern ;

  while ( pos >= 0 )
    {
      int i ; 

      for ( i = 0 ; i < lengthOfPattern ; i++ )
	if ( s[pos+i] != pattern[i] )
	  {
	    pos-- ;
	    break ; 
	  }

      if ( i == lengthOfPattern )
	return str_substring ( s , 0 , pos ) ;
    }
  
  return NULL ;
}




char *intToString ( int i )
{
  char *tmp = (char *) my_malloc ( 100*sizeof(char) ) ;
  char *result ; 

  sprintf ( tmp , "%d\0\0" , i ) ;

  result = str_duplicate ( tmp ) ;

  free ( tmp ) ;

  return result ; 
}

char *dirname(char *fn)
{
   return str_cutFromLastSubstring(fn, "/");
}

void updateRunTimeFlag(char *key, char *value)
{
  char *oldValue;

  if (!key)
    return;
  if (!value)
    value = strdup("");

  /* bug fixed: the free command makes the pointer null causing key=0
     if the key already exist*/
  if (avl_delete(avlFlagTable, &key, &oldValue)) {
    free(oldValue);
    (void) avl_insert(avlFlagTable, key, strdup(value));
  }else {
    (void) avl_insert(avlFlagTable, strdup(key), strdup(value));
  }

}

inline int readRunTimeFlag(char *flag, char **value)
{

   assert(avlFlagTable);

   return avl_lookup(avlFlagTable, flag, value);
   
}

void
false_color(float x, float xmin, float xmax, int& int_r, int& int_g, int& int_b)
{
     if(x < xmin) x = xmin;
     if(x > xmax) x = xmax;
     float dx = xmax - xmin;
     float r, g, b;

     r = g = b = 1.0f;

     if (x < (xmin + 0.25 * dx)) {
          r = 0;
          g = 4 * (x - xmin) / dx;
     } else if (x < (xmin + 0.5 * dx)) {
          r = 0;
          b = 1 + 4 * (xmin + 0.25 * dx - x) / dx;
     } else if (x < (xmin + 0.75 * dx)) {
          r = 4 * (x - xmin - 0.5 * dx) / dx;
          b = 0;
     } else {
          g = 1 + 4 * (xmin + 0.75 * dx - x) / dx;
          b = 0;
     }

     int_r = (int) ( 255 * r);
     int_g = (int) ( 255 * g);
     int_b = (int) ( 255 * b);
}

Vector* create_vector()
{
   Vector *node;

   node = (Vector *) malloc(sizeof(Vector));
   node->size = 0;
   node->capacity = 100;
   node->data = (int *)malloc(sizeof(int)*node->capacity);

   return node;
}

void push_CC(CC_Head *vct, Vector value)
{
   Vector *tmp;

   if (vct->size == vct->capacity)
   {
      vct->capacity += 100;
      tmp = (Vector*) malloc (sizeof(Vector)*vct->capacity);
      memcpy(tmp, vct->data, (vct->capacity - 100)*sizeof(Vector));
      free(vct->data);
      vct->data = tmp;
   }

   vct->data[vct->size++] = value;

}

void push_back(Vector *vct, int value)
{
   int *tmp;

   if (vct->size == vct->capacity)
   {
      vct->capacity += 100;
      tmp = (int*) malloc (sizeof(int)*vct->capacity);
      memcpy(tmp, vct->data, (vct->capacity - 100)*sizeof(int));
      free(vct->data);
      vct->data = tmp;
   }

   vct->data[vct->size++] = value;

}

inline int index(int x, int y)
{
   return y*image_width + x;
}

inline int y_axis(int index)
{
   return index / image_width;
}

inline int x_axis(int index)
{
   return index % image_width;
}

// Function: file_exist
// check whether a file is existed or not.
bool file_exist(char *fn)
{
   FILE *fd = fopen(fn, "r");

   if (fd == NULL)
   {
      return false;
   } else {
      fclose(fd);
      return true;
   }
   
}

int image_centroid(BYTE **im)
{
   int sum_x = 0;
   int sum_y = 0;
   int num_pts = 0;

   for (int i = 0; i < image_height * image_width; i ++ )
   {
      if ( im[0][i] == BLACK ) {
         sum_x += x_axis(i);
         sum_y += y_axis(i);
         num_pts ++;
      }
   }

   return index((int)(sum_x/(float)num_pts), (int)(sum_y/(float)num_pts));
}

/* 
//	Function: set_distance_table
//
//  Set up the distance look up table for symmetry line finding.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return DIST **lut, distance lookup table, to locate the most similiar image.
//
//	Algorithms:
//	- Using watering method for the pixels which are not belong to the image (WHITE)
//	- Set the image to be 3w*h, assuming symmetry line is vertical.
//	- Calculate the Manhanttan distance for each pixel to the nearest pixel, which belongs to the image.
*/
DIST ** set_distance_table(BYTE**image, int img_h, int img_w)
{
   int h = img_h;
   int w = 3 * img_w;
   int x, y;
   size_t i;
   int span_steps;
   int count = 0;
   Vector *temp_node_vector, *node_vector;
   DIST **lut;

   lut = (DIST**)malloc(sizeof(DIST*)*h);
   lut[0] = (DIST*)malloc(sizeof(DIST)*h*w);
   for (y=0; y<h; y++)
      lut[y] = lut[0] + w*y;

   // Init the LUT.
   // use watering method.
   node_vector = create_vector();

   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (x > img_w && x < 2*img_w && image[y][x-img_w] == BLACK)
         {
            lut[y][x] = 0;
            push_back(node_vector,x);
            push_back(node_vector,y);
         }
         else 
            lut[y][x] = MAXIMUM;
      }

   span_steps = 1;
   temp_node_vector = create_vector();
   while (true)
   {
      for (i=0; i<node_vector->size; i=i+2)
      {
         int node_x = (node_vector->data)[i];
         int node_y = (node_vector->data)[i+1];
         int x, y;

         // Ignore the boundary rectangle first!
         if (node_x > 0 && node_x < w - 1 && node_y > 0 && node_y < h - 1)
         {

            y = node_y -1; x = node_x;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y -1; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y -1; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y ; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }

         }

      }

      span_steps ++;
      //printf("span %d\n", span_steps);

      //// number of new nodes > 0, if == 0, means all pixel has been watered.
      if (temp_node_vector->size == 0)
         break;

      free(node_vector->data);
      free(node_vector);
      node_vector = temp_node_vector;
      temp_node_vector = create_vector();
      //printf("node_vector size is %d", node_vector.size());


   }

   return lut;
}

// Function: mark_image
//
// mode:
// 0 - upperleft , 1 - upperrigth, 2 - bottomleft, 3 - bottomright
// 
// mark the image im to upperleft, upperright, bottomleft, bottomright
void mark_image(BYTE **im, int mode)
{
   const int MASK = 20;
   int starting_x, starting_y;

   switch (mode)
   {
      case 0:
         starting_x = 0;
         starting_y = 0;
         break;
      case 1:
         starting_x = image_width - MASK;
         starting_y = 0;
         break;
      case 2:
         starting_x = 0;
         starting_y = image_height - MASK;
         break;
      case 3:
         starting_x = image_width - MASK;
         starting_y = image_height - MASK;
         break;
      default:
         printf("wrong with the mode, exiting....\n");
         break;
   }

   for (int y = starting_y; y < starting_y + MASK; y++)
      for (int x = starting_x; x < starting_x + MASK; x++)
         im[y][x] = BLACK;
}

// Function: new_image
// Helper function to alloc a new image memory
BYTE** new_image(int h, int w)
{
   //make image from color to gray
   BYTE **dst;
   int y;

   dst = new BYTE* [h];
   dst[0] = new BYTE [h*w];
   for (y=0; y<h; y++)
      dst[y] = dst[0] + w*y;

   memset(dst[0], 0, h*w);
   return dst;
}

// Function: copy_image
// Helper function to copy the input image
//
// Return- new image as a copy to the src
BYTE** copy_image(BYTE **src, int h, int w)
{
   //make image from color to gray
   BYTE **dst;

   dst = new_image(h, w);
   memcpy(dst[0], src[0], h*w);

   return dst;
}

// Function: copy_file
// Helper function to copy the input file
//
void copy_file(char *orig_fn, char *dest_fn)
{
   if ( !file_exist(orig_fn) ) {
      printf("Error: file %s is not existed!\n", orig_fn);
      return;
   }

   char str_line[1000];
   FILE *fd_in = fopen(orig_fn, "r");
   FILE *fd_out = fopen(dest_fn, "w");
   assert( fd_in && fd_out );

   while ( fgets(str_line, 1000, fd_in ) ) {
      fprintf(fd_out, "%s", str_line);
   }

   fclose(fd_in);
   fclose(fd_out);
}


// Function: draw_symmetry
// Helper function to draw a line along x
//
//
void draw_symmetry(BYTE **&image, int h, int x)
{
   for (int y=0; y<h; y++)
      image[y][x] = BLACK;
}

// Function: reversImage
// Helper function to reverse a binary image
//
void reversImage(BYTE **&mimio_image, int h, int w)
{
   for (int y=0; y<h; y++)
      for(int x=0; x<w; x++)
      {
         if (mimio_image[y][x] == BLACK)
            mimio_image[y][x] = WHITE; // This is for white color;
         else mimio_image[y][x] = BLACK; // This is for Black color;
      }

}

// Function: free_image
// Helper function to free a 2D image
//
void free_image(BYTE **src)
{
   // 2D image is alloced by MALLOC
   delete [] *src;
   delete [] src;
}

// Function: free_image_3D
// Helper function to free 3D image
//
void free_image_3D(BYTE ***src)
{
   // 3D image is alloced by NEW
   delete [] **src;
   delete [] *src;
   delete [] src;
}

/* 
//	Function: miss_data_recover
//
//  Recover the data based on the symmetry line.
//
//	Pre-conditions:
//		BYTE **image - image with missing data
//		int sym - symmetry line
//		int h - image height
//		int w - image width
//
//	Algorithm:
//	- Get the reflected pixel based on the symmetry line.
//	- Recover the missing data based on 3x3 kernel.
*/
void miss_data_recover(BYTE **mimio_image, int sym, int h, int w)
{
   // copy the old image to the new image;
   BYTE **new_image = NULL;
   int x, y;

   new_image = copy_image(mimio_image, h, w);

   for (y = 1; y < h-1; y ++)
      for (x = 1; x < w-1; x ++)
         if (new_image[y][x] == BLACK)
         {
            // Calculate the reflected pixel.
            int x_prime = 2*sym - x; // No matter x > sym or x < sym.
            if (x_prime > w-1 || x_prime < 1) 
               continue;
            // Check the neigbour points of the reflected pixel.
            if (new_image[y][x_prime] == WHITE 
                && new_image[y-1][x_prime-1] == WHITE && new_image[y][x_prime+1] == WHITE
                && new_image[y-1][x_prime] == WHITE && new_image[y+1][x_prime-1] == WHITE
                && new_image[y-1][x_prime+1] == WHITE && new_image[y+1][x_prime] == WHITE
                && new_image[y][x_prime-1] == WHITE && new_image[y+1][x_prime+1] == WHITE )

               mimio_image[y][x_prime] = BLACK;

         }

   free_image(new_image);

}

/* 
//	Function: find_symmetry
//
//  Find the symmetry line on the image.
//
//	Assumptions: 
//		- The image is rectified.
//		- Only translation of X axis for the symmetry line.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		DIST **lut - distance lookup table to located the most similiar image.
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the symmetry line for the image.
//
//	Algorithms:
//	- The distance lookup table, lut, has been calculated for each pixel, refer to <set_distance_table> to details.
//	- Sum up the symmetry distance for each potential symmetry line, and get the least one.
*/
int find_symmetry(DIST **lut, BYTE**image, int h, int img_w)
{
   int start = 0, end = img_w;
   int *s_value = new int[img_w];
   int i;
   int x, y;
   int result = 0, max_dis = 500000;

   for (i=start; i < end; i++)
   {
      s_value[i] = 0;
      for (y = 0; y < h; y++)
         for (x = img_w; x < 2*img_w; x++)
         {
            if (image[y][x-img_w] == BLACK)
            {
               if (x >= img_w + i)
               {
                  s_value[i] += lut[y][x - 2*(x-img_w-i)];
               }
               else 
               {
                  s_value[i] += lut[y][x + 2*(img_w+i - x)];
               }
            }

         }
   }

   for (i=start; i < end; i++)
   {
      if (s_value[i] < max_dis)
      {
         result = i;
         max_dis = s_value[i];
      }
   }

   delete []s_value;
   return result;

}

// compute the inverse of matrix
//
// step 0: alloc 2D float array
float **matrix_malloc(int k)
{
   float **result = (float **)  malloc ( k * sizeof (float *));
   result[0] = (float *) malloc ( k * k * sizeof(float) );
   for (int i = 1; i < k; i ++)
      result[i] = result[0] + i * k;
   memset(result[0], 0, k*k);

   return result;
}

// step 1: compute the determinant of a matrix;
float matrix_detrm(float **a, int k)
{
   assert( k < 10 );
   
   float s=1,det=0;
   float **b = matrix_malloc(10);
   int i,j,m,n,c;
   if(k==1)
   {
      return(a[0][0]);
   }
   else
   {
      det=0;
      for(c=0;c<k;c++)
      {
         m=0;
         n=0;
         for(i=0;i<k;i++)
         {
            for(j=0;j<k;j++)
            {
               b[i][j]=0;
               if(i!=0&&j!=c)
               {
                  b[m][n]=a[i][j];
                  if(n<(k-2))
                     n++;
                  else
                  {
                     n=0;
                     m++;
                  }
               }
            }
         }
         det=det+s*(a[0][c]*matrix_detrm(b,k-1));
         s=-1*s;
      }
   }
   return det;
}

// compute the inverse of matrix
//
// step 2: compute the transpose of a matrix;
float **matrix_transpose(float **a, int k)
{
   int i, j;

   float **result = matrix_malloc(k);
   
   for(i=0;i<k;i++)
   {
      for(j=0;j<k;j++)
      {
         result[i][j]=a[j][i];
      }
   }

   return result;
}


float **compute_inverse_matrix(float **num, int dim)
{
   assert(dim < 10);
   float **b = matrix_malloc(10);
   float **fac = matrix_malloc(10);
   int p,q,m,n,i,j, f = dim;
   for(q=0;q<f;q++)
   {
      for(p=0;p<f;p++)
      {
         m=0;
         n=0;
         for(i=0;i<f;i++)
         {
            for(j=0;j<f;j++)
            {
               b[i][j]=0;
               if(i!=q&&j!=p)
               {
                  b[m][n]=num[i][j];
                  if(n<(f-2))
                     n++;
                  else
                  {
                     n=0;
                     m++;
                  }
               }
            }
         }
         fac[q][p]=pow(-1.0,q+p)*matrix_detrm(b,f-1);
      }
   }

   return matrix_transpose(fac, dim);
}

// compute the plane based on 3 points
// input:
//       3 3D points.
// output:
//       the plane and its normal
// Reference:
//  http://local.wasp.uwa.edu.au/~pbourke/geometry/planeeq/  - Equaltion of a Plan
//  http://www.netcomuk.co.uk/~jenolive/vect13.html  - Normal of a plane
//  http://www.softsurfer.com/Archive/algorithm_0104/algorithm_0104B.htm#intersect3D_2Planes%28%29 - Intersection of two planes

// http://en.wikipedia.org/wiki/Cross_product
// a ?b = (a2b3 - a3b2) i + (a3b1 - a1b3) j + (a1b2 - a2b1) k = (a2b3 - a3b2, a3b1 - a1b3, a1b2 - a2b1).
inline void cross_product(POINT_3D &v1, POINT_3D &v2, POINT_3D &result)
{
   result.x = v1.y * v2.z - v1.z * v2.y;
   result.y = v1.z * v2.x - v1.x * v2.z;
   result.z = v1.x * v2.y - v1.y * v2.x;
}

inline float dot_product(POINT_3D &v1, POINT_3D &v2)
{
   return (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z);
}

inline float pt_distance(POINT_3D &v1, POINT_3D &v2)
{
   return sqrt((v1.x-v2.x)*(v1.x-v2.x) + (v1.y-v2.y)*(v1.y-v2.y) + (v1.z-v2.z)*(v1.z-v2.z));
}

void compute_unit_vector(POINT_3D &vec)
{
   float len2 = vec.x*vec.x + vec.y*vec.y + vec.z*vec.z;
   float len = sqrt(len2);
   vec.x = vec.x/len;
   vec.y = vec.y/len;
   vec.z = vec.z/len;
}
  
/* http://topic.csdn.net/t/20060313/10/4610386.html
   d^2   =   (x3-x1)^2   +   (y3-y1)^2   +   (z3-z1)^2   -
   [(x2-x1)*(x3-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z3-z1)]^2/[(x2-x1)^2+(y2-y1)^2+(z2-z1)^2]
   if d -> 0, colinear!!!
*/
PLANE_3D* compute_plane_from_3D_pts(POINT_3D &p1, POINT_3D &p2, POINT_3D &p3)
{
   PLANE_3D *plane = (PLANE_3D *)malloc(sizeof(PLANE_3D));

   POINT_3D vec_12, vec_23;
   vec_12.x = p1.x - p2.x;
   vec_12.y = p1.y - p2.y;
   vec_12.z = p1.z - p2.z;
   compute_unit_vector(vec_12);
   
   vec_23.x = p2.x - p3.x;
   vec_23.y = p2.y - p3.y;
   vec_23.z = p2.z - p3.z;
   compute_unit_vector(vec_23);

   /*
   float angle_vec = dot_product(vec_12, vec_23);
   if (abs(angle_vec) > 0.95 && abs(angle_vec) < 1.05 ) {
      printf("ERROR: This three points is colinear!!!!!\n");
      printf("[%f, %f, %f], [%f, %f, %f], [%f, %f, %f]\n", p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
      exit(0);
      return NULL;
   }
   */

   float dis  =   (p3.x-p1.x)*(p3.x-p1.x) + (p3.y-p1.y)*(p3.y-p1.y) + (p3.z-p1.z)*(p3.z-p1.z) - 
                  (((p2.x-p1.x)*(p3.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)+(p2.z-p1.z)*(p3.z-p1.z)) * 
                   ((p2.x-p1.x)*(p3.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)+(p2.z-p1.z)*(p3.z-p1.z)) )/ 
                   ((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)+(p2.z-p1.z)*(p2.z-p1.z)) ;
   if ( dis * dis < 0.1 ) {
      printf("WARNING: These three points is colinear!!!!!\n");
      printf("[%f, %f, %f], [%f, %f, %f], [%f, %f, %f]\n", p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
      // exit(0);
      return NULL;
   }

   plane->A = p1.y * (p2.z - p3.z) + p2.y * (p3.z - p1.z) + p3.y * (p1.z - p2.z);
   plane->B = p1.z * (p2.x - p3.x) + p2.z * (p3.x - p1.x) + p3.z * (p1.x - p2.x);
   plane->C = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
   plane->D = - ( p1.x * (p2.y*p3.z - p3.y*p2.z) + p2.x * (p3.y*p1.z - p1.y*p3.z) + p3.x * (p1.y*p2.z - p2.y*p1.z) );
   cross_product(vec_12, vec_23, plane->N);
   plane->V = p1;

   return plane;
   
}

POINT_3D* compute_intersection_line_from_2_planes(PLANE_3D &Pn1, PLANE_3D &Pn2, POINT_3D &p0, POINT_3D &p1)
{
    POINT_3D u;
    cross_product(Pn1.N, Pn2.N, u);  // cross prouduct 
    float    ax = (u.x >= 0 ? u.x : -u.x);
    float    ay = (u.y >= 0 ? u.y : -u.y);
    float    az = (u.z >= 0 ? u.z : -u.z);

    const float SMALL_NUM = 0.001; // anything that avoids division overflow
    // test if the two planes are parallel
    if ((ax+ay+az) < SMALL_NUM) {       // Pn1 and Pn2 are near parallel
       printf("ERROR: Two planes are parallel\n");
       return NULL;
    }

    // Pn1 and Pn2 intersect in a line
    // first determine max abs coordinate of cross product
    int      maxc;                      // max coordinate
    if (ax > ay) {
        if (ax > az)
             maxc = 1;
        else maxc = 3;
    }
    else {
        if (ay > az)
             maxc = 2;
        else maxc = 3;
    }

    // next, to get a point on the intersect line
    // zero the max coord, and solve for the other two
    POINT_3D iP;               // intersect point
    float    d1, d2;           // the constants in the 2 plane equations
    d1 = - dot_product(Pn1.N, Pn1.V);  // note: could be pre-stored with plane
    d2 = - dot_product(Pn2.N, Pn2.V);  // ditto

    switch (maxc) {            // select max coordinate
    case 1:                    // intersect with x=0
        iP.x = 0;
        iP.y = (d2*Pn1.N.z - d1*Pn2.N.z) / u.x;
        iP.z = (d1*Pn2.N.y - d2*Pn1.N.y) / u.x;
        break;
    case 2:                    // intersect with y=0
        iP.x = (d1*Pn2.N.z - d2*Pn1.N.z) / u.y;
        iP.y = 0;
        iP.z = (d2*Pn1.N.x - d1*Pn2.N.x) / u.y;
        break;
    case 3:                    // intersect with z=0
        iP.x = (d2*Pn1.N.y - d1*Pn2.N.y) / u.z;
        iP.y = (d1*Pn2.N.x - d2*Pn1.N.x) / u.z;
        iP.z = 0;
    }

    {
       p0.x = iP.x; p0.y = iP.y; p0.z = iP.z;
       p1.x = p0.x + u.x;
       p1.y = p0.y + u.y;
       p1.z = p0.z + u.z;
    }

    POINT_3D *res = (POINT_3D *) malloc(sizeof(POINT_3D));
    res->x = u.x;
    res->y = u.y;
    res->z = u.z;
    
    return res;
}

// compute_dist_point_to_line(): get the distance of a point to a line.
//    Input:  a Point P and a Line L (in any dimension)
//    Return: the shortest distance from P to L
//    http://www.softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm#dist_Point_to_Line%28%29
float compute_dist_point_to_line( POINT_3D &P, POINT_3D &L_P0, POINT_3D &L_P1)
{
    POINT_3D v, w;
    v.x = L_P1.x - L_P0.x;
    v.y = L_P1.y - L_P0.y;
    v.z = L_P1.z - L_P0.z;
    w.x = P.x - L_P0.x;
    w.y = P.y - L_P0.y;
    w.z = P.z - L_P0.z;

    float c1 = dot_product(w,v);
    float c2 = dot_product(v,v);
    float b = c1 / c2;

    POINT_3D Pb;
    Pb.x = L_P0.x + b * v.x;
    Pb.y = L_P0.y + b * v.y;
    Pb.z = L_P0.z + b * v.z;

    return sqrt((P.x - Pb.x)*(P.x - Pb.x) +
                (P.y - Pb.y)*(P.y - Pb.y) +
                (P.z - Pb.z)*(P.z - Pb.z));
}

#ifdef LINUX

void Save2File(char* fname, BYTE **image0, CImg<unsigned char> *bitmap, int image_W, int image_H, int color, BYTE ***image_color, int save_format)
{
   int h, w;

   if (image_W != 0 && image_H != 0 )
   {
      h = image_H;
      w = image_W;
   }
   else {
      
      if (bitmap)
      {
         h = bitmap->dimy();
         w = bitmap->dimx();
      }
      else
      {
         h = image_height;
         w = image_width;
      }
   }

   if (!color)
   {
      BYTE **image;
      // make a copy of the original image. do NOT change the image to be saved.
      image = copy_image(image0, h, w);
      for (int i = 0; i < h; i ++)
         for (int j = 0; j < w; j++)
            image[i][j] = 255*(1-image[i][j]);
   
      if (image != NULL && ( image_W == 0 || image_H ==0) )
      {
         CImg<BYTE> newbitmap = CImg<BYTE>(*image,w,h,1,1,false);
         newbitmap.SAVE_FORMAT(fname);
      }
      else if (image != NULL)
      {
         h = image_H;
         w = image_W;	
         CImg<BYTE> newbitmap = CImg<BYTE>(*image,w,h);
         newbitmap.SAVE_FORMAT(fname);
      }
      else bitmap->SAVE_FORMAT(fname);

   } else {
      
      //CImg<BYTE> newbitmap = CImg<BYTE>(**image_color,w,h,1,3,false);
      
      CImg<BYTE> newbitmap = CImg<BYTE>(w,h,1,3,false);
      for (int y = 0 ; y < h; y++)
         for (int x = 0; x < w; x++)
         {
            newbitmap(x, y, 0, 0) = image_color[y][x][0];
            newbitmap(x, y, 0, 1) = image_color[y][x][1];
            newbitmap(x, y, 0, 2) = image_color[y][x][2];
         }
               
      newbitmap.SAVE_FORMAT(fname);
   }

}

CImg<unsigned char> * load_image(char *file_name, int &h, int &w)
{
   CImg<unsigned char> *bitmap;

   // check whether this file is existed or not.
   if (!file_exist(file_name)) {
      printf("ERROR: %s is not existed!\n", file_name);
      exit(0);
   }
   
   bitmap = new CImg<BYTE>(file_name);
   h = bitmap->dimy();
   w = bitmap->dimx();

   image_height = h;
   image_width  = w;

   return bitmap;
}

BYTE ** load_image_array(char *file_name, int &h, int &w)
{

   CImg<unsigned char> *bitmap = load_image(file_name, h, w);
   BYTE **cur_im;
   set_image(cur_im, bitmap);
   delete bitmap;

   return cur_im;
}

void grayimage(CImg<unsigned char> *bitmap, BYTE **image)
{

   int x, y;
   int h = bitmap->dimy();
   int w = bitmap->dimx();

   for (y=0; y<h; y++)
      for (x=0; x<w; x++)
      {
         image[y][x] = (BYTE)((*bitmap)(x,y,0)*0.299 + (*bitmap)(x,y,1)*0.587 + (*bitmap)(x,y,2)*0.114);
      }   
}

void get_image(BYTE **image, CImg<BYTE> *bitmap)
{

   int h = bitmap->dimy();
   int w = bitmap->dimx();
   int x,y;

   grayimage(bitmap, image);

   //convert to black-white image 
   int threshold = 150;
   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (image[y][x]>threshold)
            image[y][x] = WHITE; // This is for white color;
         else image[y][x] = BLACK; // This is for Black color;
      }
   
}

void set_image(BYTE **&image, CImg<BYTE> *bitmap)
{

   int h = bitmap->dimy();
   int w = bitmap->dimx();
   int x,y;

   image_height = h;
   image_width  = w;
   
   //make image from color to gray
   image = new BYTE* [h];
   image[0] = new BYTE [h*w];
   for (y=0; y<h; y++)
      image[y] = image[0] + w*y;

   grayimage(bitmap, image); 


   //convert to black-white image 
   int threshold = 150;
   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (image[y][x]>threshold)
            image[y][x] = WHITE; // This is for white color;
         else image[y][x] = BLACK; // This is for Black color;
      }
   
}

int get_image_height(CImg<unsigned char> *bitmap)
{
   return  bitmap->dimy();
}

int get_image_width(CImg<unsigned char> *bitmap)
{
   return  bitmap->dimx();
}

#else

CLSID clsid;
int GetEncoderClsid(const WCHAR* format, CLSID* pClsid);
void Save2File(char* fname, BYTE **image, Bitmap *bitmap, int image_W, int image_H, int color, BYTE ***image_color, int save_format)
{
   int x, y;
   WCHAR wstr [1000];
   Status stat;

   mbstowcs(wstr, fname, 1000);
   if ( save_format == 0 ) {
      GetEncoderClsid(L"image/png", &clsid);
   } else {
      GetEncoderClsid(L"image/tiff", &clsid);
   }

   if (bitmap == NULL  && image != NULL)  // Save 1bit TIF image for ras2vec.
   {
      //image_W = image_width;   // ???
      //image_H = image_height;  // ???
      assert(image_W);
      assert(image_H);
      Bitmap *bm = new Bitmap(image_W,image_H,PixelFormat1bppIndexed);
      BitmapData objBmpData;
	  bm->LockBits(new Rect(0, 0,image_W, image_H),
                   ImageLockModeRead|ImageLockModeWrite,
                   PixelFormat1bppIndexed,
                   &objBmpData);
	  
      int line_num = image_W % 32 == 0 ? image_W/32 : image_W/32 + 1;
      line_num *= 4;

	  int byte_num = line_num*image_H;
	  memset(objBmpData.Scan0, 0xFF, byte_num);

      unsigned char *tt = (unsigned char *)objBmpData.Scan0;
	  for (y=0; y<image_H; y++)
         for (x=0; x<image_W; x++)
		 {
            if (image[y][x] == BLACK)
			{
               int loc = line_num*y+x/8;
               BYTE re = ~(1 << (7 - x % 8));
               *(tt+loc) &=  re;
			}
         }

	  bm->UnlockBits(&objBmpData);

      stat = bm->Save(wstr, &clsid, NULL);
      if(stat != Ok)
         cout<<fname<<" saved failed."<<endl;

      delete bm;
      return;
   }
   
   if (!color)
   {
      if (image != NULL && ( image_W == 0 || image_H ==0) ) // Save BLACK/WHITE image
      {
         int h = bitmap->GetHeight();
         int w = bitmap->GetWidth();	
         Bitmap * newbitmap = new Bitmap(w,h);
         for (y=0; y<h; y++)
            for (x=0; x<w; x++)
               newbitmap->SetPixel(x,y,Color((1-image[y][x])*255,(1-image[y][x])*255,(1-image[y][x])*255));


         stat = newbitmap->Save(wstr, &clsid, NULL);
         //stat = newbitmap->Save(wstr, ImageFormat.pngf);

         delete newbitmap;

      }
      else if (image != NULL) // Save GRAY image
      {
         int h = image_H;
         int w = image_W;	
         Bitmap * newbitmap = new Bitmap(w,h);
         for (y=0; y<h; y++)
            for (x=0; x<w; x++)
               newbitmap->SetPixel(x,y, Color( 0, image[y][x], 0));
         //               newbitmap->SetPixel(x,y,Color(image[y][x], image[y][x], image[y][x]));

         //stat = newbitmap->Save(wstr, clsid, NULL);
         stat = newbitmap->Save(wstr, &clsid, NULL);
        
         delete newbitmap;
      }

      else stat = bitmap->Save(wstr, &clsid, NULL);
      //stat = newbitmap->Save(wstr, clsid, NULL);
        
   } else {  // Save COLOR image

      int h, w;
      if (bitmap)
      {
         h = bitmap->GetHeight();
         w = bitmap->GetWidth();
      }
      else
      {
         h = image_H;
         w = image_W;
      }
      
      Bitmap * newbitmap = new Bitmap(w,h);
      for (y=0; y<h; y++)
         for (x=0; x<w; x++)
            newbitmap->SetPixel(x,y,Color(image_color[y][x][0],image_color[y][x][1],image_color[y][x][2]));

      stat = newbitmap->Save(wstr, &clsid, NULL);
      //stat = newbitmap->Save(wstr, ImageFormat.pngf);

      delete newbitmap;      
   }

   if(stat != Ok)
      cout<<fname<<" saved failed."<<endl;
   
}

Bitmap * load_image(char *file_name, int &h, int &w)
{
   Bitmap *bitmap;

   // check whether this file is existed or not.
   if (!file_exist(file_name)) {
      printf("ERROR: %s is not existed!\n", file_name);
      exit(0);
   }
   
   wchar_t pwc[1000];
   mbstowcs( pwc, file_name, 1000);
   bitmap = new Bitmap(pwc);
   h = bitmap->GetHeight();
   w = bitmap->GetWidth();

   image_height = h;
   image_width  = w;

   return bitmap;
}

BYTE ** load_image_array(char *file_name, int &h, int &w)
{

   Bitmap *bitmap = load_image(file_name, h, w);
   BYTE **cur_im;
   set_image(cur_im, bitmap);
   delete bitmap;

   return cur_im;
}

void grayimage(Bitmap *bitmap, BYTE **image)
{	

   int x, y;
   Color i_color;
   int h = bitmap->GetHeight();
   int w = bitmap->GetWidth();

   for (y=0; y<h; y++)
      for (x=0; x<w; x++)
      {
         bitmap->GetPixel(x,y,&i_color);
         image[y][x] = (BYTE)(i_color.GetR()*0.299 + i_color.GetG()*0.587 + i_color.GetB()*0.114);
      }
}

int GetEncoderClsid(const WCHAR* format, CLSID* pClsid)
{
   UINT num = 0; // number of image encoders
   UINT size = 0; // size of the image encoder array in bytes
	
   ImageCodecInfo* pImageCodecInfo = NULL;

   GetImageEncodersSize(&num, &size);
   if(size == 0)
      return -1; // Failure

   pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
   if(pImageCodecInfo == NULL)
      return -1; // Failure

   GetImageEncoders(num, size, pImageCodecInfo);

   for(UINT j = 0; j < num; ++j)
   {
      if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 )
      {
         *pClsid = pImageCodecInfo[j].Clsid;
         free(pImageCodecInfo);
         return j; // Success
      }
   }

   free(pImageCodecInfo);
   return -1; // Failure
}


void get_image(BYTE **image, Bitmap *bitmap)
{

   int h = bitmap->GetHeight();
   int w = bitmap->GetWidth();
   int x,y;

   grayimage(bitmap, image);

   //convert to black-white image 
   int threshold = 150;
   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (image[y][x]>threshold)
            image[y][x] = WHITE; // This is for white color;
         else image[y][x] = BLACK; // This is for Black color;
      }

}

#if 1
void set_image(BYTE **&image, Bitmap *bitmap)
{

   int h = bitmap->GetHeight();
   int w = bitmap->GetWidth();
   int x,y;

   image_height = h;
   image_width  = w;
   
   //make image from color to gray
   image = new BYTE* [h];
   image[0] = new BYTE [h*w];
   for (y=0; y<h; y++)
      image[y] = image[0] + w*y;

   int size = h * w;
   Color i_color;
   for (int i = 0; i < size; i ++ )
   {
      x = x_axis(i);
      y = y_axis(i);
      bitmap->GetPixel(x,y,&i_color);
      if ( ! i_color.GetR() && ! i_color.GetG() && ! i_color.GetB() )
         image[0][i] = BLACK; // This is for white color;
      else
         image[0][i] = WHITE; // This is for Black color;
   }

}
#else
void set_image(BYTE **&image, Bitmap *bitmap)
{

   int h = bitmap->GetHeight();
   int w = bitmap->GetWidth();
   int x,y;

   image_height = h;
   image_width  = w;
   
   //make image from color to gray
   image = new BYTE* [h];
   image[0] = new BYTE [h*w];
   for (y=0; y<h; y++)
      image[y] = image[0] + w*y;

   grayimage(bitmap, image); 


   //convert to black-white image 
   int threshold = 150;
   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (image[y][x]>threshold)
            image[y][x] = WHITE; // This is for white color;
         else image[y][x] = BLACK; // This is for Black color;
      }

}
#endif

int get_image_height(Bitmap *bitmap)
{	
   return bitmap->GetHeight();
}

int get_image_width(Bitmap *bitmap)
{	
   return bitmap->GetWidth();
}

#endif

inline int count_image_data_points_with_mask(BYTE **im, int mask, int x0, int y0)
{
   int total_num = image_width * image_height;
   int return_num = 0;
   for (int x = x0; x < x0 + mask; x ++)
      for (int y = y0; y < y0 + mask; y ++)
         if ( x >= 0 && x < image_width &&
              y >= 0 && y < image_height &&
              im[y][x] == BLACK ) {
            return_num ++;
         }

   return return_num;
}

inline int count_image_data_points(BYTE **im, BYTE **ref_im = NULL)
{
   int total_num = image_width * image_height;
   int return_num = 0;
   int matched_num = 0;
   for (int i = 0 ; i < total_num; i ++ )
      if ( im[0][i] == BLACK ) {
         return_num ++;
         if ( ref_im && ref_im[0][i] == BLACK )
            matched_num ++;
      }

   return ref_im != NULL ? matched_num : return_num;
}

void copy_image(BYTE **src, BYTE **&dst, int h, int w)
{
   //make image from color to gray
   dst = new BYTE* [h];
   dst[0] = new BYTE [h*w];
   for (int y=0; y<h; y++)
      dst[y] = dst[0] + w*y;

   memcpy(dst[0], src[0], h*w);
}

// Function: digit_string
//
// num - number of string characters
// counter - the actual digit
// For example: "00100" - digit_string(5, 100);
char *digit_string(int num, int counter)
{
   char *result = (char *)malloc(num+1);
   char *str_pad = (char *)malloc(num);

   int bigNum = 1;
   int k = 0;
   for (int i = 0 ; i < num-1; i++)
   {
      bigNum *= 10;
      
      if (counter / bigNum == 0)
         str_pad[k++] = '0';

   }
   str_pad[k] = 0;
   
   sprintf(result, "%s%d", str_pad, counter);
   free(str_pad);
   return result;
   
}

/*
  Function: preprocess_2_c
	
  C code of preprocess for noise reduction. Click <C_Preprocess_2.c> to show the source code. This processing will be deprecated because of the enhancement of preprocess 1.

  Algorithms:
  - Remove the isolated noise <remove_isolation>
  - Using pudo-thinning to get the boundary of the image <psu_thinning>.
*/



/* 
//	Function: psu_thinning
//
//  Look for the boundary pixels for the building.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the image with new value copied.
//
//	Algorithms:
//	- create a brand new white image.
//	- search for boundary pixel: top=>bottom; bottom=>top; left=>right; right=>left;
//	- copy back to the original image.
*/
void psu_thinning(BYTE **mimio_image, int h, int w)
{
   int i, j, y;
   BYTE ** image;

   image = (BYTE**)malloc(sizeof(BYTE*)*h);
   image[0] = (BYTE*)malloc(sizeof(BYTE)*h*w);
   for (y=0; y<h; y++)
      image[y] = image[0] + w*y;

   for (j = 0; j < h; j++)
      for (i=0; i < w; i++)
         image[j][i] = WHITE;

   for (i = 0; i < w; i++)
   {
      // from top to botton
      for (j = 0; j < h; j++)
         if (mimio_image[j][i] == BLACK)
         {
            image[j][i] = BLACK;
            break;
         }

      // from bottom to top 
      for (j = h-1; j >= 0; j--)
         if (mimio_image[j][i] == BLACK)
         {
            image[j][i] = BLACK;
            break;
         }
   }

   for (j = 0; j < h; j++)
   {
      // from left to right
      for (i = 0; i < w; i++)
         if (mimio_image[j][i] == BLACK)
         {
            image[j][i] = BLACK;
            break;
         }

      // from right to left 
      for (i = w-1; i >= 0; i--)
         if (mimio_image[j][i] == BLACK)
         {
            image[j][i] = BLACK;
            break;
         }
   }

   for (j = 0; j < h; j++)
      for (i = 0; i < w; i ++)
         mimio_image[j][i] = image[j][i];

   free(image[0]);
   free(image);


}


/* 
//	Function: prior_remove
//
//  Remove the noise based on prior knowledge (cheating for simplify purpose).
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the orignal image; the value has been changed.
//
//	Algorithms:
//	remove the noise based on building prior knowledge
*/
void prior_remove(BYTE **mimio_image, int h, int w)
{
   int x_min = 105, x_max= 425;
   int y_min = 130, y_max = 260;
   int i, j;

   for (i = 0; i < x_min; i++)
   {
      for (j=0; j<h; j++)
         mimio_image[j][i] = WHITE;
   }

   for (i = x_max; i < w; i++)
   {
      for (j=0; j<h; j++)
         mimio_image[j][i] = WHITE;
   }

   for (i = 0; i < y_min; i++)
   {
      for (j=0; j<w; j++)
         mimio_image[i][j] = WHITE;
   }

   for (i = y_max; i < h; i++)
   {
      for (j=0; j<w; j++)
         mimio_image[i][j] = WHITE;
   }

}

/* 
//	Function: remove_isolation
//
//  Remove the isolated noise.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the orignal image; the value has been changed.
//
//	Algorithms:
//	remove the noise outside of 40 pixel; crop the image
*/
void remove_isolation(BYTE **mimio_image, int h, int w)
{
   int THRESH = 40;
   int i, j;

   for (i = 0; i < THRESH; i++)
   {
      for (j=0; j<h; j++)
         mimio_image[j][i] = WHITE;
      for (j=0; j<w; j++)
         mimio_image[i][j] = WHITE;
   }

   for (i = w - THRESH; i < w; i++)
   {
      for (j=0; j<h; j++)
         mimio_image[j][i] = WHITE;
   }

   for (i = h - THRESH; i < h; i++)
   {
      for (j=0; j<w; j++)
         mimio_image[i][j] = WHITE;
   }

}

/* 
//	Function: item_seg
//
//  Set up the distance look up table for symmetry line finding.
//		
//	Pre-conditions:
//		int x, y - current pixel
//		Vector *vct - the vector recording all pixel in current CC.
//		int *seg_pixels - number of pixels in this CC, not used so far.
//		BYTE **image - image to be computed
//		BYTE **lut - LUT for the pixels
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the LUT and the vector.
//
//	Algorithms:
//	Using the vector to construct the CC.
*/

void item_seg(int y, int x, BYTE **image, BYTE **item_LUT, Vector *vct, int* seg_pixels, int h, int w)
{
   if (x<1 || x>w-2 || y<1 || y>h-2)
   {
      return;
   }
   
   if (item_LUT[y][x] == 1) 
      return ;

   if ( vct ) {
      push_back(vct, x);
      push_back(vct, y);
   }

   item_LUT[y][x] = 1;
   (*seg_pixels) ++;
	
   if (image[y-1][x] == BLACK) 
   {
      item_seg(y-1,x,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y-1][x+1] == BLACK) 
   {
      item_seg(y-1,x+1,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y][x+1] == BLACK) 
   {
      item_seg(y,x+1,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y+1][x+1] == BLACK) 
   {
      item_seg(y+1,x+1,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y+1][x] == BLACK) 
   {
      item_seg(y+1,x,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y+1][x-1] == BLACK) 
   {
      item_seg(y+1,x-1,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y][x-1] == BLACK) 
   {
      item_seg(y,x-1,image,item_LUT,vct,seg_pixels, h, w);
   }
   if (image[y-1][x-1] == BLACK) 
   {
      item_seg(y-1,x-1,image,item_LUT,vct,seg_pixels, h, w);
   }

}

void item_seg_vector(int y0, int x0, BYTE **image, BYTE **item_LUT, int* seg_pixels, int h, int w, vector<int> *vct_x = NULL, vector<int> *vct_y = NULL)
{
   // replace recursive function with fix-point computing

   vector<int> init_pts;
   init_pts.push_back(index(x0, y0));
   
   while (true ) {

      vector<int> new_pts(init_pts);
      init_pts.clear();
      for (int i = 0; i < new_pts.size(); i ++ )
      {

         int x = x_axis(new_pts[i]);
         int y = y_axis(new_pts[i]);
         
         if (x<1 || x>w-2 || y<1 || y>h-2)
         {
            continue;
         }
      
         if (item_LUT[y][x] == 1) 
            continue ;
         
         if ( vct_x ) {
            vct_x -> push_back(x);
         }
         if ( vct_y ) {
            vct_y -> push_back(y);
         }

         item_LUT[y][x] = 1;
         (*seg_pixels) ++;
	
         if (image[y-1][x] == BLACK) 
         {
            init_pts.push_back(index(x, y-1));
         }
         
         if (image[y-1][x+1] == BLACK) 
         {
            init_pts.push_back(index(x+1, y-1));
         }

         if (image[y][x+1] == BLACK) 
         {
            init_pts.push_back(index(x+1, y));
         }
         
         if (image[y+1][x+1] == BLACK) 
         {
            init_pts.push_back(index(x+1, y+1));
         }

         if (image[y+1][x] == BLACK) 
         {
            init_pts.push_back(index(x, y+1));
         }
         
         if (image[y+1][x-1] == BLACK) 
         {
            init_pts.push_back(index(x-1, y+1));
         }
         
         if (image[y][x-1] == BLACK) 
         {
            init_pts.push_back(index(x-1, y));
         }
         
         if (image[y-1][x-1] == BLACK) 
         {
            init_pts.push_back(index(x-1, y-1));
         }
         
      }

      if (init_pts.size() == 0)
         break;
   }

}

/* 
//	Function: remove_ins_cc
//
//  Remove the noise falling inside of the building
//		
//	Pre-conditions:
//		CC_Head *cc_head - pointing to the head of the CCs.
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the image with noise removed
//
//	Algorithms:
//	- call <psu_thinning> to get the boundary pixels.
//	- Calculate the number of pixels in CC which belongs to the boundary pixels. Using a threshold here.
*/

void remove_ins_cc(CC_Head *cc_head, BYTE **img, int h, int w)
{
   CC_Head *temp = cc_head;
   Vector *vct;
   int x, y;
   size_t i, j, total_val;
	
   // algorithm 1:
   BYTE **tmp_img = copy_image(img, h, w);
	
   // tmp_img is the boundary image of the building.
   psu_thinning(tmp_img, h, w);
	
   for (i = 0; i < temp->size; i++)
   {
      vct = temp->data + i;
      total_val = 0;
      for (j = 0; j < vct->size; j++)
      {
         x = vct->data[j++];
         y = vct->data[j];
         if (tmp_img[y][x] == BLACK)  // redundant condition? (NO - count the boundary points)
            total_val ++;

      }

      // count the number of boundary points.
      if ((total_val < (vct->size)/4 + 1) && (total_val < 10)) // total_val < 10 used for case 39, where the boundary points are connected with inner points heavily.
      {
         for (j = 0; j < vct->size; j=j+2)
            img[vct->data[(j+1)]][vct->data[j]] = WHITE;
      }

   } // end of i;

   free(tmp_img[0]);
   free(tmp_img);
}

/* 
//	Function: create_cc
//
//  creat the CC for further usage.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return CC_Head* pointing to the head of the CC.
//
//	Algorithms:
//	Call the <item_seg> to create CC.
*/
CC_Head* create_cc(BYTE **mimio_image,  int h, int w)
{
   int x, y;
   CC_Head *cc_head_ptr;
   int *segment_pixels;
   Vector *cc_vct;
   BYTE **item_LUT;
	
   cc_head_ptr = (CC_Head*) malloc (sizeof(CC_Head));
   cc_head_ptr->size = 0;
   cc_head_ptr->capacity = 100;
   cc_head_ptr->data = (Vector *) malloc (sizeof(Vector)*cc_head_ptr->capacity);

   // Set up the LUT for the connective component
   item_LUT = (BYTE **)malloc(sizeof(BYTE*) *h);
   item_LUT[0] = (BYTE *)malloc(sizeof(BYTE)*h*w);
   for (y=0; y<h; y++)
      item_LUT[y] = item_LUT[0] + y * w; 
   for (y=0; y < h; y++)
      for (x=0; x<w; x++)
         item_LUT[y][x] = 0;


   //Segment the items.
   segment_pixels = (int *)malloc(sizeof(int));
   *segment_pixels = 0;

   for (y=1; y<h-1; y++)
   {
      for(x=1; x<w-1; x++)
      {
         if (mimio_image[y][x] == BLACK && item_LUT[y][x] == 0)
         {
            cc_vct = create_vector();
            item_seg(y,x,mimio_image,item_LUT,cc_vct,segment_pixels,h,w);
            push_CC(cc_head_ptr, *cc_vct);
         }
      }

   }

   free(item_LUT[0]);
   free(item_LUT);

   return cc_head_ptr;

}

/* 
//	Function: posterior_remove
//
//  Remove the noise based on some trickies in this projects.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the orignal image; the value has been changed.
//
//	Algorithms:
//	remove the noise based on building posterior_remove knowledge
*/

void posterior_remove(BYTE **image, int h, int w)
{
   //	int x_min = X_MIN + 15, x_max = X_MAX - 15;
   //	int y_min = Y_MIN, y_max = Y_MAX;
   int x_min = 105, x_max= 425;
   int y_min = 130, y_max = 260;
   int thresh = 40;
   int i, j;
   int up;

   psu_thinning(image, h, w);
	
   // psudo code for interior noise remove:
   // 1. get the left and right majority x value by choose 3 random points of y, say 170, 195, 230
   // 2. get the top and bottom majority y value, by similiar algorithm.
   // 3. remove the area between majority - 5 (threshold)
	
   // Even simple method:
   // crop the interior area (only works for case < 39)
   for (i = 125; i < 410; i++)
      for (j = 165; j < 235; j++)
         image[j][i] = WHITE;
		
   for (i = x_min; i < x_max; i++)
   {
      // from bottom to top 
      for (j = y_max; j >= y_min; j--)
      {
         if (image[j][i] == BLACK)
         { 
            for (up = 1; up < 10 ; up++)
               image[j-up][i] = WHITE;
				
            break;
         }
					
      }
   }	
}


/* 
//	Function: thinningImage
//
//  Thinning algorithm for image noise removal.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		The thinned image is pointed by **image.
//
//	Algorithms:
//	- Thinning LUT.
//	- Convolute the LUT N.E.W.S.
*/
void thinningImage(BYTE **image , int h, int w)
{
   BYTE THINNING_LUT[256] = {  1,1,1,0,1,1,0,0,1,1,0,0,0,1,0,0,
                               1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0, /*32*/
                               1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0, 
                               0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0, /*64*/
                               1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                               1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                               0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,
                               0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0, /*128*/
                               1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,
                               1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,
                               0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,
                               1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,
                               0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
                               0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0};


   int x, y;
   BYTE Bit_shift = 0;
   int is_done = 0;

   while (is_done == 0)
   {
      is_done = 1;  // To indicate no things to be changed.

      // First try to do north and south.
      // Starting from 1, we don't need to worry about the bounder.
      // Need to finish another part, i.e. the bouder situation.
      for (x=1; x<w-1; x++)   // thinning from north.
         for (y=1; y<h-1; y++ )
         {
            if (image[y][x] == BLACK)   
            {
               Bit_shift = (image[y-1][x] << 7) | (image[y-1][x+1] << 6) |
                  (image[y][x+1] << 5) | (image[y+1][x+1] << 4) |
                  (image[y+1][x] << 3) | (image[y+1][x-1] << 2) |
                  (image[y][x-1] << 1) | (image[y-1][x-1] );
               image[y][x] = THINNING_LUT[Bit_shift];
               if (image[y][x] != BLACK)
                  is_done = 0; // To indicate something changed.
               Bit_shift = 0;
					

               // Now test the next one to try to thin from north.
               for (y = y + 1; y < h-1 && image[y][x] == BLACK; ++y);
            }// end of if image[y][x] == 1;

         }// end of for.
		
      for (x=1; x<w-2; x++)   // thinning from south.
         for (y=h-2; y>0; y-- )
         {
            if (image[y][x] == BLACK)   
            {
               Bit_shift = (image[y-1][x] << 7) | (image[y-1][x+1] << 6) |
                  (image[y][x+1] << 5) | (image[y+1][x+1] << 4) |
                  (image[y+1][x] << 3) | (image[y+1][x-1] << 2) |
                  (image[y][x-1] << 1) | (image[y-1][x-1] );
               image[y][x] = THINNING_LUT[Bit_shift];
               if (image[y][x] != BLACK)
                  is_done = 0; // To indicate something changed.
               Bit_shift = 0;
					

               // Now test the next one to try to thin from south.
               for (y = y - 1; y > 1 && image[y][x] == BLACK; --y);
            }// end of if image[y][x] == 1;

         }// end of for.

      // Now try to do west and east.
      // Starting from 1, we don't need to worry about the bounder.
      // Need to finish another part, i.e. the bouder situation.
      for (y=1; y<h-1; y++ )   // thinning from west.
         for (x=1; x<w-1; x++)
         {
            if (image[y][x] == BLACK)   
            {
               Bit_shift = (image[y-1][x] << 7) | (image[y-1][x+1] << 6) |
                  (image[y][x+1] << 5) | (image[y+1][x+1] << 4) |
                  (image[y+1][x] << 3) | (image[y+1][x-1] << 2) |
                  (image[y][x-1] << 1) | (image[y-1][x-1] );
               image[y][x] = THINNING_LUT[Bit_shift];
               if (image[y][x] != BLACK)
                  is_done = 0; // To indicate something changed.
               Bit_shift = 0;
					

               // Now test the next one to try to thin from west.
               for (x = x + 1; x < w-1 && image[y][x] == BLACK; ++x);
            }// end of if image[y][x] == 1;

         }// end of for.

      for (y=1; y<h-1; y++ )    // thinning from east.
         for (x=w-2; x>1; x--)
         {
            if (image[y][x] == BLACK)   
            {
               Bit_shift = (image[y-1][x] << 7) | (image[y-1][x+1] << 6) |
                  (image[y][x+1] << 5) | (image[y+1][x+1] << 4) |
                  (image[y+1][x] << 3) | (image[y+1][x-1] << 2) |
                  (image[y][x-1] << 1) | (image[y-1][x-1] );
               image[y][x] = THINNING_LUT[Bit_shift];
               if (image[y][x] != BLACK)
                  is_done = 0; // To indicate something changed.
               Bit_shift = 0;
					

               // Now test the next one to try to thin from east.
               for (x = x - 1; x > 1 && image[y][x] == BLACK; --x);
            }// end of if image[y][x] == 1;

         }// end of for.

   } // end of while;
}

/* 
//	Function: preprocess
//  preprocess the image with algorithm 1.
//
//	Algorithms:
//		- Remove the isolated noise
//		- Thinning the binary image for further processing.
//		- Creating CC for inside noise removal
//		- Removing noise CC inside the building.
//		
*/
void preprocess(char *fn)
{
   int mrows, ncols;
   BYTE **image;

#ifdef LINUX
#else
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif

   wchar_t pwc[1000];
   char new_name[1000];

   strcpy(new_name, fn);
   mbstowcs( pwc, new_name, 1000);

#ifdef LINUX
   CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(new_name);
   int h = bitmap_mimio->dimy();
   int w = bitmap_mimio->dimx();
#else      
   Bitmap* bitmap_mimio = new Bitmap(pwc);
   int h = bitmap_mimio->GetHeight();
   int w = bitmap_mimio->GetWidth();
#endif      

   if (output_fn == NULL)
      sprintf(new_name, "pre1_%s", fn);
   else
      strcpy(new_name, output_fn);

   set_image(image,bitmap_mimio);
      
 
   // Algorithm
   //remove_isolation(image, h, w);
   thinningImage(image, h, w);

   CC_Head *cc_head_ptr = create_cc(image, h, w);
   remove_ins_cc(cc_head_ptr, image, h, w);
	
   // apply some tricky to remove noise for fitting
   // then, try to use chain code representation and apply reconstruction rules.
   //	posterior_remove(image, h, w);
   Save2File(new_name,image,bitmap_mimio,0,0, 0, NULL);

}

/* 
//	Function: preprocess_2
//
//  Interface function for C and Matlab for preprocessing.
//
//	Notes: 
//		the parameters for double *im; instead of unsigned char *im;
//		
//	Algorithms:
//		- Removing the isolated noise
//		- Doing psudo thinning processing to obtain the contour of the building, and remove all other noise.
//		
*/
void preprocess_2(char *fn)
{
   int mrows, ncols;
   BYTE **image;

#ifdef LINUX
#else   
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif    

   wchar_t pwc[1000];
   char new_name[1000];

   strcpy(new_name, fn);
   mbstowcs( pwc, new_name, 1000);

#ifdef LINUX
   CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(new_name);
   int h = bitmap_mimio->dimy();
   int w = bitmap_mimio->dimx();
#else      
   Bitmap* bitmap_mimio = new Bitmap(pwc);
   int h = bitmap_mimio->GetHeight();
   int w = bitmap_mimio->GetWidth();
#endif      
   if (output_fn == NULL)
      sprintf(new_name, "pre2_%s", fn);
   else
      strcpy(new_name, output_fn);

   
   set_image(image,bitmap_mimio);
      
 
   // Algorithm
   // remove noise around boundary
   //remove_isolation(image, h, w);
   //prior_remove(image, h, w);

   // do not psudo thinning to get boundary
   psu_thinning(image, h, w);

   // do algorithm 1 to get rid of noise inside of the body
   // this doesn't work, because of the implementation of remove_ins_cc;
   //CC_Head *cc_head_ptr = create_cc(image, h, w);
   //remove_ins_cc(cc_head_ptr, image, h, w);

   // try majority filter/median filter to remove the inside noise
   
   Save2File(new_name,image,bitmap_mimio,0,0,0,NULL);
}

void final_boundary(BYTE **im, int *x, int *cluster_ave, int num_clusters, int data_w, int range, int start, int mode)
{
   // compute the final boundary pixles
   for (int i=start; i < start+num_clusters; i++)
   {
      for (int j=0; j < data_w; j++)
      {
         if (mode)  // from top to bottom
         {
            // find a bug here, should contiue when x[j] == -1.
            if (x[j] != -1 && im[x[j]][j] == WHITE && abs(x[j] - cluster_ave[i]) < range)
               im[x[j]][j] = BLACK;
         }
         else {    // from left to right
            if (x[j] != -1 && im[j][x[j]] == WHITE && abs(x[j] - cluster_ave[i]) < range)
               im[j][x[j]] = BLACK;
         }
      }
   }
 
   
}
void calc_cluster(BYTE **im, int *all, int h, int w, const int cr, const int cp, const int range)
{

   // Constrain:
   //     1. for more than half, cannot be in the same bins (avoid collapse when there is no data on the top)


   // deal with vertical first;
   
   int clust_long = h;
   int num_clusters_1 = 0;
   int num_clusters_2 = 0;
   int i;

   int c_bins = 2*( clust_long / cr + 1);

   int * vote_x = new int[c_bins];
   int * sum_vote_x = new int[c_bins];
   int *cluster_ave = new int[c_bins];

   // bug here: memset is void*, unit is byte, must times 4 for int.
   memset(cluster_ave, 0, c_bins*4);
   memset(vote_x, 0, c_bins*4);
   memset(sum_vote_x, 0, c_bins*4);

   int data_w = w;
   int half_way = c_bins/2;
   int *x = all;
   // compute the cluster
   for ( i=0; i < data_w; i++)
   {
      // test bottom up one
      if (x[i] != -1)
      {
         int t = x[i] / cr;
         vote_x[ t ] ++;
         sum_vote_x[ t ] += x[i];
      }

      // test top down one
      if (x[w+i] != -1)
      {
         int t = x[w+i] / cr;
         vote_x[half_way + t] ++;
         sum_vote_x[half_way + t] += x[w+i];
      }
   }

   // compute how many clusters we have
   // avoid conflict or collapse
   for ( i=0; i < half_way; i++)
   {
      int done = false;
      if (vote_x[i] > cp )
      {
         if (vote_x[half_way+i] > cp)
         {
            if (i > half_way/2) // from bottom up
            {
               cluster_ave[num_clusters_1++] = sum_vote_x[i] / vote_x[i];
               vote_x[half_way+i] = 0;
            }
            else {
               cluster_ave[half_way + num_clusters_2++] = sum_vote_x[half_way + i] / vote_x[half_way + i];
               vote_x[i] = 0;
               done = true;
            }
         }
         else {
            cluster_ave[num_clusters_1++] = sum_vote_x[i] / vote_x[i];
            vote_x[half_way+i] = 0;
         }
      }

      // only need to update half_way+i, top down
      if (vote_x[half_way + i] > cp && !done )
      {
         cluster_ave[half_way + num_clusters_2++] = sum_vote_x[half_way + i] / vote_x[half_way + i];
      }
   }
   
   final_boundary(im, all, cluster_ave, num_clusters_1, data_w, range, 0, 1);   
   final_boundary(im, &all[w], cluster_ave, num_clusters_2, data_w, range, half_way,1);


   // deal with left <-> right now
   
   clust_long = w;
   num_clusters_1 = 0;
   num_clusters_2 = 0;   
   
   c_bins = 2*( clust_long / cr + 1);

   vote_x = new int[c_bins];
   sum_vote_x = new int[c_bins];
   cluster_ave = new int[c_bins];

   // bug here: memset is void*, unit is byte, must times 4 for int.
   memset(cluster_ave, 0, c_bins*4);
   memset(vote_x, 0, c_bins*4);
   memset(sum_vote_x, 0, c_bins*4);

   data_w = h;
   half_way = c_bins/2;
   x = &all[2*w];
   // compute the cluster
   for ( i=0; i < data_w; i++)
   {
      // test left -> right
      if (x[i] != -1 )
      {
         int t = x[i] / cr;
         vote_x[ t ] ++;
         sum_vote_x[ t ] += x[i];
      }

      // test right -> left
      if (x[h+i] != -1)
      {
         int t = x[h+i] / cr;
         vote_x[half_way + t] ++;
         sum_vote_x[half_way + t] += x[h+i];
      }
   }

   // compute how many clusters we have
   // avoid conflict or collapse
   for ( i=0; i < half_way; i++)
   {
      int done = false;
      if (vote_x[i] > cp )
      {
         if (vote_x[half_way+i] > cp)
         {
            if (i < half_way/2) // from left right
            {
               cluster_ave[num_clusters_1++] = sum_vote_x[i] / vote_x[i];
               vote_x[half_way+i] = 0;
            }
            else {
               cluster_ave[half_way + num_clusters_2++] = sum_vote_x[half_way + i] / vote_x[half_way + i];
               vote_x[i] = 0;
               done = true;
            }
         }
         else {
            cluster_ave[num_clusters_1++] = sum_vote_x[i] / vote_x[i];
            vote_x[half_way+i] = 0;
         }
         
      }

      // only need to update half_way+i, top down
      if (vote_x[half_way + i] > cp && !done )
      {
         cluster_ave[half_way + num_clusters_2++] = sum_vote_x[half_way + i] / vote_x[half_way + i];
      }
   }
   
   final_boundary(im, x, cluster_ave, num_clusters_1, data_w, range, 0, 0);   
   final_boundary(im, &x[h], cluster_ave, num_clusters_2, data_w, range, half_way,0);
   
}

// Function: boundary_detect
//
// Detect the boundary of images based on clustering.
// Return: the new boundary image.
BYTE** boundary_detect(BYTE **image, int h, int w)
{

   const int CLUSTER_RANGE = 40; // cluster distance
   // const int INTERVAL = 5; //    interleave range.
   const int RANGE = CLUSTER_RANGE/2;  // distance to the average of a cluster, assume half of the CLUSTER_RANGE
   // a bug found here, when the RANGE is not half of CR, where the boundary is missing.
   const int CLUSTER_PIXELS = 15; // how many pixles needed to treated as a cluster
   
   // try to get the boundary of the image
   BYTE **new_im = new_image(h, w);

   // problems:
   //     1. we cannot have some verticle boundary pixels, such as 074.png.
   //        And this is not solvable based on this algorithm where multiple
   //        verticle lines are blocked by other structure
   //     2. what if there is no top pixels.
   //     3. what if there is only partial top pixles.
   // solution: cluster?

   // starting from the bottom for our case
   int *all = new int[2*w + 2*h];
   int *x = new int[w];
   int sum = 0, num = 0;
   int i;
   for ( i = 0; i < w; i ++)
      for (int j=h-1; j>0; j--)
      {
         if (image[j][i] == BLACK)
         {
            x[i] = j;
            sum += j;
            num ++;
            break;
         }
         x[i] = -1;
      }

   for ( i = 0; i < w; i ++)
      all[i] = x[i];
   
   delete x;

   // processing from left
   x = new int[h];
   sum = 0, num = 0;
   for ( i = 0; i < h; i ++)
      for (int j=0; j < w; j++)
      {
         if (image[i][j] == BLACK)
         {
            x[i] = j;
            sum += j;
            num ++;
            break;
         }
         x[i] = -1;
      }

   for ( i = 0; i < h; i ++)
      all[i+w*2] = x[i];

   delete x;
   
   // processing from right
   x = new int[h];
   sum = 0, num = 0;
   for ( i = 0; i < h; i ++)
      for (int j=w-1; j > 0; j--)
      {
         if (image[i][j] == BLACK)
         {
            x[i] = j;
            sum += j;
            num ++;
            break;
         }
         x[i] = -1;
      }

   for ( i = 0; i < h; i ++)
      all[i+w*2+h] = x[i];

   delete x;

   // starting from the top for our case
   
   x = new int[w];
   sum = 0, num = 0;
   for ( i = 0; i < w; i ++)
      for (int j=0; j<h; j++)
      {
         if (image[j][i] == BLACK)
         {
            x[i] = j;
            sum += j;
            num ++;
            break;
         }
         x[i] = -1;
      }

   for ( i = 0; i < w; i ++)
      all[i+w] = x[i];
   delete x;

   calc_cluster(new_im, all, h, w, CLUSTER_RANGE, CLUSTER_PIXELS, RANGE);

   delete all;
   return new_im;
   
}

void clear_bd_noise(BYTE **im, int h, int w)
{
   for (int i=0 ; i < w; i++) {
      im[0][i] = WHITE;
      im[h-1][i] = WHITE;
   }

   for (int i=0 ; i < h; i++) {
      im[i][0] = WHITE;
      im[i][w-1] = WHITE;
   }
   
}

void preprocess_3(char *fn)
{
   int mrows, ncols;
   BYTE **image;

#ifdef LINUX
#else   
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif   

   wchar_t pwc[1000];
   char new_name[1000];

   strcpy(new_name, fn);
   mbstowcs( pwc, new_name, 1000);

#ifdef LINUX
   CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(new_name);
   int h = bitmap_mimio->dimy();
   int w = bitmap_mimio->dimx();
#else      
   Bitmap* bitmap_mimio = new Bitmap(pwc);
   int h = bitmap_mimio->GetHeight();
   int w = bitmap_mimio->GetWidth();
#endif      

   if (output_fn == NULL)
      sprintf(new_name, "pre3_%s", fn);
   else
      strcpy(new_name, output_fn);
   
   set_image(image,bitmap_mimio);
      
 
   // Algorithm
   // Assumption: the outside noise, including noise tree data has been removed
   //             (manually or automatically by, say average image
   // systematically get the boundary pixels.
   BYTE **im = boundary_detect(image, h, w);

   //   clear_bd_noise(im,h,w);

   Save2File(new_name,im,bitmap_mimio,0,0,0,NULL);
}

void preprocess_4(char *fn)
{
   int mrows, ncols;
   BYTE **image;

#ifdef LINUX
#else   
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif   

   wchar_t pwc[1000];
   char new_name[1000];

   strcpy(new_name, fn);
   mbstowcs( pwc, new_name, 1000);

#ifdef LINUX
   CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(new_name);
   int h = bitmap_mimio->dimy();
   int w = bitmap_mimio->dimx();
#else      
   Bitmap* bitmap_mimio = new Bitmap(pwc);
   int h = bitmap_mimio->GetHeight();
   int w = bitmap_mimio->GetWidth();
#endif      

   if (output_fn == NULL)
      sprintf(new_name, "pre4_%s", fn);
   else
      strcpy(new_name, output_fn);
   
   set_image(image,bitmap_mimio);
      

   // Description:
   //    Attack the boundary image by dividing the original image to tiles. 
   // Algorithm:
   //    1. divide the orignial image into nxn size tiles.
   //    2. sweep each tile, get the boundary for each tile.
   //    3. NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
   //       This wont work, since it is not possible to distinguish the upper or bottom part.
   //       Without boundary extraction, thinking about work on the original image directly.

   //   clear_bd_noise(im,h,w);


}

/* 
//	Function: generate_iv_from_bpa
//
//  Create an big iv file from bpa files.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the orignal image; the value has been changed.
//
//	Algorithms:
//	remove the noise outside of 40 pixel; crop the image
*/
void
generate_iv_from_bpa()
{
   char str_line[1000];
   char templ_fn[] = "C:/Liwh/Dev/Matlab/PolyFitting/Data/slices/Rotated_split_";
   char file_org[] = "c:/Liwh/Dev/Matlab/PolyFitting/Data/3.8.07_Siavash/iv/Rotated_split_035.iv";
   char new_file[] = "new.iv";
   char temp_str[1000];

   FILE *fd_org = fopen(file_org, "r");
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_org);
   assert(fd_new);

   for (int i = 0; i<32; i++)
   {
      fgets(str_line, 1000, fd_org);
      fputs(str_line, fd_new);
   }

   char file_name[1000];
   int line_num = 0;
   for (int file_no = 0; file_no < 101; file_no ++)
   {
      if (file_no < 10)
         sprintf(file_name, "%s00%d.bpa", templ_fn, file_no);
      else if (file_no < 100)
         sprintf(file_name, "%s0%d.bpa", templ_fn, file_no);
      else
         sprintf(file_name, "%s%d.bpa", templ_fn, file_no);         
      
      printf ("Processing %s \n", file_name);
      
      FILE *fd = fopen(file_name, "r");
      assert(fd);

   
      //   float a, b, c;
      char a[20], b[20], c[20];

      while (fgets(str_line, 1000, fd))
      {
         if (line_num == 0)
         {
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, "      point [ %s %s %s", a, b, c);
            fputs(temp_str, fd_new);
         }
         else
         {
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, ",\n          %s %s %s", a, b, c);
            fputs(temp_str, fd_new);
         }
         
         line_num ++;
      }

      fclose(fd);
   }
   
   sprintf(temp_str," ]\n\n    }\n    PointSet {\n      numPoints %d\n",line_num);
   fputs(temp_str, fd_new);
   fputs("\n    }\n  }\n}\n", fd_new);
   
   fclose(fd_new);
   fclose(fd_org);

   exit(0);
}

// Function: generate_iv_from_ptx
//
// Command: Project.exe -j -O "-t 0 -w 111 -p input.ptx -P XXX -d 10" // -d: downsampling
// This is from Gene's data of hunter hall interior scanning.
void generate_iv_from_ptx(char *fn, int down_s = 1, char *output_fn = NULL)
{
   char str_line[1000];
   char *file_name = strdup(fn);
   char *new_file = "new.iv";
   char temp_str[1000];

   if ( output_fn )
      new_file = output_fn;
   
   if (down_s == 0)
      down_s = 1;

   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   printf("Generating from ptx!!!!\n");
   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb 0.31403902 0.99084514 0.79899842\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    DrawStyle {\n");
      fprintf(fd_new, "      style POINTS\n");
      fprintf(fd_new, "      pointSize 1\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
   }

   int line_num = 0;
   int total = 0;
   {
      FILE *fd = fopen(file_name, "r");
      assert(fd);

   
      //   float a, b, c;
      char a[20], b[20], c[20];

      while (fgets(str_line, 1000, fd))
      {
         if (line_num == 10)
         {
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, "      point [ %s %s %s", a, b, c);
            fputs(temp_str, fd_new);
            total ++;
         }
         else if (line_num > 10) 
         {
            if ( line_num % down_s == 0 ) {
               sscanf(str_line, "%s %s %s", a, b,c);
               sprintf(temp_str, ",\n          %s %s %s", a, b, c);
               fputs(temp_str, fd_new);
               total ++;
            }
         }
         
         line_num ++;
      }

      fclose(fd);
   }
   
   sprintf(temp_str," ]\n\n    }\n    PointSet {\n      numPoints %d\n", total);
   fputs(temp_str, fd_new);
   fputs("\n    }\n  }\n}\n", fd_new);
   
   fclose(fd_new);

   exit(0);
}

// Function: generate_iv_for_3D_BPA_model
//
// Command: Project.exe -j -O "-t 5 -d 3 -p ../data/stamos/ThomasHunter -P ../data/3.8.07_Siavash/iv"
// This is to load Stamos's data to display triagles from BPA.
void generate_smf_for_qslim(char *input_path, char *output_path, int down_sampling = 0, int max_faces = 0, int start_faces = 0)
{
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];
   int  down_s = 1;
   if (down_sampling > 0 )
      down_s = down_sampling;

   sprintf(new_file, "%s/new.iv", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#$SMF 1.0\n");
   }

   int line_num = 0;
   bool is_first_line = true;
   for (int i = 0; true; i ++ )
   {
      char *ds = digit_string(3, i);
      sprintf(old_name, "%s/vertices_%s.ascii", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      FILE *fd = fopen(old_name, "r");
      assert(fd);

      printf("Processing %s ...\n", old_name);
      
      //   float a, b, c;
      char a[20], b[20], c[20];
      int is_file_number = 1;
      int this_file_number = 0;
      int pts_num = 0;
      while (fgets(str_line, 1000, fd))
      {
         if ( is_file_number ) {
            sscanf(str_line, "%d", &pts_num);
            is_file_number = 0;
            continue;
         }
         
         sscanf(str_line, "%s %s %s", a, b,c);
         sprintf(temp_str, "v %s %s %s\n", a, b, c);
         fputs(temp_str, fd_new);

         this_file_number ++;
         line_num ++;
      }

      assert( this_file_number == pts_num);
      fclose(fd);
   }
   
   int num_vertices = line_num;
   int num_faces = 0;
   
   // dump the BPA
   line_num = 0;
   for (int i = 0; true; i ++ )
   {
      char *ds = digit_string(3, i);
      sprintf(old_name, "%s/triangles_%s.ascii", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      FILE *fd = fopen(old_name, "r");
      assert(fd);

      printf("Processing %s ...\n", old_name);
      
      //   float a, b, c;
      int a, b, c;
      int is_file_number = 1;
      int pts_num = 0;
      while (fgets(str_line, 1000, fd))
      {
         if ( is_file_number ) {
            sscanf(str_line, "%d", &pts_num);
            is_file_number = 0;
            continue;
         }

         line_num ++;
         
         if ( start_faces > 0 && line_num < start_faces )
            continue;
         
         if ( max_faces > 0 && num_faces >= max_faces )
            break;

         if ( line_num % down_s == 0 ) {
            sscanf(str_line, "%d %d %d", &a, &b,&c);
            sprintf(temp_str, "f %d %d %d\n", a+1, b+1, c+1);
            fputs(temp_str, fd_new);
            num_faces ++;
         }

      }

      fclose(fd);
   }
   
   fprintf(fd_new, "#$vertices %d\n", num_vertices);
   fprintf(fd_new, "#$faces %d\n", num_faces);
   
   fclose(fd_new);

   exit(0);
}


// Function: generate_iv_for_3D_BPA_model
//
// Command: Project.exe -j -O "-t 4 -d 3 -p ../data/stamos/ThomasHunter -P ../data/3.8.07_Siavash/iv -s <start_faces> -m <max_faces>"
// This is to load Stamos's data to display triagles from BPA.
void generate_iv_for_3D_BPA_model(char *input_path, char *output_path, int down_sampling, int max_faces, int start_faces)
{
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];
   int  down_s = 1;
   if (down_sampling > 0 )
      down_s = down_sampling;

   sprintf(new_file, "%s/new.iv", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb 0.31403902 0.99084514 0.79899842\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
   }

   int line_num = 0;
   bool is_first_line = true;
   for (int i = 0; true; i ++ )
   {
      char *ds = digit_string(3, i);
      sprintf(old_name, "%s/vertices_%s.ascii", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      FILE *fd = fopen(old_name, "r");
      assert(fd);

      printf("Processing %s ...\n", old_name);
      
      //   float a, b, c;
      char a[20], b[20], c[20];
      int is_file_number = 1;
      int this_file_number = 0;
      int pts_num = 0;
      while (fgets(str_line, 1000, fd))
      {
         if ( is_file_number ) {
            sscanf(str_line, "%d", &pts_num);
            is_file_number = 0;
            continue;
         }
         
         sscanf(str_line, "%s %s %s", a, b,c);
         if ( is_first_line )
         {
            is_first_line = false;
            sprintf(temp_str, "      point [ %s %s %s", a, b, c);
         } else {
            sprintf(temp_str, ",\n          %s %s %s", a, b, c);
         }
         fputs(temp_str, fd_new);

         this_file_number ++;
         line_num ++;
      }

      assert( this_file_number == pts_num);
      fclose(fd);
   }
   
   fputs("      ]\n\n    }\n", fd_new);

   // dump the BPA
   fprintf(fd_new, "    IndexedFaceSet { \n");
   fprintf(fd_new, "       coordIndex [ \n");
   line_num = 0;
   for (int i = 0; true; i ++ )
   {
      char *ds = digit_string(3, i);
      sprintf(old_name, "%s/triangles_%s.ascii", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      FILE *fd = fopen(old_name, "r");
      assert(fd);

      printf("Processing %s ...\n", old_name);
      
      //   float a, b, c;
      char a[20], b[20], c[20];
      int is_file_number = 1;
      int pts_num = 0;
      while (fgets(str_line, 1000, fd))
      {
         if ( is_file_number ) {
            sscanf(str_line, "%d", &pts_num);
            is_file_number = 0;
            continue;
         }

         if ( start_faces == 0 || ( start_faces != 0 && start_faces < line_num && max_faces > line_num )) {
            if ( line_num % down_s == 0 ) {
               sscanf(str_line, "%s %s %s", a, b,c);
               sprintf(temp_str, "          %s, %s, %s, -1,\n", a, b, c);
               fputs(temp_str, fd_new);
            }
         }

         line_num ++;
      }

      fclose(fd);
   }
   
   fputs("      ]\n\n    }\n", fd_new);

   // final closing
   fputs("  }\n}\n", fd_new);
   
   fclose(fd_new);

   exit(0);
}

// Function: generate_iv_from_slices
//
// Command: Project.exe -j -O "-t 3 -p input_path -P output_path"
// This is to load Stamos's data.
void generate_iv_from_slices(char *input_path, char *output_path)
{
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s/new.iv", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb 0.31403902 0.99084514 0.79899842\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    DrawStyle {\n");
      fprintf(fd_new, "      style POINTS\n");
      fprintf(fd_new, "      pointSize 1\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
   }

   int line_num = 0;
   bool is_first_line = true;
   for (int i = 0; true; i ++ )
   {
      char *ds = digit_string(3, i);
      sprintf(old_name, "%s/vertices_%s.ascii", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      FILE *fd = fopen(old_name, "r");
      assert(fd);

      printf("Processing %s ...\n", old_name);
      
      //   float a, b, c;
      char a[20], b[20], c[20];
      int is_file_number = 1;
      int this_file_number = 0;
      int pts_num = 0;
      while (fgets(str_line, 1000, fd))
      {
         if ( is_file_number ) {
            sscanf(str_line, "%d", &pts_num);
            is_file_number = 0;
            continue;
         }
         
         sscanf(str_line, "%s %s %s", a, b,c);
         if ( is_first_line )
         {
            is_first_line = false;
            sprintf(temp_str, "      point [ %s %s %s", a, b, c);
         } else {
            sprintf(temp_str, ",\n          %s %s %s", a, b, c);
         }
         fputs(temp_str, fd_new);

         this_file_number ++;
         line_num ++;
      }

      assert( this_file_number == pts_num);
      fclose(fd);
   }
   
   sprintf(temp_str," ]\n\n    }\n    PointSet {\n      numPoints %d\n", line_num);
   fputs(temp_str, fd_new);
   fputs("\n    }\n  }\n}\n", fd_new);
   
   fclose(fd_new);

   exit(0);
}

// Function: generate_cat_from_parts
//
// Command: Project.exe -j -O "-t 2 -p input_path -P output_path"
// This is to load Stamos's data.
void generate_cat_from_parts(char *input_path, char *output_path, int mode)
{
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];
   FILE *fd_new;

   if ( mode == 0 || mode == 2) {
      
      sprintf(new_file, "%s/vertices.ascii", output_path);
      fd_new = fopen(new_file, "w");
      assert(fd_new);

      // then concatenate points
      for (int i = 0; true; i ++ )
      {
         char *ds = digit_string(3, i);
         sprintf(old_name, "%s/vertices_%s.ascii", input_path, ds);
         free(ds);

         if ( !file_exist(old_name) )
            break;
      
         FILE *fd = fopen(old_name, "r");
         assert(fd);

         printf("Processing %s ...\n", old_name);
      
         //   float a, b, c;
         char a[20], b[20], c[20];
         int is_file_number = 1;
         int this_file_number = 0;
         int pts_num = 0;
         while (fgets(str_line, 1000, fd))
         {
            if ( is_file_number ) {
               sscanf(str_line, "%d", &pts_num);
               is_file_number = 0;
               continue;
            }
         
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, "%s %s %s\n", a, b, c);
            fputs(temp_str, fd_new);

            this_file_number ++;
         }

         assert( this_file_number == pts_num);
         fclose(fd);
      }
   
      fclose(fd_new);
   }

   if ( mode == 1 || mode == 2 ) {
      
      sprintf(new_file, "%s/triangles.ascii", output_path);
      fd_new = fopen(new_file, "w");
      assert(fd_new);

      // then concatenate points
      for (int i = 0; true; i ++ )
      {
         char *ds = digit_string(3, i);
         sprintf(old_name, "%s/triangles_%s.ascii", input_path, ds);
         free(ds);

         if ( !file_exist(old_name) )
            break;
      
         FILE *fd = fopen(old_name, "r");
         assert(fd);

         printf("Processing %s ...\n", old_name);
      
         //   float a, b, c;
         char a[20], b[20], c[20];
         int is_file_number = 1;
         int this_file_number = 0;
         int pts_num = 0;
         while (fgets(str_line, 1000, fd))
         {
            if ( is_file_number ) {
               sscanf(str_line, "%d", &pts_num);
               is_file_number = 0;
               continue;
            }
         
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, "%s %s %s\n", a, b, c);
            fputs(temp_str, fd_new);

            this_file_number ++;
         }

         assert( this_file_number == pts_num);
         fclose(fd);
      }
   
      fclose(fd_new);
   }
   
   exit(0);
}


// Function: generate_iv_from_sub_ivs
//
// Command: Project.exe -j -O "-p input_path -P output_path"
// This is to load Stamos's data.
void generate_iv_from_sub_ivs(char *input_path, char *output_path, int start_faces)
{
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   // then concatenate points
   int is_first_file = true;
   int current_point_index = 0;
   char swap_fn[1000];
   char final_fn[1000];
   sprintf(swap_fn, "%s_swap.iv", output_path);
   sprintf(final_fn, "%s_final.iv", output_path);
   for (int i = start_faces; true; i ++ )
   {
      char *ds = digit_string(1, i);
      sprintf(old_name, "%s_%s.iv", input_path, ds);
      free(ds);

      if ( !file_exist(old_name) )
         break;
      
      if ( is_first_file ) {
         is_first_file = false;
         copy_file(old_name, swap_fn);
         // sprintf(swap_fn, "%s", old_name);
         continue;
      }

      printf("Processing %s ...\n", old_name);

      FILE *fd_2 = fopen(old_name, "r");
      assert(fd_2);

      FILE *fd_1 = fopen(swap_fn, "r");
      assert(fd_1);

      FILE *fd_merge = fopen(final_fn, "w");
      assert(fd_merge);
      
      int mode = 0;
      int num_vert_in_1 = 0;
      while (fgets(str_line, 1000, fd_1))
      {
         if (strncmp(str_line, "point", 5) == 0){
            mode = 1;
            fprintf(fd_merge, "%s", str_line);
            continue;
         }

         if ( mode == 1 && str_line[0] == ']' ) {
            mode = 2;

            // incorporate the 2nd file
            int a, b, c;
            char inner_str[1000];
            int inner_mode = 0;
            while (fgets(inner_str, 1000, fd_2)) {
               if (strncmp(inner_str, "point", 5) == 0) {
                  inner_mode = 1;
                  continue;
               }

               if ( inner_mode == 1) {
                  fprintf(fd_merge, "%s", inner_str);
               }

               if ( inner_mode == 1 && strncmp(inner_str, "coordIndex", 10) == 0 ) {
                  inner_mode = 2;
                  continue;
               }

               if ( inner_mode == 2 ) {
                  sscanf(inner_str, "   %d, %d, %d, -1", &a, &b, &c);
                  fprintf(fd_merge, "   %d, %d, %d, -1,\n", a+num_vert_in_1, b+num_vert_in_1, c+num_vert_in_1);
               }
               
            }
         }
         
         if ( mode != 2) {
            fprintf(fd_merge, "%s", str_line);
         }
         
         if ( mode == 1) {
            num_vert_in_1 ++;
         }

         if ( mode == 2 && strncmp(str_line, "coordIndex", 10) == 0 ) {
            mode = 3;
         }
      }

      fclose(fd_1);
      fclose(fd_2);
      fclose(fd_merge);
      
      copy_file(final_fn, swap_fn);
   }
   
   exit(0);
}


void generate_iv_for_slab_set_points(FILE *fd_new, vector<double> &data )
{
#if 1 // the color for ivview is reversed due to dark background
   const int NUM_C = 10;
   float colors[NUM_C][3] = {{255,0,0}, // red
                             {0,255,0}, // green
                             {0,0,255}, // blue
                             {255,255,0}, // yellow
                             {255,255,255}, // grey
                             {0,255,255}, // cyan
                             {255,0,128}, // red
                             {128,0,255}, // violet
                             {12,15,25},    // white
                             {128,128,64}}; // orange
#else
#if 1
   const int NUM_C = 9;
   float colors[NUM_C][3] = {{240,248,255},
                             {138,43,226},
                             {0,255,255},
                             {255,0,255},
                             {255,215,0},
                             {250,235,215},
                             {205,92,92},
                             {255,255,224},
                             {128,128,0}};
#else
   const int NUM_C = 5;
   float colors[NUM_C][3] = {{255,0,0},
                             {0,255,0},
                             {255,0,255},
                             {0,255,255},
                             {255,0,255}};
#endif
#endif
  
   assert(fd_new);

   static int color_index = 0;
   int c_i = color_index % NUM_C;

   printf("COLOR: [%f, %f, %f]\n", colors[c_i][0], colors[c_i][1], colors[c_i][2]);
   float total_c = colors[c_i][0] + colors[c_i][1] + colors[c_i][2];
   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb %f %f %f\n", colors[c_i][0]/total_c, colors[c_i][1]/total_c, colors[c_i][2]/total_c);
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    DrawStyle {\n");
      fprintf(fd_new, "      style POINTS\n");
      fprintf(fd_new, "      pointSize 5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [ ");
      
   }

   for (int i = 0; i < data.size(); i += 3) {
      fprintf(fd_new, "              %f %f %f,\n", data[i], data[i+1], data[i+2]);
   }
   
   fprintf(fd_new," ]\n\n    }\n    PointSet {\n      numPoints %d\n}}", data.size() / 3);

   color_index ++;
   
}

// Function: generate_iv_for_slab_highlight
//
// Command: Project.exe -j -O "-p input_path -P output_path -t 6 -m 50 -d 1 -s 4"
// This is to highlight slab of data
// -m : # of slabs,
// -d : downsampling #
// -s : # of planes
void generate_iv_for_slab_highlight(char *fn, char *output_path, int slice_total, int down_sampling, int have_plane = 0)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s/slabs.iv", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      // this is transfomration parameter, after it, zoom in 4 times?
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 1 0  1.3707\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 0 1  0.2200\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  1 0 0  0.0400\n");
      fprintf(fd_new, "}\n");
      // this is for transformation
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
   }

   
   // BOX : -36.2841 82.3821 -2.4001 80.6962 -15.4828 136.499
   // TEST: -x 20 -X 90 -z 20 -Z 60 -y -3.0 -Y 44.0
   // double BOX_MIN_X = -36;
   // double BOX_MAX_X = 82;
   // double BOX_MIN_Y = -2;
   // double BOX_MAX_Y = 80;
   // double BOX_MIN_Z = -15;
   // double BOX_MAX_Z = 136;
   double BOX_MIN_X = 1000;
   double BOX_MAX_X = -1000;
   double BOX_MIN_Y = 1000;
   double BOX_MAX_Y = -1000;
   double BOX_MIN_Z = 1000;
   double BOX_MAX_Z = -1000;

   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   vector<double> data;
   printf("loading data from file...\n");
   int num = 0;
   while (fgets(str_line, 1000, fid))
   {
#if 1      
      if (sscanf(str_line, "%s %s %s", x_s, z_s, y_s) == 3)
#else         
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
#endif         
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         /*
         if (x < BOX_MIN_X || x > BOX_MAX_X ||
             y < BOX_MIN_Y || y > BOX_MAX_Y ||
             z < BOX_MIN_Z || z > BOX_MAX_Z)
            continue;
         */
         if (x < BOX_MIN_X) BOX_MIN_X = x;
         if (x > BOX_MAX_X) BOX_MAX_X = x;
         if (y < BOX_MIN_Y) BOX_MIN_Y = y;
         if (y > BOX_MAX_Y) BOX_MAX_Y = y;
         if (z < BOX_MIN_Z) BOX_MIN_Z = z;
         if (z > BOX_MAX_Z) BOX_MAX_Z = z;

         num ++; 
         if ( num % down_sampling != 0 )
            continue;
         
         data.push_back(x);
         data.push_back(y);
         data.push_back(z);
      }
   }
   fclose(fid);

   printf("BOX: [%.3f - %.3f], [%.3f - %.3f], [%.3f - %.3f]\n", BOX_MIN_X, BOX_MAX_X,
          BOX_MIN_Y, BOX_MAX_Y, BOX_MIN_Z, BOX_MAX_Z);
   double diff_y = BOX_MAX_Y - BOX_MIN_Y;
   double slice_int =  diff_y / slice_total;
   vector<double> slice_data;
   for (int i = 0; i < slice_total; i ++)
   {
      printf("\nLoad: Processing slice #%d, ", i);
      // find out the appropriate points
      // CHANGE: BOX_MIN_Y   
      double BOX_MIN = BOX_MIN_Y;
      double slice_min = i*slice_int + BOX_MIN;
      double slice_max = slice_min + slice_int;
      for (int index = 0; index < data.size(); index += 3)
      {
         // CHANGE: index
         if (data[index+1] > slice_min && data[index+1] < slice_max)
         {
            slice_data.push_back(data[index]);        // x axis
            slice_data.push_back(data[index+1]);      // y axis
            slice_data.push_back(data[index+2]);      // z axis
         }
      }
      
      generate_iv_for_slab_set_points(fd_new, slice_data);
      slice_data.clear();
   }

   int num_planes = 4;
   if ( have_plane > 0 )
      num_planes = have_plane;
   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "    LightModel {\n");
      fprintf(fd_new, "      model PHONG\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Material {\n");
      fprintf(fd_new, "      ambientColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      diffuseColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      emissiveColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      specularColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      shininess     0.5\n");
      fprintf(fd_new, "      transparency  0.5\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n"); // 13, 31, 37, 41

      for ( int i = 0; i < num_planes; i ++ ) {
         float ratio = 0.15;
         float y_high = BOX_MIN_Y + (i + 1)/(float)(num_planes + 1) * diff_y;
         float x_min =  BOX_MIN_X - (BOX_MAX_X - BOX_MIN_X ) * ratio;
         float x_max =  BOX_MAX_X + (BOX_MAX_X - BOX_MIN_X ) * ratio;
         float z_min =  BOX_MIN_Z - (BOX_MAX_Z - BOX_MIN_Z ) * ratio;
         float z_max =  BOX_MAX_Z + (BOX_MAX_Z - BOX_MIN_Z ) * ratio;
         fprintf(fd_new, "        %.3f %.3f %.3f,\n", x_min , y_high, z_min);
         fprintf(fd_new, "        %.3f %.3f %.3f,\n", x_min , y_high, z_max);
         fprintf(fd_new, "        %.3f %.3f %.3f,\n", x_max , y_high, z_max);
         fprintf(fd_new, "        %.3f %.3f %.3f,\n", x_max , y_high, z_min);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");

      for ( int i = 0; i < num_planes; i ++ ) {
         fprintf(fd_new, "        %d, %d, %d, %d, -1,   \n", i*4+3, i*4+2, i*4+1, i*4);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "  }\n");
   }
   
   // generate the planar
   if ( 0 )
   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "    LightModel {\n");
      fprintf(fd_new, "      model PHONG\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Material {\n");
      fprintf(fd_new, "      ambientColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      diffuseColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      emissiveColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      specularColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      shininess     0.5\n");
      fprintf(fd_new, "      transparency  0.5\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n"); // 13, 31, 37, 41
      fprintf(fd_new, "        15 11 20,\n");   
      fprintf(fd_new, "        15 11 90,\n");
      fprintf(fd_new, "        50 11 90,\n");
      fprintf(fd_new, "        50 11 20,\n");
      fprintf(fd_new, "        15 26 20,\n");
      fprintf(fd_new, "        15 26 90,\n");
      fprintf(fd_new, "        50 26 90,\n");
      fprintf(fd_new, "        50 26 20,\n");
      fprintf(fd_new, "        15 32 20,\n");
      fprintf(fd_new, "        15 32 90,\n");
      fprintf(fd_new, "        50 32 90,\n");
      fprintf(fd_new, "        50 32 20,\n");
      fprintf(fd_new, "        20 41 25,\n");
      fprintf(fd_new, "        20 41 85,\n");
      fprintf(fd_new, "        45 41 85,\n");
      fprintf(fd_new, "        45 41 25\n");
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");
      fprintf(fd_new, "        3, 2, 1, 0, -1,   \n");
      fprintf(fd_new, "        7, 6, 5, 4, -1,   \n");
      fprintf(fd_new, "        11, 10, 9, 8, -1,   \n");
      fprintf(fd_new, "        15, 14, 13, 12, -1,   \n");
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "  }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);

   
}

// Function: generate_iv_for_IR_multi_dir
//
// Command: Project.exe -j -O "-p input_path -P output_path -t 11"
// Reconstruct 3D model from multiple extrusion directions.
// Here, we assume the reconstruction is obtained from two directions.
// The first direction is from z direction (d = 1);
// The second direction is from y direction (d = 0);
// We have to make sure the ratio is kept for 3D space, so ts = im_d1/im_d2;
// If we would reconstruct from the 3rd direction, that is x direction (d = 2),
// we should do the similiar thing as the second case.
// -w : define the image width along z direction (face-inside);
// -W : define the image width along y direction (bottom-up);
//
void generate_iv_for_IR_multi_dir(char *fn, char *output_path , int dataset_type, int dir, int flag_vertical = 0)
{

   int im_width1 = image_width;
   int im_width2 = 0;
   int dir0 = -1;
   int dir1 = -1;
   int dir2 = -1;
   
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "0:1:2:t:p:P:d:D:fw:W:s:m:M:o:x:X:y:Y:z:Z:")) != EOF)
      {
         switch (c) {
            case 'W':
               im_width2 = atoi(util_optarg);
               break;
            case '0':
               dir0 = atoi(util_optarg);
               break;
            case '1':
               dir1 = atoi(util_optarg);
               break;
            case '2':
               dir2 = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(im_width2 > 0 );
   assert(dir0 > -1 && dir1 > -1);
   printf("Direction is di11\n");
   
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model BASE_COLOR\n"); // PHONG
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n"); // LightModel
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));
      
   // draw faces
   int gbl_count = 0;
   array_t *gbl_points = array_alloc(vector<float>, 0);
   vector<char *> gbl_faces;
   double scale1 = 0.0;
   
   int k1, k2;
   if ( 1 )
   {
      assert(dir0 == 0 || dir0 == 1);
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);
      
      double scale = image_width/(x_max - x_min);
      double depth_bottom = ((dir0 == 0) ? y_min : z_min) * scale;
      double depth_top    = ((dir0 == 0) ? y_max : z_max) * scale;
      double depth_inter = depth_top - depth_bottom;
      scale1 = scale;
      
      array_t *boundary;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         double bottom = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(0);
         double top = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(1);
         if ( top == bottom ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }
         bool isNewLayer = true;
         int x0, y0;
         arrayForEachItem(vector<int> *, boundary, k2, points) {

            // to avoid the same point (no face)
            if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
               continue;

            x0 = (*points)[0];
            y0 = (*points)[1];
            vector<float> p1, p2;
            p1.push_back((*points)[0]);
            if ( dir0 == 1 ) {
               p1.push_back(((*points)[1]));
               p1.push_back(bottom);
            } else {
               p1.push_back(bottom);
               p1.push_back(((*points)[1]));
            }
            p2.push_back((*points)[2]);
            if ( dir0 == 1 ) {
               p2.push_back(((*points)[3]));
               p2.push_back(top);
            } else {
               p2.push_back(top);
               p2.push_back(((*points)[3]));
            }
            array_insert_last(vector<float>, gbl_points, p1);
            array_insert_last(vector<float>, gbl_points, p2);
            gbl_count += 2;

            if ( isNewLayer ) {
               isNewLayer = false;
            } else {
               char tmp_str[100];
               // construct a face with 4 points.
               // FOR TH BUILDING
               if ( dir == 0 ) {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
               } else {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 2, gbl_count - 1, gbl_count - 3);
               }
               
               gbl_faces.push_back(strdup(tmp_str));
            }
         }
      }

   }

   // 2nd model construction
   
   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   if ( flag_vertical ){

      assert(dir1 == 0 || dir1 == 2);
      
      char *ver_fn = strdup(fn);
      char *ptr = strrchr(ver_fn, '/');
      assert(ptr);
      *ptr = NULL;
      char ver_ir_fn[1000];
      sprintf(ver_ir_fn, "%s/ir_vertical.txt", ver_fn);
      array_t *z_arr = array_alloc(vector<float> *, 0);
      array_t *end_points = load_end_points_from_IR(ver_ir_fn, z_arr);
      assert(array_n(end_points) == array_n(z_arr));
      image_width = im_width2;
      
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);

      double diff_3D = (dir1 == 0) ? x_max - x_min : z_max - z_min;
      double scale = (double)image_width/diff_3D;
      double depth_bottom = ((dir1 == 0) ? y_min : x_min) * scale;
      double depth_top    = ((dir1 == 0) ? y_max : x_max) * scale;
      double depth_inter = depth_top - depth_bottom;

      double ts = scale1/scale;
      array_t *boundary;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         double bottom = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(0);
         double top = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(1);
         if ( top == bottom ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }
         bool isNewLayer = true;
         int x0, y0;
         arrayForEachItem(vector<int> *, boundary, k2, points) {

            // to avoid the same point (no face)
            if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
               continue;

            x0 = (*points)[0];
            y0 = (*points)[1];
            vector<float> p1, p2;
            if ( dir1 == 0 ) {
               p1.push_back(ts*(*points)[0]);
               p1.push_back(ts*bottom);
               p1.push_back(ts*(*points)[1]);
            } else {
               p1.push_back(ts*bottom);
               p1.push_back(ts*(*points)[1]);
               p1.push_back(ts*(*points)[0]);
            }

            if ( dir1 == 0 ) {
               p2.push_back(ts*(*points)[2]);
               p2.push_back(ts*top);
               p2.push_back(ts*(*points)[3]);
            } else {
               p2.push_back(ts*top);
               p2.push_back(ts*(*points)[3]);
               p2.push_back(ts*(*points)[2]);
            }
            
            array_insert_last(vector<float>, gbl_points, p1);
            array_insert_last(vector<float>, gbl_points, p2);
            gbl_count += 2;

            if ( isNewLayer ) {
               isNewLayer = false;
            } else {
               char tmp_str[100];
               // construct a face with 4 points.
               // FOR TH BUILDING
               if ( dir == 0 ) {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
               } else {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 2, gbl_count - 1, gbl_count - 3);
               }
               
               gbl_faces.push_back(strdup(tmp_str));
            }
         }
      }

   }

   {
      // start to write out the data
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n");
      vector<float> pts;
      arrayForEachItem(vector<float>, gbl_points, k1, pts) {
         fprintf(fd_new, "        %f %f %f,\n", pts[0], pts[1], pts[2]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");

      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");
      for (int i = 0; i < gbl_faces.size(); i ++) {
         fprintf(fd_new, "        %s,\n", gbl_faces[i]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);


}

// Function: generate_iv_for_IR
//
// Command: Project.exe -j -O "-p input_path -P output_path -t 7"
// This is to show the model from IR
void generate_iv_for_IR(char *fn, char *output_path , int dataset_type, int dir, int orientation)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model BASE_COLOR\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n"); // LightModel
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));
      
   // draw faces
   {
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);
      
      double scale = image_width/(x_max - x_min);
      double depth_bottom = (( orientation == 0 ) ? y_min : z_min) * scale;
      double depth_top    = (( orientation == 0 ) ? y_max : z_max) * scale;
      double depth_inter = depth_top - depth_bottom;
      
      int gbl_count = 0;
      array_t *gbl_points = array_alloc(vector<float>, 0);
      vector<char *> gbl_faces;

      int k1, k2;
      array_t *boundary;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         double bottom = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(0);
         double top = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(1);
         if ( top == bottom ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }
         bool isNewLayer = true;
         int x0, y0;
         arrayForEachItem(vector<int> *, boundary, k2, points) {

            // to avoid the same point (no face)
            if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
               continue;

            x0 = (*points)[0];
            y0 = (*points)[1];
            vector<float> p1, p2;
            p1.push_back((*points)[0]);
            p1.push_back(bottom);
            p1.push_back((*points)[1]);
            p2.push_back((*points)[2]);
            p2.push_back(top);
            p2.push_back((*points)[3]);
            array_insert_last(vector<float>, gbl_points, p1);
            array_insert_last(vector<float>, gbl_points, p2);
            gbl_count += 2;

            if ( isNewLayer ) {
               isNewLayer = false;
            } else {
               char tmp_str[100];
               // construct a face with 4 points.
               // FOR TH BUILDING
               if ( dir == 0 ) {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
               } else {
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 2, gbl_count - 1, gbl_count - 3);
               }
               
               gbl_faces.push_back(strdup(tmp_str));
            }
         }
      }

      // start to write out the data
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n");
      vector<float> pts;
      arrayForEachItem(vector<float>, gbl_points, k1, pts) {
         fprintf(fd_new, "        %f %f %f,\n", pts[0], pts[1], pts[2]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");

      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");
      for (int i = 0; i < gbl_faces.size(); i ++) {
         fprintf(fd_new, "        %s,\n", gbl_faces[i]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);


}

// Function: generate_iv_for_IR_follow_me
//
// Command: Project.exe -j -O "-p input_path -P output_path -t 12"
// This is to show the model from IR
void generate_iv_for_IR_follow_me(char *fn, char *output_path , int dataset_type, int dir, int orientation, int flag_vertical)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   int im_width1 = image_width;
   int im_width2 = 0;
   int dir0 = 0;
   int dir1 = 0;
   int dir2 = 0;
   
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "0:1:2:t:p:P:d:D:fw:W:s:m:M:o:x:X:y:Y:z:Z:")) != EOF)
      {
         switch (c) {
            case 'W':
               im_width2 = atoi(util_optarg);
               break;
            case '0':
               dir0 = atoi(util_optarg);
               break;
            case '1':
               dir1 = atoi(util_optarg);
               break;
            case '2':
               dir2 = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(im_width2 > 0 );
   printf("Direction is di11\n");
   
   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s", output_path);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model BASE_COLOR\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n"); // LightModel
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *fm_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR_with_follow_me(fn, z_arr, fm_arr);
   assert(array_n(end_points) == array_n(z_arr));
   assert(array_n(end_points) == array_n(fm_arr));
      
   double scale1 = 0.0;
   // draw faces
   {
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);

      /*
      double scale = image_width/(x_max - x_min);
      double depth_bottom = (( orientation == 0 ) ? y_min : z_min) * scale;
      double depth_top    = (( orientation == 0 ) ? y_max : z_max) * scale;
      */
      double scale = image_width/(z_max - z_min);
      double depth_bottom = (x_min) * scale;
      double depth_top    = (x_max) * scale;
      double depth_inter = depth_top - depth_bottom;
      scale1 = scale;
      
      int gbl_count = 0;
      array_t *gbl_points = array_alloc(vector<float>, 0);
      vector<char *> gbl_faces;

      int k1, k2;
      array_t *boundary;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         double bottom_base = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(0);
         double top = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(1);
         if ( top == bottom_base ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }

         int x0, y0, x1, y1;
         vector<float> *fm_info = array_fetch(vector<float> *, fm_arr, k1);
         arrayForEachItem(vector<int> *, boundary, k2, points) {

            x0 = (*points)[0];
            y0 = (*points)[1];
            x1 = (*points)[2];
            y1 = (*points)[3];

            // to avoid the same point (no face)
            if ( x1 == x0  && y1 == y0) 
               continue;

            double bottom = bottom_base;
            double upper = bottom;
            float  offset_x = .0;
            float  offset_y = .0;
            float  offset_z = .0;
            for ( int fm_i = 0; fm_i < fm_info->size(); fm_i += 3 )
            {
               offset_x = (*fm_info)[fm_i];
               offset_y = (*fm_info)[fm_i + 1];
               offset_z = (*fm_info)[fm_i + 2] - offset_z;

               upper += offset_z * depth_inter;
               vector<float> p1, p2, p3, p4;
               p1.push_back(x0);
               p1.push_back(y0);
               //p1.push_back(bottom);
               p1.push_back(depth_inter - bottom);
               p2.push_back(x1);
               p2.push_back(y1);
               //p2.push_back(bottom);
               p2.push_back(depth_inter - bottom);
               p3.push_back(x0 + offset_x);
               p3.push_back(y0 + offset_y);
               //p3.push_back(upper);
               p3.push_back(depth_inter - upper);
               p4.push_back(x1 + offset_x);
               p4.push_back(y1 + offset_y);
               //p4.push_back(upper);
               p4.push_back(depth_inter - upper);
               x0 += offset_x;
               y0 += offset_y;
               x1 += offset_x;
               y1 += offset_y;
               bottom = upper;
               
               array_insert_last(vector<float>, gbl_points, p1);
               array_insert_last(vector<float>, gbl_points, p2);
               array_insert_last(vector<float>, gbl_points, p3);
               array_insert_last(vector<float>, gbl_points, p4);
               gbl_count += 4;

               // construct a face with 4 points.
               // FOR TH BUILDING
               char tmp_str[100];
               sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
               
               gbl_faces.push_back(strdup(tmp_str));

            }
         }
      }

      // 2nd model construction
   
      // get the data from IR txt file:
      // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
      if ( flag_vertical ){

         assert(dir1 == 0 || dir1 == 2);
      
         char *ver_fn = strdup(new_file);
         char *ptr = strrchr(ver_fn, '/');
         assert(ptr);
         *ptr = NULL;
         char ver_ir_fn[1000];
         sprintf(ver_ir_fn, "%s/ir.txt", ver_fn);
         array_t *z_arr = array_alloc(vector<float> *, 0);
         array_t *end_points = load_end_points_from_IR(ver_ir_fn, z_arr);
         assert(array_n(end_points) == array_n(z_arr));
         image_width = im_width2;
      
         double x_min, y_min, z_min;
         double x_max, y_max, z_max;
         assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);

         double diff_3D = x_max - x_min;
         double scale = (double)image_width/diff_3D;
         double depth_bottom = (z_min) * scale;
         double depth_top    = (z_max) * scale;
         double depth_inter = depth_top - depth_bottom;

         double ts = scale1/scale;
         array_t *boundary;
         arrayForEachItem(array_t *, end_points, k1, boundary) {
            vector<int> *points;
            double bottom = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(0);
            double top = depth_inter * (array_fetch(vector<float> *, z_arr, k1))->at(1);
            if ( top == bottom ) {
               printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
               printf("Total points is %d.\n", array_n(boundary));
               continue;
            }
            bool isNewLayer = true;
            int x0, y0;
            arrayForEachItem(vector<int> *, boundary, k2, points) {

               // to avoid the same point (no face)
               if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
                  continue;

               x0 = (*points)[0];
               y0 = (*points)[1];
               vector<float> p1, p2;
               if ( dir1 == 0 ) {
                  p1.push_back(ts*(image_width - (*points)[0]));
                  p1.push_back(ts*bottom);
                  p1.push_back(ts*(*points)[1]);
               } else {
                  p1.push_back(ts*bottom);
                  p1.push_back(ts*(*points)[1]);
                  p1.push_back(ts*(image_width - (*points)[0]));
               }

               if ( dir1 == 0 ) {
                  p2.push_back(ts*(image_width - (*points)[2]));
                  p2.push_back(ts*top);
                  p2.push_back(ts*(*points)[3]);
               } else {
                  p2.push_back(ts*top);
                  p2.push_back(ts*(*points)[3]);
                  p2.push_back(ts*(image_width - (*points)[2]));
               }
            
               array_insert_last(vector<float>, gbl_points, p1);
               array_insert_last(vector<float>, gbl_points, p2);
               gbl_count += 2;

               if ( isNewLayer ) {
                  isNewLayer = false;
               } else {
                  char tmp_str[100];
                  // construct a face with 4 points.
                  // FOR TH BUILDING
                  if ( dir == 0 ) {
                     sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
                  } else {
                     sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 2, gbl_count - 1, gbl_count - 3);
                  }
               
                  gbl_faces.push_back(strdup(tmp_str));
               }
            }
         }

      }
      
      // start to write out the data
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n");
      vector<float> pts;
      arrayForEachItem(vector<float>, gbl_points, k1, pts) {
         fprintf(fd_new, "        %f %f %f,\n", pts[0], pts[1], pts[2]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");

      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");
      for (int i = 0; i < gbl_faces.size(); i ++) {
         fprintf(fd_new, "        %s,\n", gbl_faces[i]);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);


}

// Function: generate_iv_for_IR_transform
//
// Command: project -j [-F IR_in.txt] -f IR_out.txt -O "-p IR_in.txt -P trans.txt -t 14 -w 111"
void generate_iv_for_IR_transform(char *fn, char *output_path , int dataset_type, int dir1, int orientation, int flag_vertical, void **params)
{
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR_with_dirs(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));

   // do the transformation on the data;
   float M[12];
   {
      FILE *fd = fopen(output_path, "r");
      assert(fd);      
      int i = 0;
      char str[1000];
      while (fgets(str, 1000, fd))
      {
         assert(sscanf(str, "%f %f %f",&M[i],&M[i+1],&M[i+2]) == 3);
         i += 3;
      }
      assert(i == 9);
      fclose(fd);
   }

   // do the computation on the points and print out the result

   FILE *fd_out = fopen(gbl_opts->output_prefix, "w");
   assert(fd_out);
   
   int k;
   array_t *arr_pts;
   arrayForEachItem(array_t *, end_points, k, arr_pts) 
   {
      vector<float> *vec_info = array_fetch(vector<float> *, z_arr, k);
      int dir = (int)(*vec_info)[0];
      int unit_type = (int) (*vec_info)[1];
      float base = (*vec_info)[2];
      float top  = (*vec_info)[3];
      int dir_group = (int)(*vec_info)[4];

      int l;
      vector<float> *pts;
      fprintf(fd_out, "BEGIN POLYGON\nDIRECTION\n%d %d\nHEIGHT\n", dir, dir_group);
      fprintf(fd_out, "%f %f\nTYPE\n2\nPOINTS\n", base, top);
      arrayForEachItem(vector<float> *, arr_pts, l, pts)
      {
         float a = pts->at(0);
         float b = pts->at(1);
         float c = pts->at(2);

         float p1 = a*M[0] + b*M[3] + c*M[6];
         float p2 = a*M[1] + b*M[4] + c*M[7];
         float p3 = a*M[2] + b*M[5] + c*M[8];
         fprintf(fd_out, "%f %f %f\n", p1, p2, p3);
         
      }
      
      fprintf(fd_out, "EXTRUSION\n");
      fprintf(fd_out, "END POLYGON\n");

   }
}


// Function: generate_iv_for_IR_merge
//
// Command: project -j -O "-p ./ -P IR_all.txt -t 13 -w 111
//          -a 0 -A test_ir.txt -b 1024 -B 512
//          -a 0 -A test_ir_roof.txt -b 1024 -B 512
//          -a 2 -A test_ir_face.txt -b 480 -B 1024
//          -a 2 -A test_ir_face_roof.txt -b 480 -B 1024
//          -x -15.36 -X 80.23 -y -30.18 -Y 89.93 -z -43.68 -Z 5.69 -M 2"
//            
// This is to show the model from IR
void generate_iv_for_IR_merge(char *fn1, char *output_path , int dataset_type, int dir1, int orientation, int flag_vertical, void **params, int insert_type = -1)
{
   char *path_prefix = ".";
   int params_index = 0;
   FILE *fd_output = fopen(output_path, "w");
   assert(fd_output);
   
   while (params[params_index])
   {
      static int dir_group = 0;

      // direction of the face
      int dir = (int) params[params_index++] - 1;
      char *fn_o = (char *)params[params_index++];
      image_width = (int)  params[params_index++];
      image_height = (int) params[params_index++];
      printf("SET %d: %s with dir %d, [%d, %d]\n", params_index/4, fn_o, dir, image_width, image_height);

      char fn[1000];
      sprintf(fn, "%s/%s", path_prefix, fn_o);
      
      // get the data from IR txt file:
      // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
      array_t *z_arr = array_alloc(vector<float> *, 0);
      array_t *end_points = load_end_points_from_IR(fn, z_arr);
      assert(array_n(end_points) == array_n(z_arr));

      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);

      double scale, depth_top, depth_bottom, a_min, b_min;
      assert( dir > -1 && dir < 3);
      if ( dir == 0 ) // y axis
      {
         scale = (x_max - x_min)/(float)image_width;
         depth_bottom = y_min;
         depth_top    = y_max;
         a_min = x_min; b_min = z_min;
      } else if ( dir == 1 ) // z axis
      {
         scale = (x_max - x_min)/(float)image_width;
         depth_bottom = z_min;
         depth_top    = z_max;
         a_min = x_min; b_min = y_min;
      } else if ( dir == 2 ) // x axis
      {
         scale = (z_max - z_min)/(float)image_width;
         depth_bottom = x_min;
         depth_top    = x_max;
         a_min = z_min; b_min = y_min;
      }
      double depth_inter = depth_top - depth_bottom;

      int k1, k2;
      array_t *boundary;
      int pre_x = -1, pre_y = -1;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         vector<float> *mode_info = array_fetch(vector<float> *, z_arr, k1);
         assert( mode_info->size() == 3);
         double bottom = depth_bottom + depth_inter * (*mode_info)[0];
         double    top = depth_bottom + depth_inter * (*mode_info)[1];
         float    type = (*mode_info)[2];

         if ( bottom == top ) {
            printf("MSG: bottom is the same as top, which is %f\n", (*mode_info)[0]);
         }
         
         fprintf(fd_output, "BEGIN POLYGON\nDIRECTION\n%d %d\n", dir, dir_group );
         fprintf(fd_output, "HEIGHT\n%f %f\n", bottom, top);
         if ( insert_type != -1 ) {
            fprintf(fd_output, "TYPE\n%d\n", insert_type);
         }
         fprintf(fd_output, "POINTS\n");
         arrayForEachItem(vector<int> *, boundary, k2, points) {
            if ( pre_x == (*points)[0] && pre_y == (*points)[1] )
               continue;
            assert(points->size() == 4);
            fprintf(fd_output, "%f %f\n", a_min + (*points)[0  ]*scale, b_min + (image_height - (*points)[0+1])*scale);
            // taper point
            // fprintf(fd_output, "%f %f\n", (*points)[0+2]*scale, (image_height - (*points)[0+3])*scale);

            pre_x = (*points)[0];
            pre_y = (*points)[1];
         }
         fprintf(fd_output, "%s\n", type < 0.5 ? "EXTRUSION" : "TAPER");
         fprintf(fd_output, "END POLYGON\n");
      }

      dir_group ++;
   }

   fclose(fd_output);
}

// Function: generate_iv_for_IR_error
//
// Command: Project.exe -j -O "-p input_path -P image_folder -t 8"
// This is to show the deviation mapping for IR
void generate_iv_for_IR_error(char *fn, char *image_folder, int dataset_type )
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   sprintf(new_file, "%s.iv", image_folder);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n"); // LightModel
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));
      
   // draw faces
   {
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);
      
      double z_scaler = image_width/(x_max - x_min);  // 14.628
      double depth_bottom = z_min * z_scaler;
      double depth_top = z_max * z_scaler;
      double depth_inter = depth_top - depth_bottom;

      int gbl_count = 0;
      array_t *gbl_points = array_alloc(vector<float>, 0);
      vector<char *> gbl_faces;

      int k1, k2;
      array_t *boundary;
      float z_btm, z_top, z_type;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         vector<int> *points;
         z_btm = (array_fetch(vector<float> *, z_arr, k1))->at(0);
         z_top = (array_fetch(vector<float> *, z_arr, k1))->at(1);
         z_type = (array_fetch(vector<float> *, z_arr, k1))->at(2);
         double bottom = depth_inter * z_btm;
         double top = depth_inter * z_top;
         if ( top == bottom ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }
         bool isNewLayer = true;
         int x0, y0;
         arrayForEachItem(vector<int> *, boundary, k2, points) {

            // to avoid the same point (no face)
            if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
               continue;

            vector<float> p1, p2;
            p1.push_back((*points)[0]);
            p1.push_back(bottom);
            p1.push_back((*points)[1]);
            p2.push_back((*points)[2]);  // for extruded, it's the same, but for taper, it is not.
            p2.push_back(top);
            p2.push_back((*points)[3]);
            array_insert_last(vector<float>, gbl_points, p1);
            array_insert_last(vector<float>, gbl_points, p2);
            gbl_count += 2;

            if ( isNewLayer ) {
               isNewLayer = false;
            } else {
               char tmp_str[100];
               // construct a face with 4 points.
               sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
               gbl_faces.push_back(strdup(tmp_str));

               char tm_fn[1000];
               sprintf(tm_fn, "texture_%.3f_%.3f_%d-%d_%d-%d_image.png", z_btm, z_top, x0, y0, (*points)[0], (*points)[1]);

               vector<float> p3, p4;
               p3 = array_fetch(vector<float>, gbl_points, gbl_count - 3);
               p4 = array_fetch(vector<float>, gbl_points, gbl_count - 4);

               // draw texture mapping
               fprintf(fd_new, "  Separator {\n");
               if ( 1 || z_type < 1.0 ) {   // ignore the taper structure for now.
                  fprintf(fd_new, "    TextureCoordinate2 {\n");
                  fprintf(fd_new, "      point [ 0 0,\n");
                  fprintf(fd_new, "              0 1,\n");
                  fprintf(fd_new, "              1 1,\n");
                  fprintf(fd_new, "              1 0,]\n");
                  fprintf(fd_new, "    }\n"); // end of TextureCoordinate2
                  fprintf(fd_new, "    Texture2 {\n");
                  fprintf(fd_new, "      filename  \"%s/%s\" \n", image_folder, tm_fn); 
                  fprintf(fd_new, "    }\n"); // end of Texture2
               }
               fprintf(fd_new, "    Coordinate3 {\n");
               fprintf(fd_new, "      point [ %f %f %f,\n", p4[0], p4[1], p4[2]);
               fprintf(fd_new, "              %f %f %f,\n", p3[0], p3[1], p3[2]);
               fprintf(fd_new, "              %f %f %f,\n", p2[0], p2[1], p2[2]);
               fprintf(fd_new, "              %f %f %f,]\n", p1[0], p1[1], p1[2]);
               fprintf(fd_new, "    }\n"); // end of Coordinate3
               fprintf(fd_new, "    FaceSet {\n");
               fprintf(fd_new, "      numVertices	4\n");
               fprintf(fd_new, "    }\n"); // end of FaceSet
               fprintf(fd_new, "  }\n"); // end of Seperator
            }

            x0 = (*points)[0];  // this is the old x, y 
            y0 = (*points)[1];
            
         }

      }

   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);


}

// Function: generate_iv_for_IR_error_layer
//
// Command: Project.exe -j -O "-p input_path -P image_folder -t 10"
// This is to show the deviation mapping for IR
void generate_iv_for_IR_error_layer(char *fn, char *image_folder, int dataset_type)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char new_file[1000];
   char temp_str[1000];
   char old_name[1000];

   assert(image_folder);
   sprintf(new_file, "%s.iv", image_folder);
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model BASE_COLOR\n"); // PHONG
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n"); // LightModel
   }

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));
      
   // draw faces
   {
      double x_min, y_min, z_min;
      double x_max, y_max, z_max;
      assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);
      
      double z_scaler = image_width/(x_max - x_min);  // 14.628
      double depth_bottom = z_min * z_scaler;
      double depth_top = z_max * z_scaler;
      double depth_inter = depth_top - depth_bottom;
      array_t *gbl_points = array_alloc(vector<float>, 0);

      int k1, k2;
      array_t *boundary;
      float z_btm, z_top, z_type;
      arrayForEachItem(array_t *, end_points, k1, boundary) {
         int gbl_count = 0;
         vector<float> p1, p2;
         vector<char *> gbl_faces;
         vector<int> *points;
         z_btm = (array_fetch(vector<float> *, z_arr, k1))->at(0);
         z_top = (array_fetch(vector<float> *, z_arr, k1))->at(1);
         z_type = (array_fetch(vector<float> *, z_arr, k1))->at(2);
         double bottom = depth_inter * z_btm;
         double top = depth_inter * z_top;
         if ( top == bottom ) {
            printf("ERROR: TOP %f, is the same as BOTTOM at height: %f\n", top, (array_fetch(vector<float> *, z_arr, k1))->at(0));
            printf("Total points is %d.\n", array_n(boundary));
            continue;
         }

         // This is for taper structure;
         if ( z_type > 0.5 ) {

            float tmp = 1.0;
            char *tm_fn = NULL;
            int x0 = -1, y0 = -1;
            arrayForEachItem(vector<int> *, boundary, k2, points) {

               // to avoid the same point (no face)
               if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
                  continue;

               p1.push_back((*points)[0]);
               p1.push_back(bottom);
               p1.push_back((*points)[1]);
               p1.push_back((*points)[2]);  // for extruded, it's the same, but for taper, it is not.
               p1.push_back(top);
               p1.push_back((*points)[3]);

               tmp = 1.0 - tmp;

               p2.push_back(tmp);
               p2.push_back(1.0);
               p2.push_back(tmp);
               p2.push_back(0.0);

               if ( k2 > 0 ) {

                  char tmp_str[1000];
                  sprintf(tmp_str, "%s/texture_%.3f_%.3f_%d-%d_%d-%d_image.png", image_folder, z_btm, z_top, x0, y0,(*points)[0],(*points)[1]);
                  printf("INFO: taper texture file: %s\n", tmp_str);
                  if ( file_exist(tmp_str) ) {
                     tm_fn = strdup(tmp_str);
                  }
                  
                  // here we assume the first face file should be existed.
                  // later on, if some face file is not existed, use the previous one.
                  assert( tm_fn != NULL );

                  // draw the texture mapping for taper structure
                  // this is a little bit different from the below extruded one: we have to do texture mapping for each
                  // small face instead of doing the whole layer;
                  {
                     fprintf(fd_new, "  Separator {\n");
                     fprintf(fd_new, "    TextureScalePolicy {\n");
                     fprintf(fd_new, "    	policy FRACTURE\n");
                     fprintf(fd_new, "    }\n");
                     fprintf(fd_new, "    Texture2 {\n");
                     fprintf(fd_new, "      filename  \"%s\" \n", tm_fn); 
                     fprintf(fd_new, "    }\n"); // end of Texture2
                     fprintf(fd_new, "    TextureCoordinate2 {\n");
                     fprintf(fd_new, "      point [ \n");
                     for (int i = p2.size() - 8; i < p2.size(); i +=2 ) {
                        fprintf(fd_new, "              %f %f,\n", p2[i], p2[i+1]);
                     }
                     fprintf(fd_new, "             ]\n}\n");// end of TextureCoordinate2

                     fprintf(fd_new, "    Coordinate3 {\n");
                     fprintf(fd_new, "      point [ \n");
                     for (int i = p1.size() - 12; i < p1.size(); i += 3) {
                        fprintf(fd_new, "              %f %f %f,\n", p1[i], p1[i+1], p1[i+2]);
                     }
                     fprintf(fd_new, "            ]\n}\n");// end of Coordinate3

                     fprintf(fd_new, "    IndexedFaceSet {\n");
                     fprintf(fd_new, "      coordIndex [\n");
                     fprintf(fd_new, "           0, 1, 3, 2, -1,\n"); // end of FaceSet
                     fprintf(fd_new, "                 ]\n}\n"); // end of FaceSet
                     fprintf(fd_new, "  }\n"); // end of Seperator
                  }

               } // end of if a new layer

               x0 = (*points)[0];  // this is the old x, y 
               y0 = (*points)[1];

            } // end of each line segments
            
            continue;
         } // end of taper structure;


         char tm_fn[1000];
         {
            sprintf(tm_fn, "texture_%.3f_%.3f_image.png", z_btm, z_top);
            bool isNewLayer = true;
            int x0, y0;
            int total_width = 0;
            int len_so_far = 0;
            arrayForEachItem(vector<int> *, boundary, k2, points) {
               if ( k2 == 0 ) {
                  x0 = (*points)[0];
                  y0 = (*points)[1];
                  continue;
               }
               float x_l = abs(x0 - (*points)[0]);
               float y_l = abs(y0 - (*points)[1]);
               total_width += (int)(sqrt(x_l*x_l + y_l*y_l));
               x0 = (*points)[0];
               y0 = (*points)[1];
            }
            printf("Total len: %d\n", total_width);

            arrayForEachItem(vector<int> *, boundary, k2, points) {

               // to avoid the same point (no face)
               if ( k2 > 0 && (*points)[0] == x0  && (*points)[1] == y0) 
                  continue;

               p1.push_back((*points)[0]);
               p1.push_back(bottom);
               p1.push_back((*points)[1]);
               p1.push_back((*points)[2]);  // for extruded, it's the same, but for taper, it is not.
               p1.push_back(top);
               p1.push_back((*points)[3]);

               len_so_far += (int) sqrt(float(abs(x0 - (*points)[0])*abs(x0 - (*points)[0]) +
                                              abs(y0 - (*points)[1])*abs(y0 - (*points)[1])));
               float tmp = (float)len_so_far/(float)total_width;
               if (tmp > 1.0) {
                  printf("WARNING: too long, len_so_far %d, ratio: %.2f\n", len_so_far, tmp);
                  tmp = 1.0;
               }
               p2.push_back(tmp);
               p2.push_back(1.0);
               p2.push_back(tmp);
               p2.push_back(0.0);
               gbl_count += 2;
               if ( isNewLayer ) {
                  isNewLayer = false;
               } else {
                  char tmp_str[100];
                  // construct a face with 4 points.
                  sprintf(tmp_str, "%d, %d, %d, %d, -1", gbl_count - 4, gbl_count - 3, gbl_count - 1, gbl_count - 2);
                  gbl_faces.push_back(strdup(tmp_str));
               }

               x0 = (*points)[0];  // this is the old x, y 
               y0 = (*points)[1];
            }

         }
         
         // ignore this part if it is not good
         if ( gbl_faces.size() == 0 || p2.size() < 3 || p1.size() < 3 )
            continue;

         // draw texture mapping
         fprintf(fd_new, "  Separator {\n");
         fprintf(fd_new, "    TextureScalePolicy {\n");
         fprintf(fd_new, "    	policy FRACTURE\n");
         fprintf(fd_new, "    }\n");
         fprintf(fd_new, "    Texture2 {\n");
         fprintf(fd_new, "      filename  \"%s/%s\" \n", image_folder, tm_fn); 
         fprintf(fd_new, "    }\n"); // end of Texture2
         if ( z_type < 1.0 ) {   // ignore the taper structure for now.
            fprintf(fd_new, "    TextureCoordinate2 {\n");
            fprintf(fd_new, "      point [ \n");
            for (int i = 0; i < p2.size(); i +=2 ) {
               fprintf(fd_new, "              %f %f,\n", p2[i], p2[i+1]);
            }
            fprintf(fd_new, "             ]\n}\n");// end of TextureCoordinate2
         }

         fprintf(fd_new, "    Coordinate3 {\n");
         fprintf(fd_new, "      point [ \n");
         for (int i = 0; i < p1.size(); i += 3) {
            fprintf(fd_new, "              %f %f %f,\n", p1[i], p1[i+1], p1[i+2]);
         }
         fprintf(fd_new, "            ]\n}\n");// end of Coordinate3

         fprintf(fd_new, "    IndexedFaceSet {\n");
         fprintf(fd_new, "      coordIndex [\n");
         for (int i = 0; i < gbl_faces.size(); i ++) {
            fprintf(fd_new, "           %s,\n", gbl_faces[i]); // end of FaceSet
         }
         fprintf(fd_new, "                 ]\n}\n"); // end of FaceSet
         fprintf(fd_new, "  }\n"); // end of Seperator

         // test
         printf("Done: %.3f - %.3f\n", z_btm, z_top);
      }

   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);


}

// Function: generate_iv_from_input
//
// Command: Project.exe -j -O "-t 9 -p ../data/Rotated.bpa -P ../data/Rotated_10th.bpa -d 10"
// This is a wrapper for converting ascii to IV file.
void generate_iv_split_bpa( char *input_fn, char *output_fn, int down_s)
{
   FILE *fd = fopen(input_fn, "r");
   assert(fd);
   FILE *fd_new = fopen(output_fn, "w");
   assert(fd_new);

   if ( down_s < 1 )
      down_s = 1;
   
   char str[1000];
   int number = 0;
   while ( fgets(str, 1000, fd) ) {
      if ( number % down_s == 0 ) {
         fprintf(fd_new, "%s", str);
      }
      number ++;
   }
   fclose(fd_new);
   fclose(fd);
}

//  Command: project -j [-F bounding_box.txt] -f xxx -O "-p IR_in.txt -P trans.txt -t 17 -w 111 "
//
void generate_data_from_bounding_box(char *fn, char *output_path , void **params)
{
   // load the matrix if needed
   char str[1000];
   float m[6];
   float x, X, y, Y, z, Z;
   if ( strcmp ( gbl_opts->input_prefix , "XXX" ) != 0 ) { // we have 1x6 bounding box
      FILE *m_fd = fopen(gbl_opts->input_prefix, "r");
      int m_i = 0;
      while ( fgets ( str, 1000, m_fd ) ) {
         assert(sscanf(str, "%f %f %f %f %f %f", &x, &X, &y, &Y, &z, &Z) == 6);
      }

      fclose(m_fd);
   }
   
   // load the real dataset
   FILE *fd = fopen( fn, "r" );
   FILE *fd_out = fopen( output_path, "w" );
   assert ( fd );
   assert ( fd_out );

   while ( fgets ( str, 1000, fd ) ) {
      float a, b, c;
      assert ( sscanf (str, "%f %f %f", &a, &b, &c) == 3);

      if ( a > x && a < X &&
           b > y && b < Y &&
           c > z && c < Z )
         fprintf(fd_out, "%f %f %f\n", a, b, c);
   }

   fclose ( fd_out );
   fclose ( fd );
   
}


//  Command: project -j [-F Matrix_in.txt] -f no_use -O "-p IR_in.txt -P IR_out_name.txt -t 16 -w 111 "
//
void generate_iv_for_3D_real_dataset(char *fn, char *output_path , void **params)
{
   // load the matrix if needed
   char str[1000];
   float m[16];
   bool need_transform = false;
   if ( strcmp ( gbl_opts->input_prefix , "XXX" ) != 0 ) { // we have 4x4 matrix file
      FILE *m_fd = fopen(gbl_opts->input_prefix, "r");
      float a, b, c, d;
      int m_i = 0;
      while ( fgets ( str, 1000, m_fd ) ) {
         assert(sscanf(str, "%f %f %f %f", &a, &b, &c, &d) == 4);
         m[m_i++ ] = a;
         m[m_i++ ] = b;
         m[m_i++ ] = c;
         m[m_i++ ] = d;
      }

      assert( m_i == 16 );
      need_transform = true;
      fclose(m_fd);
   }
   
   // load the real dataset
   FILE *fd = fopen( fn, "r" );
   FILE *fd_out = fopen( output_path, "w" );
   assert ( fd );
   assert ( fd_out );

   while ( fgets ( str, 1000, fd ) ) {
      float a, b, c, d;
      float x, y, z;
      assert ( sscanf (str, "%f, %f, %f, %f", &a, &b, &c, &d) == 4);
      if ( need_transform ) {
         x = m[0]*a + m[1]*b + m[2]*c + m[3];
         y = m[4]*a + m[5]*b + m[6]*c + m[7];
         z = m[8]*a + m[9]*b + m[10]*c + m[11];
      } else {
         x = a;
         y = b;
         z = c;
      }
      
      fprintf(fd_out, "%f %f %f\n", x, y, z);
   }

   fclose ( fd_out );
   fclose ( fd );
   
}

//  3D point cloud generation:
//
//  1. load the normal and faces.
//  2. find the longest line in a face, compute the unit vector of this line segment: u = P0 - P1;
//  3. get the 3rd unit vector: v = CROSS(n, u);
//  4. get the M = [n;u;v] and MM = inv(M); // inverse code: http://www.dreamincode.net/code/snippet1156.htm 
//  5. transform the face using MM to 2D coordinate system. ( data * MM);
//  6. transform the sampled data back to 3D using M. ( data_sample * M);
//
//  Function: generate_iv_for_IR_transform
//
//  Command: project -j [-F IR_in.txt] -f IR_out.txt -O "-p IR_in.txt -P trans.txt -t 15 -w 111 -A <sample_rate> -o 0/1"
//
//  Know Issue: if the face is not convex, it may create wrong point cloud - a quick bypass is break this concave to convex by adding lines.

void generate_iv_for_3D_pont_cloud(char *fn, char *output_path , int dataset_type, int dir1, int orientation, int flag_vertical, void **params)
{
   int sampling_type = orientation;
   // sampling_type: 0 - no sampling, 1 - uniform sampling.
   
   // load the data with NORMAL field.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR_with_dirs(fn, z_arr);

   FILE *output_fd = fopen(gbl_opts->output_prefix, "w");
   assert(output_fd);
   FILE *output_3D_fd = fopen(output_path, "w");
   assert(output_3D_fd);
   
   // find the longest line in a face, compute unit vector of it.
   // make sure element in z_arr has size of 9;

   int k, inner;
   array_t *arr_pts;
   int iteration = 0;
   arrayForEachItem(array_t *, end_points, k, arr_pts) {

      // ignore faces already been processed.
      if ( iteration > 0 ) {
         iteration -- ;
         continue;
      }

      printf("No. %5d of %d faces.\n", k, array_n(end_points));
      
      vector<float> *z_info = array_fetch(vector<float> *, z_arr, k);
      POINT_3D n;
      assert(z_info->size() >= 9);
      n.x = z_info->at(6);
      n.y = z_info->at(7);
      n.z = z_info->at(8);
      
      vector<float> *pts;
      POINT_3D p1, p2;
      float max_dist = 0.0;
      int index_longest = -1;
      arrayForEachItem(vector<float> *, arr_pts, inner, pts) {

         p2.x = pts->at(0);
         p2.y = pts->at(1);
         p2.z = pts->at(2);
         
         if ( inner == 0 ) {
            p1 = p2;
            continue;
         }
         
         float dist = pt_distance(p1, p2);
         if ( dist > max_dist ) {
            max_dist = dist;
            index_longest = inner;
         }

         p1 = p2;
      }

      // compute the unit vector;
      assert( index_longest != -1 );
      pts = array_fetch(vector<float> *, arr_pts, index_longest - 1);
      //pts = array_fetch(vector<float> *, arr_pts, 0);
      p1.x = pts->at(0);
      p1.y = pts->at(1);
      p1.z = pts->at(2);
      //pts = array_fetch(vector<float> *, arr_pts, 1);
      pts = array_fetch(vector<float> *, arr_pts, index_longest);
      p2.x = pts->at(0);
      p2.y = pts->at(1);
      p2.z = pts->at(2);

      POINT_3D u;
      u.x = p2.x - p1.x;
      u.y = p2.y - p1.y;
      u.z = p2.z - p1.z;
      compute_unit_vector(u);

      POINT_3D v;
      cross_product(n, u, v);

      // compute the inverse matrix
      float **M = matrix_malloc(3);
      M[0][0] = n.x; M[0][1] = n.y; M[0][2] = n.z;
      M[1][0] = u.x; M[1][1] = u.y; M[1][2] = u.z;
      M[2][0] = v.x; M[2][1] = v.y; M[2][2] = v.z;

      float **MM = compute_inverse_matrix(M, 3);

      if ( 0 ) // for test and debug
      {

         float a = -705.238767;
         float b = -495.356366;
         float c = -21.653543;
         float u, v, w;
         u = a*MM[0][0]+b*MM[1][0]+c*MM[2][0];
         v = a*MM[0][1]+b*MM[1][1]+c*MM[2][1];
         w = a*MM[0][2]+b*MM[1][2]+c*MM[2][2];
         printf("ORIGINAL: %f %f %f\n", a, b, c);
         printf("INVERSE: %f %f %f\n", u, v, w);

         a = u; b = v; c = w;
         u = a*M[0][0]+b*M[1][0]+c*M[2][0];
         v = a*M[0][1]+b*M[1][1]+c*M[2][1];
         w = a*M[0][2]+b*M[1][2]+c*M[2][2];
         printf("BACK: %f %f %f\n", u, v, w);
         
         exit(0);
      }

      float min_x = 100000.0;
      float min_y = 100000.0;
      float max_x = -100000.0;
      float max_y = -100000.0;

      // compute the new coordinates and generate the new files.
      array_t *new_points_arr = NULL;
      array_t *new_end_points = array_alloc(array_t *, 0);
      while (1)
      {
         fprintf(output_fd, "INVERSE MATRIX MM:\n");
         fprintf(output_fd, "%f %f %f\n", MM[0][0], MM[0][1], MM[0][2]);
         fprintf(output_fd, "%f %f %f\n", MM[1][0], MM[1][1], MM[1][2]);
         fprintf(output_fd, "%f %f %f\n", MM[2][0], MM[2][1], MM[2][2]);
         fprintf(output_fd, " MATRIX M:\n");
         fprintf(output_fd, "%f %f %f\n", M[0][0], M[0][1], M[0][2]);
         fprintf(output_fd, "%f %f %f\n", M[1][0], M[1][1], M[1][2]);
         fprintf(output_fd, "%f %f %f\n", M[2][0], M[2][1], M[2][2]);
         new_points_arr = array_alloc(vector<float> *, 0);
         fprintf(output_fd, "BEGIN\n");
         arrayForEachItem(vector<float> *, arr_pts, inner, pts) {
            float a = pts->at(0);
            float b = pts->at(1);
            float c = pts->at(2);

            float u, v, w;
            u = a*MM[0][0]+b*MM[1][0]+c*MM[2][0];
            v = a*MM[0][1]+b*MM[1][1]+c*MM[2][1];
            w = a*MM[0][2]+b*MM[1][2]+c*MM[2][2];
            fprintf(output_fd, "%f %f %f\n", u, v, w);

            vector<float> *pt = new vector<float>();
            pt->push_back(u);
            pt->push_back(v);
            pt->push_back(w);
            array_insert_last(vector<float> *, new_points_arr, pt);

            if ( iteration == 0 ) { // assume the outer loop boundary determine the bounding box.
               min_x = v < min_x ? v : min_x;
               max_x = v > max_x ? v : max_x;
               min_y = w < min_y ? w : min_y;
               max_y = w > max_y ? w : max_y;
            }
            
         }
         fprintf(output_fd, "END %d\n", array_n(arr_pts));
         array_insert_last(array_t *, new_end_points, new_points_arr);

         if ( k == array_n(end_points) - 1)
            break;
         
         // there are may be multiple faces in this plane
         // NOTE: the z_info->at(4)::dir_group shows the Nth face of the plane.
         //       if N is not 0, means there are more than 1 face existed in this plane.
         iteration ++;
         vector<float> *z_info = array_fetch(vector<float> *, z_arr, k+iteration);
         float num_face = z_info->at(4);

         if ( num_face == 0.0 ) {
            iteration --;
            break; // a new plane
         } else {
            arr_pts = array_fetch(array_t *, end_points, k+iteration);
         }

      }

      ////////////////////////////////////////////////////////////////////
      //////     Now, let's do sampling on the transformed data   ////////
      ////////////////////////////////////////////////////////////////////

      float sample_rate = 10.0;
      unsigned int num_sampling = 0;
      unsigned int num_done_spl = 0;
      float face_max_y = max_y;
      float face_min_y = min_y;
      if ( params[0] ) {
         sample_rate = atof((char *)params[0]);
      }

      if ( sampling_type == 1) {
         float d1 = (max_x - min_x) / sample_rate;
         float d2 = (max_y - min_y) / sample_rate;
         num_sampling = (int) (d1 * d2);
      }

      {
         vector<float> *vec_samples = new vector<float>();
         float normal_coord;
         
         // compute the intersection of lines:
         // Line1: x = c ( c is a constant ).
         // Line?: lines of the polygon
         // Add all points between the max and min point of the polygon.
         // Here, we assume the polygon is convex polygon.
         my_printf("MIN_X: %.4f, MAX_X: %.4f\n", min_x, max_x);
         for ( float x = min_x; x < (sample_rate + max_x ) || sampling_type == 1 ; x += sample_rate)
         {
            // uniform sampling
            if ( sampling_type == 1) {
               if ( num_done_spl > num_sampling )
                  break;
               x = min_x + rand()/(float)RAND_MAX * (max_x - min_x);
            }
            
            int j1;
            array_t *new_points_arr;
            vector<float> line_range;
            float max_y, min_y;
            arrayForEachItem(array_t *, new_end_points, j1, new_points_arr) 
            {
               max_y = -111111.0;
               min_y =  111111.0;
               
               int pt_indx;
               vector<float> *pts;
               POINT_3D p1, p2;
               arrayForEachItem(vector<float> *, new_points_arr, pt_indx, pts) {

                  // we have to include the last one and the first one as a line segment
                  vector<float> *pts_2 = array_fetch(vector<float> *, new_points_arr, (pt_indx + 1)%(array_n(new_points_arr)));
               
                  p1.x = pts->at(1);
                  p1.y = pts->at(2);
                  //p1.z = pts->at(2);
               
                  p2.x = pts_2->at(1);
                  p2.y = pts_2->at(2);
                  //p2.z = pts_2->at(2);

                  if (pt_indx == 0)
                     normal_coord = pts->at(0);

                  // both points are in the same side.
                  if ( ( p1.x < x && p2.x < x ) ||
                       ( p1.x > x && p2.x > x ) )
                     continue;

                  float min_v = min(p1.y, p2.y);
                  float max_v = max(p1.y, p2.y);
               
                  if ( abs(p1.x - p2.x) < 0.1 ) {
                     max_y = max_y < max_v ? max_v : max_y;
                     min_y = min_y > min_v ? min_v : min_y;
                  } else {
                     float y_v = p1.y + ( (x - p1.x)/(p2.x - p1.x) )*(p2.y - p1.y);
                     max_y = max_y < y_v ? y_v : max_y;
                     min_y = min_y > y_v ? y_v : min_y;
                  }

               }

               if ( max_y > min_y ) { // meaning there is intersection.
                  line_range.push_back(min_y);
                  line_range.push_back(max_y);
               }
            }

            // adding points
            sort(line_range.begin(), line_range.end());
            if ( line_range.size() > 2 )
            {
               assert(line_range.size() % 2 == 0);
               static int multi_face_no = 1;
               my_printf("Found No. %3d multiple faces: x is %.3f - [", multi_face_no, x, line_range.size()/2);
               multi_face_no ++;

               for(int i = 0; i < line_range.size(); i ++ )
                  my_printf("%.4f ", line_range[i]);
               my_printf("]\n");

               if ( sampling_type == 1) {
                  // this is a little bit harder
                  ++num_done_spl;
                  float rate = rand()/(float)RAND_MAX;
                  float total_dis = 0.0, cum_rate = 0.0;
                  bool found = false;
                  float cur_y;
                  total_dis = face_max_y - face_min_y;

                  // make sure there are no more density points on faces with windows.
                  // otherwise, we will observe that it is darker around area with windows/wholes.
                  {
                     for(int i = 0; i < line_range.size() - 1; i ++ ) {
                        float this_rate = (line_range[i+1] - line_range[i])/total_dis;
                        if ( cum_rate + this_rate >= rate ) {
                           if ( i % 2 == 0 ) {
                              found = true;
                              cur_y = line_range[i] + ((rate - cum_rate)/this_rate)*(line_range[i+1] - line_range[i]);
                           }
                           break;
                        }
                        cum_rate += this_rate;
                     }

                     if ( found ) {
                        vec_samples->push_back(x);
                        vec_samples->push_back(cur_y);
                     }

                  }
               }
               
            } else if ( sampling_type == 1 && line_range.size() == 2){
               min_y = line_range[0];
               max_y = line_range[1];
               float cur_y = min_y + rand()/(float)RAND_MAX * (max_y - min_y);
               vec_samples->push_back(x);
               vec_samples->push_back(cur_y);
               ++num_done_spl;
            }
               

            if ( sampling_type != 1 ){
               for ( int i = 0 ; i < line_range.size(); i += 2)
               {
                  min_y = line_range[i];
                  max_y = line_range[i+1];
                  if ( max_y > min_y ) {
                     for (float j = min_y; j < max_y; j += sample_rate )
                     {
                        vec_samples->push_back(x);
                        vec_samples->push_back(j);
                     }
                     vec_samples->push_back(x);
                     vec_samples->push_back(max_y);
                  }
               }
            }

         }

         if ( 0 ) // for test and debug
         {
            //test
            int pt_indx;
            vector<float> *pt;
            vec_samples->clear();
            arrayForEachItem(vector<float> *, new_points_arr, pt_indx, pt) {
               vec_samples->push_back(pt->at(1));
               vec_samples->push_back(pt->at(2));
            }
         }
         
         // transform the point back and dump them.
         // fprintf(output_3D_fd, "BEGIN\n");
         for (int i = 0; i < vec_samples->size(); i +=2 ) {

            float a = normal_coord;
            float b = vec_samples->at(i);
            float c = vec_samples->at(i+1);

            float u, v, w;
            u = a*M[0][0]+b*M[1][0]+c*M[2][0];
            v = a*M[0][1]+b*M[1][1]+c*M[2][1];
            w = a*M[0][2]+b*M[1][2]+c*M[2][2];
            fprintf(output_3D_fd, "%f %f %f\n", u, v, w);
         }
         // fprintf(output_3D_fd, "END %d\n", vec_samples->size()/2);

         delete vec_samples;
      }

      array_free(new_end_points);

      
      
   }

   fclose(output_fd);
   fclose(output_3D_fd);
   
}


// Function: generate_iv_from_input
//
// Command: Project.exe -j -O ""
// This is a wrapper for converting ascii to IV file.
void generate_iv_from_input ()
{
   int input_file_type = 13;
   char *input_file_name = NULL;
   char *output_file_path = NULL;
   int down_sampling = 0;
   int max_faces = 0;
   int start_faces = 0;
   int dataset_type = 2;
   int dir = 0;
   int flag_vertical = 0;
   int orientation = 0;
   int insert_type = -1;
   image_width = -1;
   char *opt_backup;

   const int NUM_PARAM = 40;
   int params_index = 0;
   void **params = (void **) malloc( NUM_PARAM * sizeof(void *));
   memset(params, 0, NUM_PARAM * sizeof(void *));
   
   if (global_opts)
   {

      opt_backup = strdup(global_opts);
      
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "0:1:2:a:A:b:B:d:D:fi:m:M:o:p:P:s:t:w:W:x:X:y:Y:z:Z:")) != EOF)
      {
         switch (c) {
            case 'f':
               flag_vertical = 1;
               break;
            case 'a':
               params[params_index++] = (void *)(atoi(util_optarg)+1);
               break;
            case 'A':
               params[params_index++] = (void *)strdup(util_optarg);
               break;
            case 'b':
               params[params_index++] = (void *)atoi(util_optarg);
               break;
            case 'B':
               params[params_index++] = (void *)atoi(util_optarg);
               break;
            case 'i':
               insert_type = atoi(util_optarg);
               break;
            case 'o':
               orientation = atoi(util_optarg);
               break;
            case 't':
               input_file_type = atoi(util_optarg);
               break;
            case 'm':
               max_faces = atoi(util_optarg);
               break;
            case 'w':
               image_width = atoi(util_optarg);
               break;
            case 'M':
               dataset_type = atoi(util_optarg);
               break;
            case 's':
               start_faces = atoi(util_optarg);
               break;
            case 'd':
               down_sampling = atoi(util_optarg);
               break;
            case 'D':
               dir = atoi(util_optarg);
               break;
            case 'x':
               set_x_min(atof(util_optarg));
               break;
            case 'X':
               set_x_max(atof(util_optarg));
               break;
            case 'y':
               set_y_min(atof(util_optarg));
               break;
            case 'Y':
               set_y_max(atof(util_optarg));
               break;
            case 'z':
               set_z_min(atof(util_optarg));
               break;
            case 'Z':
               set_z_max(atof(util_optarg));
               break;
            case 'p':
               input_file_name = strdup(util_optarg);
               break;
            case 'P':
               output_file_path = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   if (global_opts)
      free(global_opts);
   global_opts = opt_backup;

   assert(input_file_name);
   assert(output_file_path);
   assert(image_width != -1 );
   // assert(params_index % 4 == 0);

   if ( input_file_type == 0 ) // load Gene's data
   {
      generate_iv_from_ptx(input_file_name, down_sampling, output_file_path);
   } else if ( input_file_type == 1 ){  // load old bpa data
      generate_iv_from_bpa();
   } else if ( input_file_type == 2 ){  // concatenate splitted bpa data into one big file
      generate_cat_from_parts(input_file_name, output_file_path, max_faces);
   } else if ( input_file_type == 3 ){  // load splitted bpa data
      generate_iv_from_slices(input_file_name, output_file_path);
   } else if ( input_file_type == 4 ){  // load splitted bpa data to generate a big BPA iv file
      generate_iv_for_3D_BPA_model(input_file_name, output_file_path, down_sampling, max_faces, start_faces);
   } else if ( input_file_type == 5 ){  // load splitted bpa data into smf file for qslim as input
      generate_smf_for_qslim(input_file_name, output_file_path, down_sampling, max_faces, start_faces);
   } else if ( input_file_type == 6 ){  // for SIGGRAPH, highlight slab of 3D data
      generate_iv_for_slab_highlight(input_file_name, output_file_path, max_faces, down_sampling, start_faces );
   } else if ( input_file_type == 7 ){  // for IR, generate 3D model with faces in Inventor
      generate_iv_for_IR(input_file_name, output_file_path, dataset_type, dir, orientation );
   } else if ( input_file_type == 8 ){  // for IR deviation mapping, generate error model with texture mapping in Inventor
      generate_iv_for_IR_error(input_file_name, output_file_path, dataset_type );
   } else if ( input_file_type == 9 ){  // split the big bpa files into smaller one.
      generate_iv_split_bpa(input_file_name, output_file_path, down_sampling );
   } else if ( input_file_type == 10 ){  // for IR deviation mapping, texture mapping layer by layer
      generate_iv_for_IR_error_layer(input_file_name, output_file_path, dataset_type );
   } else if ( input_file_type == 11 ){  // for IR, generate 3D model with faces in Inventor in multiple dirs.
      generate_iv_for_IR_multi_dir(input_file_name, output_file_path, dataset_type, dir, flag_vertical );
   } else if ( input_file_type == 12 ){  // for IR, generate 3D model with faces in Inventor with follow-me structure
      generate_iv_for_IR_follow_me(input_file_name, output_file_path, dataset_type, dir, orientation, flag_vertical );
   } else if ( input_file_type == 13 ){  // for IR, combine IRs into one file from all directions
      generate_iv_for_IR_merge(input_file_name, output_file_path, dataset_type, dir, orientation, flag_vertical, params, insert_type );
   } else if ( input_file_type == 14 ){  // for IR, tranform the side1 to side2 with matrix T.
      generate_iv_for_IR_transform(input_file_name, output_file_path, dataset_type, dir, orientation, flag_vertical, params );
   } else if ( input_file_type == 15 ){  // generalized version of transform based 3x3 matrix.
      generate_iv_for_3D_pont_cloud(input_file_name, output_file_path, dataset_type, dir, orientation, flag_vertical, params );
   } else if ( input_file_type == 16 ){  // for real dataset, transform the data based on 4x4 matrix
      generate_iv_for_3D_real_dataset(input_file_name, output_file_path, params );
   } else if ( input_file_type == 17 ){  // for bounding box/ Not iv, but the original data.
      generate_data_from_bounding_box(input_file_name, output_file_path, params );
   } else { // merge small iv files to one single iv file.
      generate_iv_from_sub_ivs(input_file_name, output_file_path, start_faces);
   }

}

// Function: sort_IR_on_height
//
// Command: Project.exe -m -O "-p input_IR -P output_IR"
// This is to sort IR for SketchUp, so that the model has the same color for SIGGRAPH workflow figure.
void sort_IR_on_height()
{
   char *input_file_name = NULL;
   char *output_file_path = NULL;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "p:P:")) != EOF)
      {
         switch (c) {
            case 'p':
               input_file_name = strdup(util_optarg);
               break;
            case 'P':
               output_file_path = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(input_file_name);
   assert(output_file_path);

   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(input_file_name, z_arr);
   assert(array_n(end_points) == array_n(z_arr));

   FILE *fd = fopen(output_file_path, "w");
   assert(fd);
   
   // sort the keyslices based on z_arr[0]
   st_table *st_done = st_init_table(st_numcmp, st_numhash);
   while (true) {
      float layer = 1.1; // maximum 1.0
      int index = -1;
      int k;
      vector<float> *vec_h;
      arrayForEachItem(vector<float> *, z_arr, k, vec_h) {
         if ( (*vec_h)[0] <= layer && !st_lookup(st_done, (char *)k, (char **)NULL)) {
            layer = (*vec_h)[0];
            index = k;
         }
      }

      if ( index > -1 ) {
         st_insert(st_done, (char *)index, (char *)1);

         // write out the new IR
         float bottom = (array_fetch(vector<float> *, z_arr, index))->at(0);
         float top = (array_fetch(vector<float> *, z_arr, index))->at(1);
         float type = (array_fetch(vector<float> *, z_arr, index))->at(2);

         if ( top == bottom )  // discard if height is zero
            continue;
         
         array_t *boundary_pts = array_fetch(array_t *, end_points, index);
         vector<int> *pts;
         fprintf(fd, "BEGIN POLYGON\n");
         arrayForEachItem(vector<int> *, boundary_pts, k, pts) {
            fprintf(fd, "%d %d\n", (*pts)[0], (*pts)[1]);
         }

         if ( type < 1 ) {
            fprintf(fd, "EXTRUSION\n");
         } else {
            fprintf(fd, "TAPERED\n");
            arrayForEachItem(vector<int> *, boundary_pts, k, pts) {
               fprintf(fd, "%d %d\n", (*pts)[2], (*pts)[3]);
            }
         }

         fprintf(fd, "HEIGHT\n");
         fprintf(fd, "%f %f\n", bottom, top);
         fprintf(fd, "END POLYGON\n");
         
      }
      else {
         // all sorted
         assert( st_count(st_done) == array_n(end_points) );
         break;
      }
   }
}

void test_data_for_DP(char *name, int mode)
{
   FILE *fd = fopen(name, "w+");
   FILE *input_fd = fopen("ras2vec.ply", "r");
   assert(fd);
   assert(input_fd);

   int n = 0;
   char str_line[1000];
   while (fgets(str_line, 1000, input_fd))
   {

      if (strncmp(str_line, "POLY", 4) == 0 || strncmp(str_line, "END", 3) == 0)
      {
         continue;
      }
      else
      {
         if (mode)
            fprintf(fd, "%s", str_line);
         n++;
      }
   }

   if (mode)
   {
      fclose(fd);
      fclose(input_fd);
      printf("Total %d lines data!\n", n);
      return;
   }
      
   n = n*2;
   fwrite(&n, sizeof(int), 1, fd);
   float *f_v = (float *) malloc (sizeof(float) * n);
   n = 0;
   
   assert(fseek( input_fd, 0L, 0) == 0);   
   while (fgets(str_line, 1000, input_fd))
   {

      if (strncmp(str_line, "POLY", 4) == 0 || strncmp(str_line, "END", 3) == 0)
         continue;
      else
      {
         sscanf(str_line, "%f %f", f_v+n, f_v+n+1);
         n += 2;
      }
   }

   fwrite(f_v, sizeof(float), n, fd);
   printf("Total %d lines are recorded!\n", n/2);
   
   fclose(fd);
   fclose(input_fd);
}

enum COLOR_VALUE {
   RED,
   GREEN,
   BLUE
};

void set_color(BYTE ***im, int y, int x, BYTE r, BYTE g, BYTE b)
{
   if (im == NULL) return;
   
   if (y < 0 || y > image_height - 1 ||
       x < 0 || x > image_width  - 1)
      return;
   
   im[y][x][0] = r;
   im[y][x][1] = g;
   im[y][x][2] = b;
}

void set_color(BYTE ***im, int i, int j, COLOR_VALUE value)
{
   switch (value)
   {
      case RED:
         im[i][j][0] = 255;
         im[i][j][1] = 0;
         im[i][j][2] = 0;
         break;
      case GREEN:
         im[i][j][0] = 0;
         im[i][j][1] = 255;
         im[i][j][2] = 0;
         break;
      case BLUE:
         im[i][j][0] = 0;
         im[i][j][1] = 0;
         im[i][j][2] = 255;
         break;
      default:
         break;
   }
}

int neighbor_prob(int y, int x, int range, int value,BYTE **im, int h, int w)
{
   int startY = y-range>0? y-range : 0;
   int endY   = y+range<h? y+range : h-1;
   int startX = x-range>0? x-range : 0;
   int endX   = x+range<w? x+range : w-1;

   int res = 0;
   for (int i = startY; i < endY; i++)
      for (int j = startX; j < endX; j++)
         if (im[i][j] == value)
            res ++;

   return res;
   
}

typedef struct boundary_ {
   BYTE ***im;
   BYTE **ref_im;
   int  change_ref;
} boundary_return;
   

// Function: compute_landing
// 
// Return: image with colored pixels for showing the matching results
// Known issues:
boundary_return *compute_landing(FILE *comp_res, BYTE **cur_im, BYTE ** cur_im_boundary, BYTE **ref_im, BYTE **ref_im_boundary, int h, int w, int change_ref)
{

   int num_common = 0;
   int new_num_common = 0;
   int num_cur_im_bound = 0;
   int num_ref_im_bound = 0;

   //boundary_return *res = (boundary_return *) malloc (sizeof(boundary_return);
   boundary_return *res = new boundary_return;
   //make color image memory space
   BYTE ***image = new BYTE** [h];
   image[0] = new BYTE* [h*w];
   image[0][0] = new BYTE [h*w*3];
   memset(image[0][0], 255, h*w*3);
   for (int y=0; y<h; y++)
   {
      image[y] = image[0] + w*y;
      for (int x=0; x<w; x++)
         image[y][x] = image[0][0] + (w*y + x)*3; // fix a bug from (w*y*3)
   }
   res->im = image;
   res->change_ref = 0;

   for (int i = 0; i < h; i ++)
      for (int j = 0; j < w; j ++)
      {
         if (ref_im_boundary[i][j] == BLACK)
            num_ref_im_bound ++;
         
         if (cur_im_boundary[i][j] == BLACK){
            num_cur_im_bound ++;

            // common data - GREEN
            if (ref_im_boundary[i][j] == BLACK)
            {
               num_common ++;
               set_color(image, i, j, GREEN);
            }
            else {
               // noise data? - RED
               if (neighbor_prob(i, j, 1, BLACK,ref_im_boundary, h, w) > 0)
               {
                  new_num_common ++;
                  set_color(image, i, j, RED);                  
               }
               else{  // missing data? - BLUE
                  set_color(image, i, j, BLUE);                                    
               }
            }
         }

      }
   
   // RED - step 3, get the noise data

   new_num_common += num_common;
   float stat1 = (float)(new_num_common)/num_cur_im_bound*100;  // // of match on current new image
   float stat2 = (float)(num_common)/num_ref_im_bound*100;      // // of match on reference image

   char str[1000];
   sprintf(str, "%10d", num_cur_im_bound);
   fprintf(comp_res, str);
   sprintf(str, "%10d", num_ref_im_bound);
   fprintf(comp_res, str);
   sprintf(str, "%10.2f%%", stat1);
   fprintf(comp_res, str);
   sprintf(str, "%10.2f%%", stat2);
   fprintf(comp_res, str);

   if (stat2 < 60 )
      res->change_ref = change_ref + 1; // accumulate to 2 to change the reference image.
   else
      res->change_ref = 0;  // set this to zero;

   return res;
}
    
BYTE **my_imread(char *file_name)
{
   BYTE **result;

#ifdef LINUX
   CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(file_name);
#else   
   wchar_t pwc[1000];
   mbstowcs( pwc, file_name, 1000);
   Bitmap* bitmap_mimio = new Bitmap(pwc);
#endif
   
   set_image(result, bitmap_mimio);
   return result;
   
}

void my_printf(const char *fmt, ...)
{
   if (DEBUG_BPA < ALL_INFO)
      return;
   
   /* Guess we need no more than 1000 bytes. */
   int n, size = 100;
   char *p;
   va_list ap;
   if ((p = (char *)malloc (size)) == NULL)
      return;
   
   while (1) {
      /* Try to print in the allocated space. */
      va_start(ap, fmt);
#ifndef MSVC_60
      n = vsnprintf (p, size, fmt, ap);
#endif
      va_end(ap);
      /* If that worked, return the string. */
      if (n > -1 && n < size)
      {
         printf(p);
         return;
      }
      /* Else try again with more space. */
      if (n > -1)    /* glibc 2.1 */
         size = n+1; /* precisely what is needed */
      else           /* glibc 2.0 */
         size *= 2;  /* twice the old size */
      if ((p = (char *)realloc (p, size)) == NULL)
         return;
   }

}

BYTE **integrate_image(int start, int end, int len)
{

   BYTE **tmp_im;
   BYTE **res_im;

   char str_pad[10];
   char file_name[1000];
   for (int k = start; k < end; k++)
   {
      if (k < 10)
         strcpy(str_pad,"00"); 
      else if (k < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      sprintf(file_name, "../data/new-slices/slice_1024_%s%d.png", str_pad, k);
      
      tmp_im = my_imread(file_name);
      if (k==start)
      {
         res_im = tmp_im;
         continue;
      }
      else
      {
         for (int i = 0; i < len; i++)
            res_im[0][i] |= tmp_im[0][i];
      }
   }

   return res_im;
}

DIST ** set_hausdorff_distance_table(BYTE**image, int h, int w)
{
   int x, y;
   size_t i;
   int span_steps;
   int count = 0;
   Vector *temp_node_vector, *node_vector;
   DIST **lut;

   lut = (DIST**)malloc(sizeof(DIST*)*h);
   lut[0] = (DIST*)malloc(sizeof(DIST)*h*w);
   for (y=0; y<h; y++)
      lut[y] = lut[0] + w*y;

   // Init the LUT.
   // use watering method.
   node_vector = create_vector();

   for (y=0; y<h; y++)
      for(x=0; x<w; x++)
      {
         if (image[y][x] == BLACK)
         {
            lut[y][x] = 0;
            push_back(node_vector,x);
            push_back(node_vector,y);
         }
         else 
            lut[y][x] = MAXIMUM;
      }

   span_steps = 1;
   temp_node_vector = create_vector();
   while (true)
   {
      for (i=0; i<node_vector->size; i=i+2)
      {
         int node_x = (node_vector->data)[i];
         int node_y = (node_vector->data)[i+1];
         int x, y;

         // Ignore the boundary rectangle first!
         if (node_x > 0 && node_x < w - 1 && node_y > 0 && node_y < h - 1)
         {

            y = node_y -1; x = node_x;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y -1; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x-1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y -1; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y ; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }
            y = node_y +1; x = node_x+1;
            if (lut[y][x] == MAXIMUM)
            {
               lut[y][x] = span_steps;
               push_back(temp_node_vector, x);
               push_back(temp_node_vector, y);
            }

         }

      }

      span_steps ++;
      //printf("span %d\n", span_steps);

      //// number of new nodes > 0, if == 0, means all pixel has been watered.
      if (temp_node_vector->size == 0)
         break;

      free(node_vector->data);
      free(node_vector);
      node_vector = temp_node_vector;
      temp_node_vector = create_vector();
      //printf("node_vector size is %d", node_vector.size());

   }

   return lut;
}


vector<int>* compute_Hausdorff(BYTE **A, BYTE **B, int h, int w)
{
   DIST **lut = set_hausdorff_distance_table(B, h, w);

   vector<int> *res_vector = new vector<int>;
   
   for (int i = 0; i < h; i++)
      for (int j = 0; j < w; j++)
      {
         if (A[i][j] == BLACK)
            res_vector->push_back(lut[i][j]);
      }
   
   // free look-up table
   free(*lut);
   free(lut);
   
   return res_vector;
   
}


double average_HD(vector<int> *v1, float ratio)
{

   if (v1->size() == 0)
      return 0.0;
   
   int len = (int) (v1->size() * ratio);
   if (len == 0) len = 1;
   
   double sum = 0;
   for (int i = 0; i < len; i++)
      sum += (*v1)[i];
   
   double average_dis = sum/len;

   return average_dis;
}     

// Function: boundary_matching
//
// Key slice detection using Hausdorff distance measurement
void boundary_matching()   // Hausdorff distance based match
{

#ifndef LINUX
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif   

   FILE *comp_res = fopen("../data/temp/comp_result.txt", "w");
   
   fprintf(comp_res, "image index | HD | REV. HD");

   int START=80;  // a middle image as a reference (find a good one)
   int k = START;
   int NUM = START+110;
   char str_pad[6];
   char str[100];
   int  start_ref = 0;
   BYTE **cur_im, **ref_im, **int_im, **pre_im;
   int change_ref = 0;
   while (true)
   {
      printf("\nprocessing slice %d ...\n", k);
      if (k < 10)
         strcpy(str_pad,"00"); 
      else if (k < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      sprintf(str, "\nslice_%s%d", str_pad, k);
      fprintf(comp_res, str);
      char file_name[256];
      char result_name[256];
      sprintf(file_name, "../data/new-slices/slice_1024_%s%d.png", str_pad, k);
      sprintf(result_name, "../data/temp/result_slice_1024_%s%d.png", str_pad, k);

#ifndef LINUX
      wchar_t pwc[1000];
      mbstowcs( pwc, file_name, 1000);
      Bitmap* bitmap_mimio = new Bitmap(pwc);
      int h = bitmap_mimio->GetHeight();
      int w = bitmap_mimio->GetWidth();
#else
      CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(file_name);
      int h = bitmap_mimio->dimy();
      int w = bitmap_mimio->dimx();
#endif

      set_image(cur_im,bitmap_mimio);
      
      if (k == START) {
         ref_im = cur_im;
         k++;
         continue;
      }

      // compute the Hausdorff distance between the images
      vector<int> *v1 = compute_Hausdorff(ref_im, cur_im, h, w);
      vector<int> *v2 = compute_Hausdorff(cur_im, ref_im, h, w);

      sort(v1->begin(), v1->end(), greater<int>());
      sort(v2->begin(), v2->end(), greater<int>());      

      // for testing - compare the hausdorff distance - better use emacs.
      //for (int i = 0; i < v1->size(); i ++)
      // fprintf(comp_res, "%3d",  (*v1)[i]);

      // based on observation, 10% is the best ratio for comparison.
      // compute the average value for the 10% biggest distance.
      // e.g., use 83 as reference image, the average value until 92 is 1.2-1.5,
      // starting from 93, it is 5.x - 6.x.. If use 93 as reference, the average
      // value until 115 around 3.x. so use the middle vale 4-4.5 as the threshold.
      const float HD_THRESH = 4.0;

      double average_dis  = average_HD(v1, 0.1);
      double average_dis2 = average_HD(v2, 0.1);

      //printf("The average distance of biggest 0.1 is %4f\n", average_dis);
      //printf("The reverse average distance of biggest 0.1 is %4f\n", average_dis2);
      fprintf(comp_res, " %4f", average_dis);
      fprintf(comp_res, " %4f", average_dis2);

      if (average_dis > HD_THRESH )
      {
         ref_im = cur_im;
         printf("\nChange the reference image to current image %d\n", k);
         fprintf(comp_res, "\nChange the reference image to current image %d\n", k);

         Save2File(result_name, cur_im ,bitmap_mimio, 0, 0, 0, NULL);
      }

      k++;
      if (k > NUM) break;

   }

   fclose(comp_res);
 
}

// Function: boundary_matching_pixel_landing
//
// Key slice detection using pixel landing approach
void boundary_matching_pixel_landing()
{

#ifndef LINUX
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/bmp", &clsid);
#endif   

   FILE *comp_res = fopen("../data/temp/comp_result.txt", "w");
   
   fprintf(comp_res, "image index | current | ref.  |comm/cur(%%)|comm/ref (%%)");

   int START=1;
   int k = START;
   int NUM = 30;
   char str_pad[6];
   char str[100];
   int  start_ref = 0;
   BYTE **cur_im, **ref_im, **int_im, **pre_im;
   int change_ref = 0;
   while (true)
   {
      printf("processing slice %d ...\n", k);
      if (k < 10)
         strcpy(str_pad,"00"); 
      else if (k < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      sprintf(str, "\nslice_%s%d", str_pad, k);
      fprintf(comp_res, str);
      char file_name[256];
      char result_name[256];
      sprintf(file_name, "../data/new-slices/slice_1024_%s%d.png", str_pad, k);
      sprintf(result_name, "../data/temp/result_slice_1024_%s%d.png", str_pad, k);

#ifndef LINUX
      wchar_t pwc[1000];
      mbstowcs( pwc, file_name, 1000);
      Bitmap* bitmap_mimio = new Bitmap(pwc);
      int h = bitmap_mimio->GetHeight();
      int w = bitmap_mimio->GetWidth();
#else
      CImg<BYTE> *bitmap_mimio = new CImg<BYTE>(file_name);
      int h = bitmap_mimio->dimy();
      int w = bitmap_mimio->dimx();
#endif

      set_image(cur_im,bitmap_mimio);
      
      if (k == START) {
         ref_im = cur_im;
         int_im = cur_im;
         k++;
         continue;
      }

      BYTE **cur_im_boundary = boundary_detect(cur_im, h, w);
      BYTE **ref_im_boundary = boundary_detect(ref_im, h, w);
      BYTE **int_im_boundary = boundary_detect(int_im, h, w);

      boundary_return *br = compute_landing(comp_res, cur_im, cur_im_boundary, ref_im, ref_im_boundary, h, w, change_ref );

      Save2File(result_name, NULL, bitmap_mimio, 0, 0, 1, br->im);

      // update the images
      //if (min(size(stat)) > 1 && stat(1,2) < 50 && stat(2,2) < 50)
      change_ref = br->change_ref;
      
      if (br->change_ref == 2)
      {
         sprintf(str, "\nA new reference image at slice %d\n", k-1);
         fprintf(comp_res, str );
         ref_im = pre_im; // pre_im is the image of previous one. if we want to more backtracking, need more.
         BYTE **ref_save_im = integrate_image(start_ref, k, h*w);
         
         k = k - 2;       // assume, k will be increased by 1.
         start_ref = k;
         sprintf(str, "../data/temp/accu_reference_%d.png",k);

         Save2File(str, ref_save_im, bitmap_mimio, 0, 0, 0, NULL);
         if (k > NUM) break;
      }
    
      pre_im = cur_im;
    
      k++;
      if (k > NUM) break;

   }

   fclose(comp_res);
 
}

// Function: my_HT
// Hough transform of C version
//
// Return value are saved in pdetect and tetadetect
void my_HT(BYTE **im_2D, int h, int w, int &pdetect, int &tetadetect)
{
   int pstep = HT_PSTEP;
   int tetastep = HT_TETASTEP;
   int kernel = 8;

   int dia_len = (int)sqrt((double)(h*h + w*w));
   vector<int> p;
   vector<int> teta;
   for (int i = 0; i <= dia_len; i+=pstep) // change from i = 1 to i = 0, for there is 1 pixel low than the real data of the lines.
      p.push_back(i);
   // NOTE: angle is clock-wise, 0 degree is right pointing, 90 degree is down pointing.
   // ALSO: it is not possible having an angle teta, s.t.  180 <  teta  < 270
   for (int i = 0; i <= 360-tetastep; i+=tetastep)
      teta.push_back(i);

   int mrows = p.size();
   int ncols = teta.size();
   long data_len = mrows*ncols;
   int ic = w;
   int ir = h;
   vector<int> z(data_len);

   // testing
   BYTE *im = im_2D[0];

   /* Inline the myht subroutine. */
   /* myht(z, acc, im, p, np, t, nt, row, col); */
   for (int i = 0; i<data_len; i++) z[i] = 0;

   int max_vote = 0;
   int max_index = -1;
   int counter = 0;
   for (int i = 0; i < ic; i ++) /* i is xIndex, j is yIndex */
      for (int j = 0; j < ir; j++)
      {
         //if (im[i*ir + j] == BLACK) /* find(Imbinary == 0)*/
         if (im[j*ic + i] == BLACK) /* find(Imbinary == 0)*/
         {
            counter++;
            double Indteta = 0.0;

            for (int ifi = 0; ifi < ncols; ifi ++)
            {
               double temp1 = teta[ifi]*PI/180;
                  
               // The following equation is obtained by triangle equation
               // l = i*cos(temp1) + j*sin(temp1) by parellel
               // refer to the wiki HT for the above equation.
               // here, ifi is iterating through all angles, and then compute
               // the roi(pronunciation of Greek symbol), which is the distance
               // from origin to the line cross the point.
               double roi = i*cos(temp1) + j*sin(temp1);
               if ( roi > 1 && roi < p[mrows-1])
               {
                  double temp2 = floor((roi+0.5)/pstep);
                  int index = (int)(Indteta*mrows + temp2);
                  z[index] ++;

                  if (z[index] >= max_vote)
                  {
                     max_vote = z[index];
                     max_index = index;
                  }
               }

               Indteta ++;
            }


         }

      }
   /* end of big for */

   // get the maximum location and value?
   /*
     vector<int>::iterator loc =  max_element(z.begin(), z.end());
     int i; 
     for (i = 0; i < data_len; i++)
     if (z[i] == *loc)
     break;
   */

   // get the location based on loc;
   int p_index = max_index % mrows;
   int t_index = max_index / mrows;
   pdetect = p[p_index] ;
   tetadetect = teta[t_index];

}

#if 0
// Function: my_HT_array
// Hough transform of C version
//
// Return value are saved in pdetect and tetadetect as an array
void my_HT_array(BYTE **im_2D, int h, int w, vector<int> &pdetect, vector<int> &tetadetect, int thres = 0)
{
   int pstep = HT_PSTEP;
   int tetastep = HT_TETASTEP;
   int kernel = 8;

   int dia_len = (int)sqrt((double)(h*h + w*w));
   vector<int> p;
   vector<int> teta;
   for (int i = 0; i <= dia_len; i+=pstep) // change from i = 1 to i = 0, for there is 1 pixel low than the real data of the lines.
      p.push_back(i);
   for (int i = 0; i <= 360-tetastep; i+=tetastep)
      teta.push_back(i);

   int mrows = p.size();
   int ncols = teta.size();
   long data_len = mrows*ncols;
   int ic = w;
   int ir = h;
   vector<int> z(data_len);

   // testing
   BYTE *im = im_2D[0];

   /* Inline the myht subroutine. */
   /* myht(z, acc, im, p, np, t, nt, row, col); */
   for (int i = 0; i<data_len; i++) z[i] = 0;

   for (int i = 0; i < ic; i ++) /* i is xIndex, j is yIndex */
      for (int j = 0; j < ir; j++)
      {
         //if (im[i*ir + j] == BLACK) /* find(Imbinary == 0)*/
         if (im[j*ic + i] == BLACK) /* find(Imbinary == 0)*/
         {
            for (int ifi = 0; ifi < ncols; ifi ++)
            {
               double temp1 = teta[ifi]*PI/180;
                  
               // The following equation is obtained by triangle equation
               // l = i*cos(temp1) + j*sin(temp1) by parellel
               double roi = i*cos(temp1) + j*sin(temp1);
               if ( roi > 1 && roi < p[mrows-1])
               {
                  double temp2 = floor((roi+0.5)/pstep);
                  int index = (int)(ifi*mrows + temp2);
                  z[index] ++;

               }

            }
         }
      }
   /* end of big for */

   // get the location based on loc;
   int th = (thres == 0) ? 50 : thres;
   for (int i = 0 ; i < data_len; i ++)
   {
      if (z[i] < th) continue;
      
      int p_index = i % mrows;
      int t_index = i / mrows;
      pdetect.push_back(p[p_index]);
      tetadetect.push_back(teta[t_index]);
      my_printf("No. %3d: %4d - %4d\n", pdetect.size(), p[p_index], teta[t_index]);
   }

   printf("The HT array results: %d %d \n", pdetect.size(), tetadetect.size());
}
#else
void draw_line_on_data(int pd, int td, BYTE **im, int h, int w, BYTE ***im3D, BYTE **orig_im, vector<int> &line_set);
vector<int> find(BYTE *im, int len, int value);
// Function: my_HT_array
// Hough transform of C version
//
// Return value are saved in pdetect and tetadetect as an array
void my_HT_array(BYTE **im_2D, int h, int w, vector<int> &pd_v, vector<int> &td_v, int thres = 0)
{
   int pdetect;
   int tetadetect;
   vector<int> temp;      
   vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
   
   BYTE **Imbinary = copy_image(im_2D, h, w);
   while (true)
   {
      my_HT(Imbinary, h, w, pdetect, tetadetect);
      pd_v.push_back(pdetect);
      td_v.push_back(tetadetect);
      my_printf("No. %3d: %4d - %4d\n", pd_v.size(), pdetect, tetadetect);
      
      // draw line on the image
      draw_line_on_data(pdetect, tetadetect, Imbinary, h, w, NULL, im_2D, line_set);

      temp = find(*Imbinary,h*w, BLACK);
      if (temp.size() == 0) break;
   }
   
}
#endif

void clear_data(BYTE **im, int y, int x, int val, int clear_mask = 0)
{
   int mask;
   if ( clear_mask == 0 ) {
      mask = HT_MASK;
   } else {
      mask = gbl_opts->BPA_clear_data_mask;
   }
   
   for (int i = -mask; i < mask+1; i++)
      for (int j = -mask; j < mask+1; j++)
         if (y+i>-1 && y+i<image_height && 
			 x+j>-1 && x+j<image_width)
			 im[y+i][x+j] = val;
}

FILE *copy_dxf_head(char *fn)
{
   FILE *new_fn = fopen(fn, "w");
   FILE *tf = fopen("./template.dxf", "r");

   assert (new_fn);
   assert (tf);

   char line_str[1000];
   while (fgets(line_str, 1000, tf))
      fprintf(new_fn, line_str);

   fclose(tf);
   return new_fn;
}

vector<int> *pixels_dilation(vector<int> *vec, int mask)
{
   map<int, int> map_pixels;
   vector<int> *return_vec = new vector<int> ();
   for ( int i = 0; i < vec->size(); i ++ ) {
      int x0 = x_axis(vec->at(i));
      int y0 = y_axis(vec->at(i));

      for ( int x = x0 - mask ; x <= x0 + mask; x ++ )
         for ( int y = y0 - mask ; y <= y0 + mask; y ++ ) {
            int coord = index(x, y);
            if ( valid_pixel(x, y) &&
                 map_pixels.find(coord) == map_pixels.end() ) {
               map_pixels[coord] = 1;
               return_vec->push_back(coord);
            }
         }
   }

   return return_vec;
}

#if 1
// Function: pixels_between_2_points
// Return a vector<int> store the pixels between 2 points
vector<int> *pixels_between_2_points_in_order(int h, int w, int x1, int y1, int x2, int y2)
{
   vector<int> *result = new vector<int>;
   int x=x1, y=y1;
   bool need_reverse = false;

   float step;
   if (x1 == x2)
   {
	   x = min(y1, y2);
	   y = max(y1, y2);

      if (y1 > y2)
         need_reverse = true;
      
      for (int i = x; i < y+1; i++)
         result->push_back(index(x1, i));
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { need_reverse = true; int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy; }
         for (x=x1; x<x2+1; x++)
         {
            y = (int)(y1 + (x - x1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         if (y1 > y2) { need_reverse = true; int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1; y<y2+1; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
   }

   vector<int> *ret;
   if (need_reverse)
   {
      ret = new vector<int> ();
      for (int i = result->size() -1; i >= 0; i--)
         ret->push_back((*result)[i]);

      delete result;
      
   } else
      ret = result;
         
   return ret;
}
#else
// Function: pixels_between_2_points_in_order
// Return a vector<int> store the pixels between 2 points
vector<int> *pixels_between_2_points_in_order(int h, int w, int x1, int y1, int x2, int y2)
{
   vector<int> *result = new vector<int>;
   int x=x1, y=y1;

   float step;
   if (x1 == x2)
   {
      assert(y1 != y2);
      int sign = y1 > y2 ? -1 : 1;
      
      for (int i = y1; i != y2; i += sign)
         result->push_back(index(x1, i));

   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         int sign = x1 > x2 ? -1 : 1;
         //if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x = x1; x != x2; x += sign)
         {
            y = (int)(y1 + (x - x1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         int sign = y1 > y2 ? -1 : 1;
         //if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y = y1; y != y2; y += sign)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
   }

   // the last point
   result->push_back(index(x2, y2));

   return result;
}
#endif

// Function: pixels_between_2_points
// Return a vector<int> store the pixels between 2 points
vector<int> *pixels_between_2_points(int h, int w, int x1, int y1, int x2, int y2)
{
   vector<int> *result = new vector<int>;
   int x=x1, y=y1;

   float step;
   if (x1 == x2)
   {
      x = min(y1, y2);
      y = max(y1, y2);
      
      for (int i = x; i < y; i++) {
         if (x1 >= 0 && i >= 0 && x1 < w && i < h)
            result->push_back(index(x1, i));
      }
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x=x1+1; x<x2; x++)
         {
            y = (int)(y1 + (x - x1)*step +.5);
            //y = (int)(y1 + (x - 1 - x1)*step);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         //step = 1/step;   // if step == 0, will be in the above case.
         if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1+1; y<y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
               result->push_back(index(x, y));
         }
      }
   }

   return result;
}

// Function: draw_line_on_2D_image
// set the pixels on the line to be BLACK
void draw_line_on_2D_image(BYTE **im, int h, int w, int x1, int y1, int x2, int y2)
{
   int x=x1, y=y1;

   if (x1 >= 0 && y1 >= 0 && x1 < w && y1 < h) {
      im[y1][x1] = BLACK;
   }
   if (x2 >= 0 && y2 >= 0 && x2 < w && y2 < h) {
      im[y2][x2] = BLACK;
   }
   
   float step;

   if (x1 == x2)
   {
      x = min(y1, y2);
      y = max(y1, y2);
      
      for (int i = x; i < y; i++)
      {
         if (x1 >= 0 && i >= 0 && x1 < w && i < h)
            im[i][x1] = BLACK;
      }
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x=x1+1; x<x2; x++)
         {
            y = (int)(y1 + (x - x1)*step +.5);
            //y = (int)(y1 + (x - 1 - x1)*step);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               im[y][x] = BLACK;
            }
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         //step = 1/step;   // if step == 0, will be in the above case.
         if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1+1; y<y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               im[y][x] = BLACK;
            }
         }
      }
   }
   
}

// Function: draw_line_on_2D_image_between_arbit_two_points
// set the pixels on the line to be BLACK
void draw_line_on_2D_image_between_arbit_two_points(BYTE **im, int h, int w, int x1, int y1, int x2, int y2)
{
   int x=x1, y=y1;

   if (valid_pixel(x1, y1))
      im[y1][x1] = BLACK;

   if (valid_pixel(x2, y2))
      im[y2][x2] = BLACK;

   float step;

   if (x1 == x2)
   {
      x = min(y1, y2);
      y = max(y1, y2);
      
      for (int i = x; i < y; i++)
      {
         if (valid_pixel(x1, i))
            im[i][x1] = BLACK;
      }
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x=x1+1; x<x2; x++)
         {
            y = (int)(y1 + (x - x1)*step +.5);
            if (valid_pixel(x, y))
                  im[y][x] = BLACK;
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);;   // if step == 0, will be in the above case.
         if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1+1; y<y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (valid_pixel(x, y))
               im[y][x] = BLACK;
         }
      }
   }
   
}

// Function: draw_line
// draw 3D line using default 3 default parameters.
void  draw_line(BYTE ***im, int h, int w, int x1, int y1, int x2, int y2, int r, int g, int b)
{
   int x=x1, y=y1;

   set_color(im, y1, x1, r,g,b);
   set_color(im, y2, x2, r,g,b);

   float step;

   if (x1 == x2)
   {
      x = min(y1, y2);
      y = max(y1, y2);
      
      for (int i = x; i < y; i++)
      {
         set_color(im, i, x1, r, g, b);
      }
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x=x1+1; x<x2; x++)
         {
            y = (int)(y1 + (x - x1)*step +.5);
            //y = (int)(y1 + (x - 1 - x1)*step);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               set_color(im, y, x, r, g, b);
            }
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         //step = 1/step;   // if step == 0, will be in the above case.
         if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1+1; y<y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               set_color(im, y, x, r, g, b);
            }
         }
      }
   }
   
}

// default 3 default parameters.
void  draw_line_and_clear_data(BYTE ***im, int h, int w, int x1, int y1, int x2, int y2, int r, int g, int b, BYTE **im_data, int val, int clear_mask = 0)
{
   int x=x1, y=y1;

   set_color(im, y1, x1, r,g,b);
   set_color(im, y2, x2, r,g,b);
   clear_data(im_data, y1, x1, val, clear_mask);
   clear_data(im_data, y2, x2, val, clear_mask);   

   float step;

   if (x1 == x2)
   {
      x = min(y1, y2);
      y = max(y1, y2);
      
      for (int i = x; i < y; i++)
      {
         set_color(im, i, x1, r, g, b);
         clear_data(im_data, i, x1, val, clear_mask);
      }
      
   } else {
      step = (float)(y2-y1)/(x2-x1);
      if (abs((int)step) < 1 )
      {
         if (x1 > x2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (x=x1+1; x<x2; x++)
         {
            y = (int)(y1 + (x - x1)*step +.5);
            //y = (int)(y1 + (x - 1 - x1)*step);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               set_color(im, y, x, r, g, b);
               clear_data(im_data, y, x, val, clear_mask);
            }
         }
      }
      else
      {
         step = (float)(x2-x1)/(y2-y1);
         //step = 1/step;
         if (y1 > y2) { int yy = y1, xx = x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}
         for (y=y1+1; y<y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if (x >= 0 && y >= 0 && x < w && y < h)
            {
               set_color(im, y, x, r, g, b);
               clear_data(im_data, y, x, val, clear_mask);
            }
         }
      }
   }
   
}

// Function: new_3D_image
// Helper function to new 3D image
BYTE *** new_3D_image(int h, int w)
{
   BYTE ***image = new BYTE** [h];
   image[0] = new BYTE* [h*w];
   image[0][0] = new BYTE [h*w*3];
   memset(image[0][0], 255, h*w*3);
   for (int y=0; y<h; y++)
   {
      image[y] = image[0] + w*y;
      for (int x=0; x<w; x++)
         image[y][x] = image[0][0] + (w*y + x)*3; // fix a bug from (w*y*3)
   }

   return image;
}

void set_3D_image(BYTE **Imbinary, BYTE *** &image, int h,int w)
{
   //make color image memory space
   image = new_3D_image(h, w);

   for (int y=0; y < h; y++)
      for (int x = 0; x < w; x++)
         if (Imbinary[y][x] == BLACK)
            set_color(image, y, x, 0, 0, 0);
   
}

bool neighbor_pixel_num(BYTE** im, int x, int y, int mask, int thresh)
{
   int counter = 0;
   
   for (int i = -mask; i < mask+1; i++)
      for (int j = -mask; j < mask+1; j++)
         if (y+i>-1 && y+i<image_height && 
			 x+j>-1 && x+j<image_width  &&
			 im[y+i][x+j] == BLACK)
            counter ++;

   if (counter >= thresh)
      return true;
   else
      return false;
}

/*
  Refine the red line segments:
  check from both ends whether there is any neighbor pixels around them,
  if not, decrease the length of the line segments.
 */
bool post_line_seg(BYTE **im, double& x1, double& y1, double& x2, double& y2)
{
   float step;
   int x, y;
   int MASK = 2;
   int THRESH = 4;

   if (x1 == x2)
   {
      x = (int) min(y1, y2);
      y = (int) max(y1, y2);
      
      for (int i = x; i <= y; i++)
         if (neighbor_pixel_num(im, (int)x1, i, MASK, THRESH))
         {
            y1 = i;
            break;
         }
      for (int i = y; i >= x; i--)
         if (neighbor_pixel_num(im, (int)x1, i, MASK, THRESH))
         {
            y2 = i;
            break;
         }

      if (abs(y1-y2) <= HT_NUMTHRESH)
         return false;
      else
         return true;

   } else {
      step = (float)(y2-y1)/(float)(x2-x1);
      if (abs((int)step) < 1 )
      {
         for (x=(int)x1; x<=x2; x++)
         {
            y = (int)(y1 + (x - x1)*step + .5);
            if ( //(x >= 0 && y >= 0 && x < w && y < h) &&
                 (neighbor_pixel_num(im, x, y, MASK, THRESH)))
            {
               x1 = x;
               y1 = y;
               break;
            }
         }
         for (x=(int)x2; x>=x1; x--)
         {
            y = (int)(y1 + (x - x1)*step + .5);
            if ( //(x >= 0 && y >= 0 && x < w && y < h) &&
                 (neighbor_pixel_num(im, x, y, MASK, THRESH)))
            {
               x2 = x;
               y2 = y;
               break;
            }
         }

         if (abs(x1-x2) <= HT_NUMTHRESH)
            return false;
         else
            return true;

      }
      else
      {
         step = (float)(x2-x1)/(float)(y2-y1);
         if (y1 > y2) { int yy = (int)y1, xx = (int)x1; y1 = y2; x1 = x2; x2 = xx; y2 = yy;}

         for (y=(int)y1; y<=y2; y++)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if ( //(x >= 0 && y >= 0 && x < w && y < h) &&
                 (neighbor_pixel_num(im, x, y, MASK, THRESH)))
            {
               x1 = x;
               y1 = y;
               break;
            }
         }
         for (y=(int)y2; y>=y1; y--)
         {
            x = (int)(x1 + (y - y1)*step + .5);
            if ( //(x >= 0 && y >= 0 && x < w && y < h) &&
                 (neighbor_pixel_num(im, x, y, MASK, THRESH)))
            {
               x2 = x;
               y2 = y;
               break;
            }
         }
         
         if (abs(y1-y2) <= HT_NUMTHRESH)
            return false;
         else
            return true;
         
      }
   }

}


void HT_get_two_points(int pd, int td, int h, int w, BYTE **im, vector<int> &line_set)
{
   int cols = w;
   int rows = h;
   int data_len = h*w;
   //for i = 1:length(pdetect)
   int i = 0;
   vector<double> pdetect;
   vector<double> tetadetect;
   pdetect.push_back((double)pd);
   tetadetect.push_back((double)td);

   double x1, x2, y1, y2;
   double ptStart, ptEnd;
   if (tetadetect[i] == 90)
   {
      x1 = 0;     y1 = pdetect[i];
      x2 = cols;   y2 = y1;
   }
   else {
      ptStart = pdetect[i]/cos(PI*(tetadetect[i]/180));
      ptEnd = -rows*(tan(PI*(tetadetect[i]/180))) + ptStart;
      x1 = ptStart;   y1 = 0;
      x2 = ptEnd;     y2 = rows;
   }

   line_set.push_back((int)(x1 + .5));
   line_set.push_back((int)(y1 + .5));
   line_set.push_back((int)(x2 + .5));
   line_set.push_back((int)(y2 + .5));

   int len = line_set.size();
   draw_line_and_clear_data(NULL, h, w,
                            line_set[len-4],line_set[len-3], line_set[len-2], line_set[len-1],
                            0, 0, 0, im,
                            WHITE, 1);
   
}

#if 1

// CHANGE: 6/13/2008
// Because we redefined a line segment based on a new two-end-point, a big error may introduced.
// To conqure this, we should keep the original points on the lines.

// function: draw_line_on_data
// Draw HT lines based on real data, so that the line segments match up the data.
void draw_line_on_data(int pd, int td, BYTE **im, int h, int w, BYTE ***im3D, BYTE **orig_im, vector<int> &line_set)
{

   int cols = w;
   int rows = h;
   int data_len = h*w;
   //for i = 1:length(pdetect)
   int i = 0;
   vector<double> pdetect;
   vector<double> tetadetect;
   pdetect.push_back((double)pd);
   tetadetect.push_back((double)td);

   double x1, x2, y1, y2;
   double ptStart, ptEnd;
   if (tetadetect[i] == 90)
   {
      x1 = 0;     y1 = pdetect[i];
      x2 = cols;   y2 = y1;
   }
   else {
      ptStart = pdetect[i]/cos(PI*(tetadetect[i]/180));
      ptEnd = -rows*(tan(PI*(tetadetect[i]/180))) + ptStart;
      x1 = ptStart;   y1 = 0;
      x2 = ptEnd;     y2 = rows;
   }

   // test the accuracy of the detected lines
   // This is used to verify the correctness of my_HT.
   // It turned out that the my_HT is accurate, but the
   // red line drawing is not accurate.
   // the reason may be related to the floating <=> int
   if (0)
   {
      static int counter = 0;
      BYTE **HTImg = copy_image(im,h,w);
      draw_line_on_2D_image_between_arbit_two_points(HTImg, h, w, x1, y1, x2, y2);
      // draw_line_on_data
      char *ds = digit_string(3, counter);
      char fn[100];
      sprintf(fn, "my_HT_whole_line_%s.png", ds);
      Save2File(fn, HTImg, NULL, w, h, 0, NULL);
      free(ds);
      free_image(HTImg);
      counter++;
   }
   

   vector<int> *line_pxls = pixels_between_2_points_in_order(h, w, x1, y1, x2, y2);

   // lambdaThresh  - the threshold of the MASK, indicating an valid pixel closing enough to true data
   // NumThresh     - At least the number of true data found in LenThresh
   // LenThresh     - Window to check the NumThresh.
   int lambdaThresh = HT_LAMBDATHRESH; // another important threshold. tried, 1, 2, 4, the best one is 2.
   double NumThresh = HT_NUMTHRESH; // ANOTHER IMPORTANT THRESHOLD.
   double LenThresh = HT_LENTHRESH; // ANOTHER IMPORTANT THRESHOLD.

   // Compute the line segments.
   // We should change this by keeping original data from ptAllX and ptAllY
   // 06.13.2008
   // CASES:
   // 1. noise data with broken pixels, like  ...  ..  ...  ... .. .....
   // 2. true separated line segments, like ...........      ................    ...............
   
   
   int last_not_empty = 0;
   int indexStart = 0;
   int started = false;
   int accum = -1; 
   int len = line_pxls->size();
   int consec_empty_num = 0;
   int MASK = HT_MASK;
   while ( ++accum < len)
   {
      int cur_x = x_axis((*line_pxls)[accum]);
      int cur_y = y_axis((*line_pxls)[accum]);

      bool is_empty_point = neighbor_pixel_num(im, cur_x, cur_y, MASK, 1) == 0 ? true : false;
      if (is_empty_point && !started)
         continue;

      if (!started) {
         started = true; // Found a valid point;
         indexStart = accum;
      }

      if (is_empty_point) {
         consec_empty_num ++;
      } else {
         consec_empty_num = 0;
         last_not_empty = accum;
      }

      if (consec_empty_num > LenThresh)
      {
         // let's ignore this segment if it is too short
         // get all points from indexStart -> accum
         if (accum - indexStart - consec_empty_num > LenThresh)
         {
            // post-process the end points
            // 1st point
            for (int i = indexStart; i < last_not_empty; i ++)
            {
               int x = x_axis((*line_pxls)[i]);
               int y = y_axis((*line_pxls)[i]);
               if ( neighbor_pixel_num(im, x, y, MASK, MASK*2)) {
                  indexStart = i;
                  break;
               }
            }

            // 2nd point
            for (int i = last_not_empty; i > indexStart; i --)
            {
               int x = x_axis((*line_pxls)[i]);
               int y = y_axis((*line_pxls)[i]);
               if ( neighbor_pixel_num(im, x, y, MASK, MASK*2)) {
                  last_not_empty = i;
                  break;
               }
            }
            
            line_set.push_back(x_axis((*line_pxls)[indexStart]));
            line_set.push_back(y_axis((*line_pxls)[indexStart]));
            line_set.push_back(x_axis((*line_pxls)[last_not_empty]));
            line_set.push_back(y_axis((*line_pxls)[last_not_empty]));

            // if this is NULL, means we are only interested in the points
            {
               assert(last_not_empty > indexStart);
               for (int i = indexStart; i <= last_not_empty; i ++)
               {
                  int x = x_axis((*line_pxls)[i]);
                  int y = y_axis((*line_pxls)[i]);
                  // clear_data(im, y, x, WHITE);
                  if (im3D)
                     set_color(im3D, y, x, 255, 0, 0);
               }
            }
         }

         started = false;
         consec_empty_num = 0;
         last_not_empty = 0;
         indexStart = 0;
         
      } // end of long consective empty points

      // BUG: here let us clear the points around the im, otherwise, it will never clear up im.
      // Then, the upper while (1) loop will never stop.
      clear_data(im, cur_y, cur_x, WHITE, 2);
   }

}

#else

// function: draw_line_on_data
// Draw HT lines based on real data, so that the line segments match up the data.
void draw_line_on_data(int pd, int td, BYTE **im, int h, int w, BYTE ***im3D, BYTE **orig_im, vector<int> &line_set)
{

   int cols = w;
   int rows = h;
   int data_len = h*w;
   //for i = 1:length(pdetect)
   int i = 0;
   vector<double> pdetect;
   vector<double> tetadetect;
   pdetect.push_back((double)pd);
   tetadetect.push_back((double)td);

   double x1, x2, y1, y2;
   double ptStart, ptEnd;
   if (tetadetect[i] == 90)
   {
      x1 = 0;     y1 = pdetect[i];
      x2 = cols;   y2 = y1;
   }
   else {
      ptStart = pdetect[i]/cos(PI*(tetadetect[i]/180));
      ptEnd = -rows*(tan(PI*(tetadetect[i]/180))) + ptStart;
      x1 = ptStart;   y1 = 0;
      x2 = ptEnd;     y2 = rows;
   }

   // test the accuracy of the detected lines
   // This is used to verify the correctness of my_HT.
   // It turned out that the my_HT is accurate, but the
   // red line drawing is not accurate.
   // the reason may be related to the floating <=> int
   if (1)
   {
      static int counter = 0;
      BYTE **HTImg = copy_image(im,h,w);
      draw_line_on_2D_image_between_arbit_two_points(HTImg, h, w, x1, y1, x2, y2);
      // draw_line_on_data
      char *ds = digit_string(3, counter);
      char fn[100];
      sprintf(fn, "my_HT_whole_line_%s.png", ds);
      Save2File(fn, HTImg, NULL, w, h, 0, NULL);
      free(ds);
      free_image(HTImg);
      counter++;
   }
   
   // Equation 11
   double diffX = x2 - x1;
   double diffY = y2 - y1;
   double disPow = diffX*diffX + diffY*diffY;
   double deSq = sqrt(disPow);

   int lambdaThresh = HT_LAMBDATHRESH; // another important threshold. tried, 1, 2, 4, the best one is 2.
   int x, y;
   vector<double> ptAllX;
   vector<double> ptAllY;

   typedef double dv_iter;
   map<dv_iter, dv_iter> map_xy;
   map<dv_iter, dv_iter> map_yx;
   for (int index = 0; index < data_len; index ++ )
   {
      if (im[0][index] == BLACK)
      {
         x = index % cols;
         y = index / cols;
          
         // Distance equation from "http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html"
         double dArray = (double) abs(diffX*(y1-y) - diffY*(x1-x))/(double)deSq;
         if (dArray < lambdaThresh)
         {
            // Instead of remove data at this point, we should remove data when red line is drawn.

            // 06.11.2008 - COMMENT OUT.
            // im[y][x] = WHITE; // Remove the data fitted into a line.
                                                           
            // Find the line segments between this two points.
            // Strategy Pattern for Algorithms for C++
            // Project the data on the line
            double u = ((x - x1)*diffX + y*diffY)/disPow; // Vector
            double pX = x1 + u*diffX;
            double pY = y1 + u*diffY;
            ptAllX.push_back(pX);
            ptAllY.push_back(pY);
            map_xy.insert(pair<dv_iter, dv_iter>((ptAllX.back()), (ptAllY.back())));
            map_yx.insert(pair<dv_iter, dv_iter>((ptAllY.back()), (ptAllX.back())));
         }
          
      }
   }

    
   // in case theta in 45-135 and 225-315, use X, otherwise, Y. COMMENTS:
   double NumThresh = HT_NUMTHRESH; // ANOTHER IMPORTANT THRESHOLD.
   double LenThresh = HT_LENTHRESH; // ANOTHER IMPORTANT THRESHOLD.

   int alongX = false;
   double LenThreshDir;
   if ((tetadetect[i] > 45 && tetadetect[i] < 135) || (tetadetect[i] > 225 && tetadetect[i] < 315))
   {
      alongX = true;
      LenThreshDir = abs(LenThresh * sin(PI*tetadetect[i]/180)); // X distance based on the slope of the line.
      sort(ptAllX.begin(), ptAllX.end());// Sort the points from min to max.
        
   }
   else {
      alongX = false;
      LenThreshDir = abs(LenThresh * cos(PI*tetadetect[i]/180)); // X distance based on the slope of the line.
      sort(ptAllY.begin(), ptAllY.end());
   }
    
   int accum = 0; 
   int GoodStart = false;
   int indexStart;
   int len = ptAllX.size();
   int index;
   while ( accum < len)
   {
      if (alongX)
      {
         for (index = accum; index < len; index ++)
            if (ptAllX[index] > ptAllX[accum] + LenThreshDir)
            {
               index --;
               break;
            }
         //[Ind Y] = find(ptAllX > ptAllX(accum) & ptAllX <= ptAllX(accum)+LenThreshDir);
      }
      else
      {
         for (index = accum; index < len; index ++)
            if (ptAllY[index] > ptAllY[accum] + LenThreshDir)
            {
               index --;
               break;
            }
      }

      double lengthFind = index - accum;
      if  (lengthFind >= NumThresh && index != len)
      {
         if (GoodStart == false)
         {
            GoodStart = true;
            indexStart = accum;
         }
         accum = index; // the biggest one so far.
      }else{
         if (GoodStart == true)
         {
            GoodStart = false;

            if (index == len)
               accum = index - 1;
            
            // Find a segment.
            if (alongX) {
               x1 = (int)ptAllX[indexStart];
               x2 = (int)ptAllX[accum];
               map<dv_iter, dv_iter>::iterator iter;
               iter = map_xy.find(ptAllX.at(indexStart));
               y1 = (iter->second);
               y2 = (map_xy.find(ptAllX.at(accum))->second);
            } else {
               x1 = (map_yx.find(ptAllY.at(indexStart))->second);
               x2 = (map_yx.find(ptAllY.at(accum))->second);
               y1 = (int)ptAllY[indexStart];
               y2 = (int)ptAllY[accum];
            }

            // Two cases:
            // *. if the line is curve, remove the extra red line.
            // *. after removal, if the line is too short, return false.
            if (post_line_seg(orig_im, x1, y1, x2, y2))
            {
               line_set.push_back((int)x1);
               line_set.push_back((int)y1);
               line_set.push_back((int)x2);
               line_set.push_back((int)y2);
               if (im3D)  // if this is NULL, means we are only interested in the points
                  draw_line_and_clear_data(im3D, h, w, (int)x1, (int)y1,(int) x2,(int) y2, 255, 0, 0, im, WHITE);
            }
         }
         accum = accum + 1;
      }

        
   }

}
#endif

// Function: find
// find pixel with value in image
vector<int> find(BYTE *im, int len, int value)
{
   vector<int> res;
   
   for (int i = 0; i < len; i++)
   {
      if (im[i] == value)
         res.push_back(i);
   }
         
   return res;
}

// Function: find
// find pixel in the vector 
vector<int>* find(BYTE *im, vector<int> *index, int value)
{
   vector<int> *res = new vector<int>;
   
   for (int i = 0; i < index->size(); i++)
   {
      if (im[(*index)[i]] == value)
         res->push_back((*index)[i]);
   }
         
   return res;
}

// Function: get_image_from_vec_lines
//
// return a black white image
BYTE ** get_image_from_vec_lines(vector<int> &line_set, int h, int w)
{
   // draw the line set in the image using alternative color
   int len = line_set.size();

   BYTE **im = new_image(h, w);
   for (int i = 0; i < len; i+=4)
   {
      int x1 = line_set[i];
      int y1 = line_set[i+1];
      int x2 = line_set[i+2];
      int y2 = line_set[i+3];

      draw_line_on_2D_image(im, h, w, x1, y1, x2, y2);
   }

   return im;
}

// Function: write_lines_to_bw_image
//
// Write out a black white lines
void write_lines_to_bw_image(char *fn, vector<int> &line_set, int h, int w)
{
   // draw the line set in the image using alternative color
   int len = line_set.size();

   BYTE **im = new_image(h, w);
   for (int i = 0; i < len; i+=4)
   {
      int x1 = line_set[i];
      int y1 = line_set[i+1];
      int x2 = line_set[i+2];
      int y2 = line_set[i+3];

      draw_line_on_2D_image(im, h, w, x1, y1, x2, y2);
   }

   Save2File(fn, im, NULL, w, h, 0, NULL);

   // free the 2D image memory
   free_image(im);
}

// Function: write_lines_to_image
//
// Write out a colorful image
void write_lines_to_image(char *fn, vector<int> &line_set, int h, int w, vector<int> *colors_ptr)
{
   // draw the line set in the image using alternative color
   int len = line_set.size();

   // add colors to keep the color unchanged when doing refinement.
   vector<int> colors;
   if (colors_ptr != NULL)
      colors = *colors_ptr;
   if (colors.size() > 0)
      assert(len/4 == colors.size());
   
   BYTE ***im = new_3D_image(h, w);
   int color_switch = 0;
   for (int i = 0; i < len; i+=4)
   {
      if (colors.size() > 0)
         color_switch = colors[i/4];
      else
         color_switch ++;
      
      int x1 = line_set[i];
      int y1 = line_set[i+1];
      int x2 = line_set[i+2];
      int y2 = line_set[i+3];

      if (color_switch == -1)
         draw_line(im, h, w, x1, y1, x2, y2, 255, 255, 255);
      else if (color_switch % 3 == 0)
         draw_line(im, h, w, x1, y1, x2, y2, 255, 0, 0);
      else if (color_switch % 3 == 1)
         draw_line(im, h, w, x1, y1, x2, y2, 0, 255, 0);
      else
         draw_line(im, h, w, x1, y1, x2, y2, 0, 0, 255);
   }

   Save2File(fn, NULL ,NULL, w, h, 1, im);

   // free the 3D image memory
   free_image_3D(im);
}

/* Function: load_lines_from_BPA_dump
   Load lines from file and save them in the vector<int> variable
 */
void load_lines_from_BPA_dump(vector<int> &line_set, char *fn, int h, int w)
{
   char line_str[1000];
   char temp_str[100];
   FILE *fd = fopen(fn,"r");

   if ( !fd ) {
      printf("Could not open file: %s\n", fn);
      assert(0);
   }
   
   int line_no = 0;
   int x0, y0, x1, y1;
   int line_num = 0;
   bool new_start = false;
   while (fgets(line_str, 1000, fd))
   {
      line_num ++;
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      sscanf(line_str, "%s", temp_str);

      if (!strncmp(temp_str, "BEG", 3) ){
         new_start = true;
         continue;
      }

      if (!strncmp(line_str, "ImageSize", 9) ){
         assert(sscanf(line_str, "ImageSize %dx%d", &image_width, &image_height) == 2);
         h = image_height;
         w = image_width;
         continue;
      }

      if ( !strncmp(temp_str, "EXT", 3) ||
           !strncmp(temp_str, "HEI", 3)) {
         new_start = false;
         continue;
      }

      if (!strncmp(temp_str, "END", 3))
      {
         line_no = 0;
         new_start = true;
         continue;
      }

      if ( !new_start )
         continue;
      
      sscanf(line_str, "%d %d", &x1, &y1);

      if (!(x1>-1 && x1<w) || !(y1>-1 && y1<h))
      {
         printf("%s wrong line %d, image size %dx%d\n", fn, line_num, w, h);
         exit(0);
      }
      
      if (line_no > 0 )
      {
         line_set.push_back(x0);
         line_set.push_back(y0);
         line_set.push_back(x1);
         line_set.push_back(y1);
      }

      x0 = x1;
      y0 = y1;

      line_no ++;
   }
   
   fclose(fd);
   
}

/* Function: check_lines_from_BPA_dump
   Load lines from file and save them in the vector<int> variable
 */
bool check_lines_from_BPA_dump(vector<int> &line_set, char *fn, int h, int w, int threshold)
{
   char line_str[1000];
   char temp_str[100];
   int  good_result = true;
   
   FILE *fd = fopen(fn,"r");
   assert(fd);
   FILE *ofd = fopen("good_result.txt", "a+");
   assert(ofd);

   int line_no = 0;
   int x0, y0, x1, y1;
   int line_num = 0;
   int current_max_height = 0x7FFFFFFF;
   bool is_first_wrong = true;
   while (fgets(line_str, 1000, fd))
   {
      line_num ++;
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      sscanf(line_str, "%s", temp_str);

      if (!strncmp(temp_str, "BEG", 3))
         continue;
      if (!strncmp(temp_str, "END", 3))
      {
         line_no = 0;
         continue;
      }

      sscanf(line_str, "%d %d", &x1, &y1);

      if (!(x1>-1 && x1<w) || !(y1>-1 && y1<h))
      {
         printf("%s wrong line %d => [%d,%d] is not between [w=%d, h=%d]\n", fn, line_num, x1,y1,w,h);
         exit(0);
      }

      if (y1 > threshold)
      {
         if (y1 > current_max_height && abs(y1 - y0) + abs(x1 - x0) > 4)
         {
            good_result = false;
            //if (is_first_wrong)
            {
               fprintf(ofd, "%s --> %d\n", fn, line_num);
            }
         }
         else
            current_max_height = y1;
      } 
      
      if (line_no > 0 )
      {
         line_set.push_back(x0);
         line_set.push_back(y0);
         line_set.push_back(x1);
         line_set.push_back(y1);
      }

      x0 = x1;
      y0 = y1;

      line_no ++;
   }
   
   fclose(fd);
   fclose(ofd);
   return good_result;
   
}

/* Function: load_lines_from_ras2vec
   Load lines from file and save them in the vector<int> variable
 */
void load_lines_from_ras2vec(vector<int> &r2v_line_set, char *fn, int h, int w)
{
   char line_str[1000];
   char temp_str[100];
   FILE *fd = fopen(fn,"r");

   assert(fd);
   int line_no = 0;
   int x0, y0, x1, y1;
   while (fgets(line_str, 1000, fd))
   {
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      sscanf(line_str, "%s", temp_str);

      if (!strncmp(temp_str, "POLY", 4))
         continue;
      if (!strncmp(temp_str, "END", 3))
      {
         line_no = 0;
         continue;
      }

      sscanf(line_str, "%d %d", &x1, &y1);

	  x1 += 1; 
	  y1 = y1==0 ? h - 1 : h - y1;
	  assert(x1>-1 && x1<w);
	  assert(y1>-1 && y1<h);
      
      if (line_no > 0 )
      {
         r2v_line_set.push_back(x0);
         r2v_line_set.push_back(y0);
         r2v_line_set.push_back(x1);
         r2v_line_set.push_back(y1);
      }

      x0 = x1;
      y0 = y1;

      line_no ++;
   }
   
   fclose(fd);
} 


void compute_length(vector<int> & HT_line_set, vector<int> &HT_length, map<double, int> &len2loc, int thres_ = 0)
{
   int x1, y1, x2, y2;

   int len = HT_line_set.size();
   for (int i = 0; i < len; i+=4)
   {
      x1 = HT_line_set[i];
      y1 = HT_line_set[i+1];
      x2 = HT_line_set[i+2];
      y2 = HT_line_set[i+3];
      double temp = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);

      int threshold = thres_ == 0 ? GS_LINE_LEN_SQUARE : thres_;
      if (temp >= threshold)
      {
         //HT_length.push_back(temp);
         HT_length.push_back(i);

         if (thres_ == 0) // if NULL, means we don't need this.
            len2loc.insert(pair<double, int>(temp, i));
      }
   }

   // BTW, I think the HT_line_set has been sort based on MY HT algorithm!!!!
   // dont need to sort now, since we only choose those line segments whose length is larger
   // than the prefined length of squre.
   // sort the line segments from max to min
   // sort(HT_length.begin(), HT_length.end(), greater<double>());
}

typedef struct _line_group
{
   vector<int> end1;
   vector<int> end2;
   vector<int> all_data;
} LINE_GROUP;


double pts_dis(int x1, int y1, int x2, int y2)
{
   return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
}

/*
  Return Value:
     if no groups merge, return -1,
     otherwise, return the group id merged with the current one.
*/
int find_possible_group_merge(int cur, array_t * &groups)
{
   LINE_GROUP *lg = array_fetch(LINE_GROUP *, groups, cur);

   int x0_1, y0_1, x0_2, y0_2;
   x0_1 = lg->end1[0];
   y0_1 = lg->end1[1];
   x0_2 = lg->end2[0];
   y0_2 = lg->end2[1];

   // start at the cur group #, go through the later group #
   // assume there is ONLY one group around.
   for (int i = cur+1; i < groups->num; i ++)
   {
      LINE_GROUP *new_lg = array_fetch(LINE_GROUP *, groups, i);
      
      // check if there is any points close enough to the cur group points.
      // if found, check the angle? NO NEED at this point.
      double dis1 = pts_dis(x0_1, y0_1, new_lg->end1[0], new_lg->end1[1]);
      double dis2 = pts_dis(x0_2, y0_2, new_lg->end1[0], new_lg->end1[1]);
      double dis3 = pts_dis(x0_1, y0_1, new_lg->end2[0], new_lg->end2[1]);
      double dis4 = pts_dis(x0_2, y0_2, new_lg->end2[0], new_lg->end2[1]);
         
         
      if ( dis1 < GS_MERGE_DIS_SQUARE ||
           dis2 < GS_MERGE_DIS_SQUARE ||
           dis3 < GS_MERGE_DIS_SQUARE ||
           dis4 < GS_MERGE_DIS_SQUARE)
      {
         LINE_GROUP *merge_lg = new LINE_GROUP;
         // assume anti-clock wise order, assert it when it is not!
         // merge two line_group
         if (dis1 < GS_MERGE_DIS_SQUARE)
         {
            // reverse i, and end1 is i.end1
            merge_lg->end1 = new_lg->end2;
            merge_lg->end2 = lg->end2;
            for (int k = new_lg->all_data.size() - 1; k >= 0; k --)
               merge_lg->all_data.push_back(new_lg->all_data[k]);
            for (int k = 0; k < lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(lg->all_data[k]);
            
         } else if (dis4 < GS_MERGE_DIS_SQUARE)
         {
            // reverse i, and end1 is cur.end1
            merge_lg->end1 = lg->end1;
            merge_lg->end2 = new_lg->end1;
            for (int k = 0; k < lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(lg->all_data[k]);
            for (int k = new_lg->all_data.size() - 1; k >= 0; k --)
               merge_lg->all_data.push_back(new_lg->all_data[k]);

         } else if (dis2 < GS_MERGE_DIS_SQUARE)
         {
            merge_lg->end1 = lg->end1;
            merge_lg->end2 = new_lg->end2;
            for (int k = 0; k < lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(lg->all_data[k]);
            for (int k = 0; k < new_lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(new_lg->all_data[k]);

         } else if (dis3 < GS_MERGE_DIS_SQUARE)
         {
            merge_lg->end1 = new_lg->end1;
            merge_lg->end2 = lg->end2;
            for (int k = 0; k < new_lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(new_lg->all_data[k]);
            for (int k = 0; k < lg->all_data.size(); k ++)
               merge_lg->all_data.push_back(lg->all_data[k]);

         }


         // reconstruct the array of group
         array_t *new_group = array_alloc(LINE_GROUP *, 0);
         array_insert_last(LINE_GROUP *, new_group, merge_lg);

         int k;
         arrayForEachItem(LINE_GROUP *, groups, k, new_lg) {
            if (k != cur && k != i)
               array_insert_last(LINE_GROUP *, new_group, new_lg);
            else
               free(new_lg);
         }

         // free the old one
         array_free(groups);
         
         groups = new_group;

         return i;
      }
   }

   return -1;
   
}

// Function: compute_angle_between_lines
//
// Pre-condition:
//     The angle is represented as: [ (x1,y1) -> (x2,y2) ] -> [ (x3,y3) -> (x4,y4) ]
//
// Algorithm:
//     Use vector dot product to determine the Dun/Rui Jiao, then
//     Use the equation to get the angle.
// 
// Return: the angle between the two lines.
double compute_angle_between_lines(int x1, int y1,
                                   int x2, int y2,
                                   int x3, int y3,
                                   int x4, int y4,
                                   int& int_x, int& int_y)
{

   double theta = 0.0;

   // do nothing at this point
   // or return only >90 or < 90 by dot product of this two vector
   // return theta;

   
   // compute the angle and intersection of two lines.
   // based on link: http://www.tpub.com/math2/5.htm
   // basic idea is fi = a1 - a2; => tan(fi) = (m2 - m1)/(1 + m1m2);

   // compute the dot product
   int dot_product = (x2 - x1) * (x4 - x3) + (y2 - y1) * (y4 - y3);

   
   // special case - vertical line
   if ((x1 == x2) || (x3 == x4))
   {
      if (x1 != x2)
         theta = 90 - ( atan( double (y2 - y1)/(x2 - x1) )/PI * 180 );
      else if ( x3 != x4)
         theta = 90 - ( atan( double (y4 - y3)/(x4 - x3) )/PI * 180 );

      if (( dot_product < 0 && theta <= 90 ) ||
          ( dot_product >= 0 && theta > 90 ))
         theta = 180 - theta;

      return theta;
   }

   // calculate the angle:
   double m1 = double(y2 - y1)/double(x2 - x1);
   double m2 = double(y4 - y3)/double(x4 - x3);

   theta = (atan(( m1 - m2 )/( 1 + m1*m2 )))/PI * 180;
   theta = theta < 0 ? 180 + theta : theta;

   if (( dot_product < 0 && theta <= 90 ) ||
       ( dot_product >= 0 && theta > 90 ))
      theta = 180 - theta;

   return theta;
}

// Return Value:
//    if a line is found around the two end points, return 1, else 0;
int find_neighbor_lines(LINE_GROUP *lg,
                        vector<int> &line_set)
{
   assert(line_set.size() % 4 == 0);

   // go through every points in both HT and r2v.
   // if a point is found close to the any of the two points,
   // calculate the angle between the two line segments.
   // if angle is less than GS_NEIGHBOR_ANGLE, discard, else merge this one?
   int lg_x0 = lg->end1[0];
   int lg_y0 = lg->end1[1];
   int lg_x1 = lg->end2[0];
   int lg_y1 = lg->end2[1];

   // Let's assume a simple case first: - only one line is close to the end points.
   bool found = false;
   for (int i = 0; i < line_set.size(); i+=4)
   {
      int x0 = line_set[i];
      int y0 = line_set[i+1];
      int x1 = line_set[i+2];
      int y1 = line_set[i+3];

      // check four possible cases -
      // ((x0, y0), (lg_x0, lg_y0)) 
      // ((x0, y0), (lg_x1, lg_y1)) 
      // ((x1, y1), (lg_x0, lg_y0)) 
      // ((x1, y1), (lg_x1, lg_y1)) 
      if (abs(x0-lg_x0) < GS_SEARCH_MASK && abs(y0-lg_y0) < GS_SEARCH_MASK)
      {
         // check the angle?
         // add the intersection point???? - shoule check
         // whether the intersection point is between the two points.
         /*  Do NOT care the intersection point first. */
         int int_x, int_y;
         double angle = compute_angle_between_lines(lg->all_data[2], lg->all_data[3],
                                                    lg->all_data[0], lg->all_data[1],
                                                    x0, y0,
                                                    x1, y1,
                                                    int_x, int_y);
         if (angle < GS_SEARCH_ANGLE)
         {
            // re-construct lg
            // (x1, y1) -> (x0, y0) -> (lg_x0, lg_y0) -> ...
            lg->end1[0] = x1;
            lg->end1[1] = y1;
            lg->all_data.insert(lg->all_data.begin(), y0);
            lg->all_data.insert(lg->all_data.begin(), x0);
            lg->all_data.insert(lg->all_data.begin(), y1);
            lg->all_data.insert(lg->all_data.begin(), x1);

            found = true;
         }
         
      }

      if ( !found && (abs(x1-lg_x0) < GS_SEARCH_MASK && abs(y1-lg_y0) < GS_SEARCH_MASK) )
      {
         
         // check the angle
         int int_x, int_y;
         double angle = compute_angle_between_lines(lg->all_data[2], lg->all_data[3],
                                                    lg->all_data[0], lg->all_data[1],
                                                    x1, y1,
                                                    x0, y0,
                                                    int_x, int_y);
         if (angle < GS_SEARCH_ANGLE)
         {

            // (x0, y0) -> (x1, y1) -> (lg_x0, lg_y0) -> ...
            lg->end1[0] = x0;
            lg->end1[1] = y0;
            lg->all_data.insert(lg->all_data.begin(), y1);
            lg->all_data.insert(lg->all_data.begin(), x1);
            lg->all_data.insert(lg->all_data.begin(), y0);
            lg->all_data.insert(lg->all_data.begin(), x0);
         
            found = true;
         }

      }
      
      if (!found && (abs(x0-lg_x1) < GS_SEARCH_MASK && abs(y0-lg_y1) < GS_SEARCH_MASK) )
      {
         
         // check the angle
         int int_x, int_y;
         int last = lg->all_data.size();
         double angle = compute_angle_between_lines(lg->all_data[last-4], lg->all_data[last-3],
                                                    lg_x1, lg_y1,
                                                    x0, y0,
                                                    x1, y1,
                                                    int_x, int_y);
         if (angle < GS_SEARCH_ANGLE)
         {

            // (lg_x0, lg_y0) -> (x0, y0) -> (x1, y1)
            lg->end2[0] = x1;
            lg->end2[1] = y1;
            lg->all_data.push_back(x0);
            lg->all_data.push_back(y0);
            lg->all_data.push_back(x1);
            lg->all_data.push_back(y1);

            found = true;
         }
         
      }

      if (!found && (abs(x1-lg_x1) < GS_SEARCH_MASK && abs(y1-lg_y1) < GS_SEARCH_MASK))
      {
         
         // check the angle
         int int_x, int_y;
         int last = lg->all_data.size();
         double angle = compute_angle_between_lines(lg->all_data[last-4], lg->all_data[last-3],
                                                    lg_x1, lg_y1,
                                                    x1, y1,
                                                    x0, y0,
                                                    int_x, int_y);
         if (angle < GS_SEARCH_ANGLE)
         {

            // (lg_x0, lg_y0) -> (x1, y1) -> (x0, y0)
            lg->end2[0] = x0;
            lg->end2[1] = y0;
            lg->all_data.push_back(x1);
            lg->all_data.push_back(y1);
            lg->all_data.push_back(x0);
            lg->all_data.push_back(y0);

            found = true;
         }

      }

      if (found) {

         // This is wrong, we should not move i + ?, since vector will do it automatically.
         line_set.erase(line_set.begin() + i);
         line_set.erase(line_set.begin() + i + 1);
         line_set.erase(line_set.begin() + i + 2);
         line_set.erase(line_set.begin() + i + 3);
         return 1;
      }
      
   }
   
   return 0;
}

void draw_all_lines(char *fn, array_t *line_group)
{
   int k;
   LINE_GROUP *lg;

   vector<int> all_lines;
   arrayForEachItem(LINE_GROUP *, line_group, k, lg) {
      for (int i = 0; i < lg->all_data.size(); i ++)
         all_lines.push_back(lg->all_data[i]);
   }

   write_lines_to_image(fn, all_lines, image_height, image_width);
}


/* Function: compute_connection
   compute connected vertices based on HT and Ras2Vec results.

   Inpute:
      HT_line_set  -  Line segments from HT
      r2v_line_set -  Line segments from Ras2Vec
      HT_length    -  Sorted line length based on HT_line_set
      HT_map_length2loc - hash table to locate the line segment for the line length

   Output:
      poly_lines   -  Connected points for the final polygon

   Precondition:
      HT_length contains the large length of the lines
      HT_map_length2loc maps the HT_length to a location in HT_line_set
      HT_line_set and r2v_line_set contains the line segments from HT and Ras2Vec respectively.

   Postcondition:
      The connected vertice are saved in poly_lines

*/
void compute_connection(const vector<int> &HT_line_set_arg,
                        const vector<int> &r2v_line_set_arg,
                        const vector<int> &HT_length,
                        const map<double, int> &HT_map_length2loc,
                        vector<int> &poly_lines)
{

   // make a copy of HT and Rav2Vec lines, since we will remove
   // those lines out of the vector if they are used.
   vector<int> HT_line_set = vector<int>(HT_line_set_arg);
   vector<int> r2v_line_set = vector<int>(r2v_line_set_arg);
   
   // group the large line segments according to HT_length
   // create a data structure which is similiar to a wrapper
   array_t *groups = array_alloc(LINE_GROUP *, 0);
   
   for (int i = 0; i < HT_length.size(); i ++)
   {
      // get the four points correspoinding to the length;
      //int loc = (HT_map_length2loc.find(HT_length[i])->second);
      int loc = (int)HT_length[i];
      int x1 = HT_line_set_arg[loc];
      int y1 = HT_line_set_arg[loc+1];
      int x2 = HT_line_set_arg[loc+2];
      int y2 = HT_line_set_arg[loc+3];
      LINE_GROUP *lg = new LINE_GROUP;
      lg->end1.push_back(x1);
      lg->end1.push_back(y1);
      lg->end2.push_back(x2);
      lg->end2.push_back(y2);

      lg->all_data.push_back(x1);
      lg->all_data.push_back(y1);
      lg->all_data.push_back(x2);
      lg->all_data.push_back(y2);
      
      array_insert_last(LINE_GROUP *, groups , lg);

      // remove this line from HT_line_set
      // This is wrong, we should not move i + ?, since vector will do it automatically.
      HT_line_set.erase(HT_line_set.begin() + loc);
      HT_line_set.erase(HT_line_set.begin() + loc + 1);
      HT_line_set.erase(HT_line_set.begin() + loc + 2);
      HT_line_set.erase(HT_line_set.begin() + loc + 3);
   }

   // compute the connectivities
   int restart = 1;
   int loop = 0;
   while (restart)
   {
      restart = 0;
      loop ++;
      
      int len = groups->num;
      if (len == 1) break;
      
      printf("\nThere are %d groups left!!!\n", len);
      char d_fn[20];
      sprintf(d_fn, "iter%d.png", loop);
      draw_all_lines(d_fn, groups);
      
      for (int i = 0; i < len; i ++)
      {
         // check for possible merge: if two line groups are close to each other,
         // merge them into one, and restart the search process.
         int g = find_possible_group_merge(i, groups);
         if (g != -1)
         {
            printf("group %d and group %d are merged\n", i, g);
            restart = 1;
            break;
         }

         // find the neighbor line segments of HT line i by search for
         // HT_line_set and ras2vec_line_set. We search for orig_im ONLY
         // after no lines are found for all line groups.
         LINE_GROUP *lg = array_fetch(LINE_GROUP *, groups, i);
         if (find_neighbor_lines(lg, HT_line_set))
         {
            restart = 1;
         }
         else if (find_neighbor_lines(lg, r2v_line_set))
         {
            restart = 1;
         }

      }
   }
}

void replace_lines_with_HT(vector<int> &HT_line_set, char *fn, vector<int> &r2v_line_set)
{
   // 1. load the line segments from ras2vec output
   // 2. combine the information from 1, and line_set (HT), and orig_im to get the connectivities.

   char *file_name = strdup(fn);
   file_name[strlen(fn)-3] = 'p';
   file_name[strlen(fn)-2] = 'l';
   file_name[strlen(fn)-1] = 'y';
   load_lines_from_ras2vec(r2v_line_set, file_name, image_height, image_width);
   
   assert(HT_line_set.size() % 4 == 0);
   assert(r2v_line_set.size() % 4 == 0);

   
   // compute the length of the line in HT_line_set
   vector<int> HT_length;
   map<double, int> HT_map_length2loc;
   compute_length(HT_line_set, HT_length, HT_map_length2loc);

   int line_num = HT_length.size();
   if ( !line_num ) return;

   BYTE **im = new_image(image_height, image_width);
   int x1, y1, x2, y2;
   for (int i = 0 ; i < line_num; i ++ )
   {
      x1 = HT_line_set[HT_length[i]];
      y1 = HT_line_set[HT_length[i]+1];
      x2 = HT_line_set[HT_length[i]+2];
      y2 = HT_line_set[HT_length[i]+3];

      draw_line_and_clear_data(NULL, image_height, image_width,
                               (int)x1, (int)y1,(int) x2,(int) y2,
                               0, 0, 0, im,
                               BLACK);

   }

   // Save2File("ttttt.png", im, NULL, image_width, image_height, 0, NULL);
   for (int i = 0; i < r2v_line_set.size(); i+=4 )
   {
      x1 = r2v_line_set[i];
      y1 = r2v_line_set[i+1];
      x2 = r2v_line_set[i+2];
      y2 = r2v_line_set[i+3];

      
      if (im[y1][x1] == BLACK && im[y2][x2] == BLACK)
      {
         r2v_line_set.erase(r2v_line_set.begin() + i);
         r2v_line_set.erase(r2v_line_set.begin() + i);
         r2v_line_set.erase(r2v_line_set.begin() + i);
         r2v_line_set.erase(r2v_line_set.begin() + i);
         i -= 4;
      }
      
   }
   //write_lines_to_image("tt_HT_R2V_remove.png",r2v_line_set, image_height, image_width);

   // add the long HT lines into r2v_line_set for new drawing
   for (int i = 0 ; i < line_num; i ++ )
   {
      r2v_line_set.push_back(HT_line_set[HT_length[i]]);
      r2v_line_set.push_back(HT_line_set[HT_length[i]+1]);
      r2v_line_set.push_back(HT_line_set[HT_length[i]+2]);
      r2v_line_set.push_back(HT_line_set[HT_length[i]+3]);
   }

   // output the line to the image.
   // write_lines_to_image("tt_HT_R2V.png",r2v_line_set, image_height, image_width);
   
   // free the memory
   free_image(im);
}

void get_points_for_sketchup(vector<int> &HT_line_set, BYTE **orig_im, int h, int w)
{
   // 1. load the line segments from ras2vec output
   // 2. combine the information from 1, and line_set (HT), and orig_im to get the connectivities.

   vector<int> r2v_line_set;
   load_lines_from_ras2vec(r2v_line_set, "slice_082.ply", h, w);
   write_lines_to_image("line_set_R2V.png",r2v_line_set, h, w);
   write_lines_to_image("line_set_HT.png",HT_line_set, h, w);   
   assert(HT_line_set.size() % 4 == 0);
   assert(r2v_line_set.size() % 4 == 0);

   // compute the length of the line in HT_line_set
   vector<int> HT_length;
   map<double, int> HT_map_length2loc;
   compute_length(HT_line_set, HT_length, HT_map_length2loc);
   assert(HT_length.size() > 0);

   // Algorithm 1 - combine HT and Ras2Vec results for line connectivities computation.
   // start to compute the connectivities
   // 1. choose those line segments from HT_line_set whose length is larger than
   //    a predefined value, each line segment is considered as a group.
   // 2. keep track of the # of groups, merge two groups if they are connected by
   //    line_segments from a. HT_line_set, b. r2v_line_set, c. orig_im
   // 3. make sure at the end, the # of group is ONE.
   vector<int> poly_lines;
   compute_connection(HT_line_set, r2v_line_set, HT_length, HT_map_length2loc, poly_lines);
   
}

// function: hough transform
// Comments: not necessary at this point, repeated with matlab.
void hough_transform(char *file_name, vector<int>& r2v_line_set, int mode = 0)
{
   int thresh = 40;
   int end_thresh = 10;
   double factor = 1.5;
   int h, w;

#ifdef LINUX
   CImg<unsigned char> *bitmap_mimio;
#else
   Bitmap *bitmap_mimio;
#endif   

   bitmap_mimio = load_image(file_name, h, w);
   image_height = h;
   image_width  = w;
   
   BYTE** Imbinary,** orig_im;
   set_image(Imbinary,bitmap_mimio);
   orig_im = copy_image(Imbinary, h, w);   

   BYTE *** im_3D = NULL;
   set_3D_image(Imbinary, im_3D, h, w);

   // main loop
   int pdetect;
   int tetadetect;
   vector<int> temp;
   vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
   while (true)
   {
      my_HT(Imbinary, h, w, pdetect, tetadetect);
      printf("Angle:%d, Distance:%d\n", tetadetect, pdetect);
      assert(tetadetect >= 270 || tetadetect <= 180);

      // draw line on the image
      draw_line_on_data(pdetect, tetadetect, Imbinary, h, w, im_3D, orig_im, line_set);

      /* debug the HT 
      char fname[30];
      char *ds = digit_string(3, HT_counter);
      sprintf(fname, "my_HT_%s.png", ds);
      free(ds);
      Save2File(fname, Imbinary, bitmap_mimio, 0,0,0,NULL);
      */
      static int HT_counter = 0;
      HT_counter++;
      
      temp = find(*Imbinary,h*w, BLACK);

      //if (temp.size() == 0) break;
      if (temp.size() < 10 || HT_counter > 20) break;
      //else printf("image size %d, p:%d, teta:%d\n", temp.size(), pdetect, tetadetect);
      //thresh = (int) (thresh/factor);
      //if (thresh < end_thresh)
      // break;
   }

   //
   if ( mode == 0)
   {
      char de_fn[1000];
      char *fn = file_name;
      strncpy(de_fn, fn, strlen(fn) - 4);
      de_fn[strlen(fn) - 4] = 0;
      sprintf(de_fn, "%s_HT_result.png", de_fn);
      Save2File(de_fn, NULL ,bitmap_mimio, 0, 0, 1, im_3D);
      sprintf(de_fn, "%s_line.png", de_fn);
      write_lines_to_image(de_fn,line_set, image_height, image_width);
      sprintf(de_fn, "%s_remaining.png", de_fn);
      Save2File(de_fn, Imbinary, NULL, w, h, 0, NULL);
      
   }
   else if ( mode == 1)
   {
      // Combine HT and ras2vec results for polygon connectivities.
      // get_points_for_sketchup(line_set, orig_im, h, w);
      replace_lines_with_HT(line_set, file_name, r2v_line_set);
   }
   else if (mode == 2)
   {
   }

   // free resources
   delete(bitmap_mimio);
   free_image(Imbinary);
   free_image(orig_im);
   free_image_3D(im_3D);

}

// Function: write_polyline_2_image
//
// The function will load dumped text lines and convert it into image
// 
void write_polyline_2_image(char *fn)
{
   
   vector<int> r2v_line_set;
   load_lines_from_ras2vec(r2v_line_set, fn, image_height, image_width);

   char output[1000];
   strcpy(output, fn);
   int len = strlen(fn);
   output[len-4]='_';
   strcat(output,".png");
   write_lines_to_image(output,r2v_line_set, image_height, image_width);
   
}

// Function: write_BPA_lines_2_image
//
// The function will load dumped text lines and convert it into image
// 
void write_BPA_lines_2_image(char *fn)
{
   
   vector<int> all_lines;
   load_lines_from_BPA_dump(all_lines, fn, image_height, image_width);
   assert(all_lines.size() > 0);

   char output[1000];
   strcpy(output, fn);
   int len = strlen(fn);
   output[len-4]='_';
   strcat(output,".png");
   write_lines_to_image(output,all_lines, image_height, image_width);
}

// Function: load_parameter
// Initilize some global vars for project from parameter file
void load_parameter( char *fn )
{
   FILE *fd = fopen(fn, "r");
   char str_line[1000];
   char flag[1000];
   char value[100];

   if ( fd ) {
      while (fgets(str_line, 1000, fd )) {
         if (str_line[0] == '#')
            continue;
         if (sscanf(str_line, "set %s %s", flag, value) == 2 ) {
            if ( !strcmp(flag, "BPA_starting_point_sweeping_cut_off") ) {
               gbl_opts->BPA_starting_point_sweeping_cut_off = atoi(value);
               printf("setting BPA_starting_point_sweeping_cut_off %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_starting_point_boundary_diff_threshold") ) {
               gbl_opts->BPA_starting_point_boundary_diff_threshold = atoi(value);
               printf("setting BPA_starting_point_boundary_diff_threshold %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_check_turning_point_for_first_iteration") ) {
               gbl_opts->BPA_check_turning_point_for_first_iteration = atoi(value);
               printf("setting BPA_check_turning_point_for_first_iteration %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_clear_first_circle_data") ) {
               gbl_opts->BPA_clear_first_circle_data = atoi(value);
               printf("setting BPA_clear_first_circle_data %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_2nd_round_need_no_HT_process") ) {
               gbl_opts->BPA_2nd_round_need_no_HT_process = atoi(value);
               printf("setting BPA_2nd_round_need_no_HT_process %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_gap_line_length") ) {
               gbl_opts->BPA_gap_line_length = atoi(value);
               printf("setting BPA_gap_line_length %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_refine_ignore_mutli_boundaries") ) {
               gbl_opts->refine_ignore_mutli_boundaries = atoi(value);
               printf("setting BPA_refine_ignore_mutli_boundaries %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_starting_point_sweeping_dir") ) {
               gbl_opts->BPA_starting_point_sweeping_dir = atoi(value);
               printf("setting BPA_starting_point_sweeping_dir %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_refine_number") ) {
               gbl_opts->BPA_refine_number = atoi(value);
               printf("setting BPA_refine_number %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_pace_degree") ) {
               gbl_opts->pace_degree = atoi(value);
               printf("setting BPA_pace_degree %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_initial_radius") ) {
               gbl_opts->radius = atoi(value);
               printf("setting BPA_initial_radius %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_need_do_refinement") ) {
               gbl_opts->BPA_need_do_refinement = atoi(value);
               printf("setting BPA_need_do_refinement %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_minimum_refinement_radius_length") ) {
               gbl_opts->radius_min = atoi(value);
               printf("setting BPA_minimum_refinement_radius_length %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_need_do_HT_BPA_combination") ) {
               gbl_opts->BPA_need_do_HT_BPA_combination = atoi(value);
               printf("setting BPA_need_do_HT_BPA_combination %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_boundary_break_length") ) {
               gbl_opts->BPA_boundary_break_len = atoi(value);
               printf("setting BPA_boundary_break_length %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_debug_mode") ) {
               gbl_opts->BPA_debug_mode = atoi(value);
               printf("setting BPA_debug_mode %s\n", value);
            }
            else if ( !strcmp(flag, "BBM_using_bounding_box_mask") ) {
               gbl_opts->BBM_using_bounding_box_mask = atoi(value);
               printf("setting BBM_using_bounding_box_mask %s\n", value);
            }
            else if ( !strcmp(flag, "BBM_mask_folder") ) {
               gbl_opts->BBM_mask_folder = strdup(value);
               printf("setting BBM_mask_folder %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_turning_check_pool_size") ) {
               gbl_opts->BPA_turning_check_pool_size = atoi(value);
               printf("setting BPA_turning_check_pool_size %s\n", value);
            }
            else if ( !strcmp(flag, "IR_do_not_extend_the_last_key_slice_to_one") ) {
               gbl_opts->IR_do_not_extend_the_last_key_slice_to_one = atoi(value);
               printf("setting IR_do_not_extend_the_last_key_slice_to_one %s\n", value);
            }
            else if ( !strcmp(flag, "IR_do_not_extend_the_first_key_slice_to_zero") ) {
               gbl_opts->IR_do_not_extend_the_first_key_slice_to_zero = atoi(value);
               printf("setting IR_do_not_extend_the_first_key_slice_to_zero %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_dump_the_vectors") ) {
               gbl_opts->BPA_dump_the_vectors = atoi(value);
               printf("setting BPA_dump_the_vectors %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_reshape_slope_line") ) {
               gbl_opts->BPA_reshape_slope_line = atoi(value);
               printf("setting BPA_reshape_slope_line %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_starting_point_landing_len") ) {
               gbl_opts->BPA_starting_point_landing_len = atoi(value);
               printf("setting BPA_starting_point_landing_len %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_no_circle_when_replace_with_HT") ) {
               gbl_opts->BPA_no_circle_when_replace_with_HT = atoi(value);
               printf("setting BPA_no_circle_when_replace_with_HT %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_ignore_gap_line") ) {
               gbl_opts->BPA_ignore_gap_line = atoi(value);
               printf("setting BPA_ignore_gap_line %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_keep_remaining_boundary_point_after_split") ) {
               gbl_opts->BPA_keep_remaining_boundary_point_after_split = atoi(value);
               printf("setting BPA_keep_remaining_boundary_point_after_split %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_2nd_round_HT_length") ) {
               gbl_opts->BPA_2nd_round_HT_length = atoi(value);
               printf("setting BPA_2nd_round_HT_length %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_2nd_round_HT_dilation_mask") ) {
               gbl_opts->BPA_2nd_round_HT_dilation_mask = atoi(value);
               printf("setting BPA_2nd_round_HT_dilation_mask %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_turning_around_angle") ) {
               gbl_opts->BPA_turning_around_angle = atoi(value);
               printf("setting BPA_turning_around_angle %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_do_not_check_turning_around") ) {
               gbl_opts->BPA_do_not_check_turning_around = atoi(value);
               printf("setting BPA_do_not_check_turning_around %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_2nd_round_parameter_file") ) {
               gbl_opts->BPA_2nd_round_parameter_file = strdup(value);
               printf("setting BPA_2nd_round_parameter_file %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_clear_data_mask") ) {
               gbl_opts->BPA_clear_data_mask = atoi(value);
               printf("setting BPA_clear_data_mask %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_clear_data_for_new_boundary") ) {
               gbl_opts->BPA_clear_data_for_new_boundary = atoi(value);
               printf("setting BPA_clear_data_for_new_boundary %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_debug_color_boundary") ) {
               gbl_opts->BPA_debug_color_boundary = atoi(value);
               printf("setting BPA_debug_color_boundary %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_debug_image_interval") ) {
               gbl_opts->BPA_debug_image_interval = atoi(value);
               printf("setting BPA_debug_image_interval %s\n", value);
            }
            else if ( !strcmp(flag, "BPA_merge_boundary_points") ) {
               gbl_opts->BPA_merge_boundary_points = atoi(value);
               printf("setting BPA_merge_boundary_points %s\n", value);
            }
            else {
               printf("WARNING: unknown flag [%s]\n", flag);
               exit(0);
            }
         }
      }
      
   } else {
      printf(" Cannot find the parameter file - %s\n", fn);
      exit(0);
   }
}

// Function: project_init
// Initilize some global vars for project
void project_init()
{

   avlFlagTable = avl_init_table((int (*) (const char*, const char*))strcmp); 
   
   gbl_opts = (GLOBAL_OPTIONS *) malloc (sizeof(GLOBAL_OPTIONS));
   memset(gbl_opts, 0, sizeof(GLOBAL_OPTIONS));
   gbl_opts->pace_degree = 1.0;
   gbl_opts->refine_counter = -1;
   gbl_opts->half_length = 512;
   gbl_opts->refine_ignore_mutli_boundaries = 1;
   gbl_opts->BPA_clear_first_circle_data = 0;
   gbl_opts->BPA_starting_point_sweeping_cut_off = 0;  // default cutoff
   gbl_opts->BPA_starting_point_sweeping_dir = 1; // left side
   gbl_opts->BPA_refine_speed_up = 0; // original 1, but after improving arc_region(), it doesn't have much different now
   gbl_opts->BPA_ignore_gap_line = 0;
   gbl_opts->BPA_gap_line_matters = 0;
   gbl_opts->BPA_gap_line_length = BPA_AFTER_ROUGH_RADIUS;
   gbl_opts->BPA_debug_color_boundary = 1;
   gbl_opts->BPA_boundary_break_len = 16 ; // The length to break a sub circle.
   gbl_opts->BPA_merge_boundary_points = 0;
   gbl_opts->BPA_clear_data_mask = 2; // default mask 2x2;
   gbl_opts->BPA_dump_the_vectors = 1; // the default value is 1;
   gbl_opts->BPA_do_not_check_turning_around = 0;
   gbl_opts->BPA_reshape_slope_line = 1;
      
   gbl_opts->KSD_least_key_slice_interval = 3;
   gbl_opts->KSD_contains_tapered_structure = 0;
   gbl_opts->KSD_HD_diff_threshold = 5.0;
   gbl_opts->KSD_ratio = 0.2;
   gbl_opts->KSD_HD_data_percentage = 0.1;
   gbl_opts->KSD_single_key_slice = 0;  // when doing KSD, use the single slice as the output
   gbl_opts->KSD_ref_side = 1;          // default reference side of bottom or left.

#ifndef LINUX
   GdiplusStartupInput gdiplusStartupInput;
   ULONG_PTR gdiplusToken;
   GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
   GetEncoderClsid(L"image/png", &clsid);
   //GetEncoderClsid(L"image/tiff", &clsid);
#endif

   
   
   
}

/* Function: generate_dxf_from_ras2vec

   Output: a dxf file with line segments.
*/
void generate_dxf_from_ras2vec()
{
   // try to construct the dxf with output from ras2vec
   // 
   // step 1:  system() call to get result of ras2vec
   // step 2:  similiarity measure to identify key frames
   // step 3:  combine the result of HT with ras2vec
   // step 4:  generate dxf for google sketchup

   int  frame_num = 111;

   FILE *fd = copy_dxf_head("ras2vec.dxf");
   assert(fd);

   char str_pad[10];
   char file_name[1000];
   int  line_no = 20;
   float depth_bottom = -2.116044;
   float depth_top    = 43.216660;
   float depth_inter  = (depth_top - depth_bottom) / frame_num;
   float depth = depth_bottom;
   for (int i = 0 ; i < frame_num; i ++)
   {
      if (i < 10)
         strcpy(str_pad,"00"); 
      else if (i < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      sprintf(file_name, "../data/clear_slices/slice_%s%d.png", str_pad, i);

      char command[1000];
      sprintf(command, "..\\ras2vec.exe -p -o result %s  > temp", file_name);
      system(command);

      sprintf(file_name, "result/slice_%s%d.ply", str_pad, i);
      vector<int> line_set;
      load_lines_from_ras2vec(line_set, file_name, image_height, image_width);

      sprintf(file_name, "result/ras2vec_slice_%s%d.png", str_pad, i);
      write_lines_to_image(file_name, line_set, image_height,image_width);

      for (int k = 0; k < line_set.size(); k+=4)
      {
         float x1 = (line_set[k]   + 316.971701) / 15.604761;
         float y1 = (line_set[k+1] + 340.620716) / 15.604761;
         float x2 = (line_set[k+2] + 316.971701) / 15.604761;
         float y2 = (line_set[k+3] + 340.620716) / 15.604761;
         fprintf(fd, "\nLINE\n");
         fprintf(fd, "5\n%d\n8\n0\n",line_no);
         fprintf(fd, "10\n%f\n20\n%f\n30\n%f\n", x1, y1, depth);
         fprintf(fd, "11\n%f\n21\n%f\n31\n%f\n", x2, y2, depth);
         fprintf(fd, "0");
         line_no ++;
      }

      depth += depth_inter;
      printf("adding the %d frame\n", i);
   }

   fprintf(fd, "\nENDSEC\n0\nEOF\n");
   fclose(fd);
}

/* Function: generate_dxf_from_BPA_dump_bottom_up

   Output: a dxf file with line segments.
*/
void generate_dxf_from_BPA_dump_bottom_up()
{
   // try to construct the dxf with output from ras2vec
   // 
   // step 1:  system() call to get result of ras2vec
   // step 2:  similiarity measure to identify key frames
   // step 3:  combine the result of HT with ras2vec
   // step 4:  generate dxf for google sketchup

   int  samples_num = 1000;
   int  frame_num = 200;
   int  approach = 0;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:n:s:")) != EOF)
      {
         switch (c) {
            case 'a':
               approach = atoi(util_optarg);
               break;
            case 's':
               samples_num = atoi(util_optarg);
               break;
            case 'n':
               frame_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }
               
   FILE *fd = copy_dxf_head("BPA.dxf");
   assert(fd);

   char str_pad[10];
   char file_name[1000];
   int  line_no = 20;
   float depth_bottom = -2.116044;
   float depth_top    = 43.216660;
   float depth_inter  = (depth_top - depth_bottom) / frame_num;
   float depth = depth_bottom;
   int slice_num = 0;
   for (int i = 0 ; i < frame_num; i ++)
   {
      slice_num = (int)(i * ((float)samples_num /(float) frame_num));
      while (slice_num < samples_num)
      {
         char *ds = digit_string(3, slice_num);
         //sprintf(file_name, "result/slices_1000_0.0_44.0_result/bbb_image_slice_0%s_dumped_%d.txt", ds, approach);
         sprintf(file_name, "result/point_cloud_images/slices_taper_structure/aaa_slice_taper_%s_dumped_%d.txt", ds, approach);
         if (file_exist(file_name))
            break;
         free(ds);
         slice_num ++;
      }

      if (slice_num == samples_num)
         break;
      
      vector<int> line_set;
      load_lines_from_BPA_dump(line_set, file_name, 392, 1024);

      printf("Processing slice file: %s\n", file_name);
      for (int k = 0; k < line_set.size(); k+=4)
      {
         float x1 = (line_set[k]   + 316.971701) / 15.604761;
         float y1 = (line_set[k+1] + 340.620716) / 15.604761;
         float x2 = (line_set[k+2] + 316.971701) / 15.604761;
         float y2 = (line_set[k+3] + 340.620716) / 15.604761;
         fprintf(fd, "\nLINE\n");
         fprintf(fd, "5\n%d\n8\n0\n",line_no);
         fprintf(fd, "10\n%f\n20\n%f\n30\n%f\n", x1, y1, depth);
         fprintf(fd, "11\n%f\n21\n%f\n31\n%f\n", x2, y2, depth);
         fprintf(fd, "0");
         line_no ++;
      }

      depth += depth_inter;
   }

   fprintf(fd, "\nENDSEC\n0\nEOF\n");
   fclose(fd);
}

/* Function: generate_dxf_from_BPA_dump_left_right

   Output: a dxf file with line segments.
*/
void generate_dxf_from_BPA_dump_left_right()
{
   // try to construct the dxf with output from ras2vec
   // 
   // step 1:  system() call to get result of ras2vec
   // step 2:  similiarity measure to identify key frames
   // step 3:  combine the result of HT with ras2vec
   // step 4:  generate dxf for google sketchup

   int  samples_num = 1000;
   int  frame_num = 200;
   int  approach = 0;

   image_height = 1024;
   image_width  = 600;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:n:s:")) != EOF)
      {
         switch (c) {
            case 'a':
               approach = atoi(util_optarg);
               break;
            case 's':
               samples_num = atoi(util_optarg);
               break;
            case 'n':
               frame_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }
               
   FILE *fd = copy_dxf_head("BPA.dxf");
   assert(fd);

   char str_pad[10];
   char file_name[1000];
   int  line_no = 20;
   float depth_left  = 20.0;
   float depth_right = 90.0;
   float depth_inter  = (depth_right - depth_left) / frame_num;
   float depth = depth_left;
   int slice_num = 0;
   for (int i = 0 ; i < frame_num; i ++)
   {
      slice_num = (int)(i * ((float)samples_num /(float) frame_num));
      while (slice_num < samples_num)
      {
         char *ds = digit_string(3, slice_num);
         sprintf(file_name, "result/point_cloud_images/slices_left_right_600_1024_result/bbb_image_slice_0%s_dumped_%d.txt", ds, approach);
         if (file_exist(file_name))
            break;
         free(ds);
         slice_num ++;
      }

      if (slice_num == samples_num)
         break;
      
      vector<int> line_set;
      load_lines_from_BPA_dump(line_set, file_name, image_height, image_width);

      printf("Processing slice file: %s\n", file_name);

      // here, for left-right model, X is the same for a slices, the only change is Y and Z
      // Also, in slice coordinates, X -> Z, Y -> Y;
      // the number are computed based on the function: <get_3D_coordinate_from_2D_pixel_value>
      // MIN - MAX ==> [20,90;0,44;20,50]  ===> diff_z = 30
      // z_3D = 20 + (xxx/600)*30; = 20 + xxx / 20;
      // y_3D = 0 + (1024 - 41.5 - xxx)/(600/30) = (982.5 - xxx) / 20;
      for (int k = 0; k < line_set.size(); k+=4)
      {
         float z1 = 20.0 + (float)(image_width - line_set[k]) / 20.0;
         float y1 = (982.5 - (float)line_set[k+1]) / 20.0;
         float z2 = 20.0 + (float)(image_width - line_set[k+2]) / 20.0;
         float y2 = (982.5 - (float)line_set[k+3]) / 20.0;
         fprintf(fd, "\nLINE\n");
         fprintf(fd, "5\n%d\n8\n0\n",line_no);
         fprintf(fd, "10\n%f\n20\n%f\n30\n%f\n", depth, z1, y1);
         fprintf(fd, "11\n%f\n21\n%f\n31\n%f\n", depth, z2, y2);
         fprintf(fd, "0");
         line_no ++;
      }

      depth += depth_inter;
   }

   fprintf(fd, "\nENDSEC\n0\nEOF\n");
   fclose(fd);
}

/* Function: generate_dxf_from_BPA_dump

   Output: a dxf file with line segments.
   Command options - project.exe -R <int> -O "-a <approach> -n <total_slices>"
*/
void generate_dxf_from_BPA_dump(int DIR)
{
   // DIR -
   // 1: regular bottom-up DXF file
   // 2: left-right model
   // 3: todo - face-in model?
   switch (DIR) {
      case 1:
         generate_dxf_from_BPA_dump_bottom_up();
         break;
      case 2:
         generate_dxf_from_BPA_dump_left_right();
         break;
      default:
         printf("ERROR: No idea about this direction: %d\n", DIR);
         exit(0);
   }
         
}


/* Function : image_dilation

   Comments: we only consider the cropped image in rectangel [1, 1, width-2, height-2];
   The kernel is a 3x3 matrix, look like:
   1 1 1
   1 x 1
   1 1 1
   
 */
void image_dilation(BYTE ** &im)
{
   BYTE **tmp_im;

   copy_image(im, tmp_im, image_height, image_width);

   for (int y = 1; y < image_height - 1; y ++)
      for (int x = 1; x < image_width - 1; x ++)
      {
         tmp_im[y][x] = WHITE;
         
         if (im[y-1][x-1] == BLACK || im[y-1][x] == BLACK || im[y-1][x+1] == BLACK ||
             im[y  ][x-1] == BLACK || im[y  ][x] == BLACK || im[y  ][x+1] == BLACK ||
             im[y+1][x-1] == BLACK || im[y+1][x] == BLACK || im[y+1][x+1] == BLACK)
            tmp_im[y][x] = BLACK;
      }

   free_image(im);
   im = tmp_im;
   
}

/* Function : image_erosion

   Comments: we only consider the cropped image in rectangel [1, 1, width-2, height-2];
   The kernel is a 3x3 matrix, look like:
   1 1 1
   1 x 1
   1 1 1
   
 */
void image_erosion(BYTE **&im)
{
   BYTE **tmp_im;

   copy_image(im, tmp_im, image_height, image_width);

   for (int y = 1; y < image_height - 1; y ++)
      for (int x = 1; x < image_width - 1; x ++)
      {
         tmp_im[y][x] = WHITE;
         
         if (im[y-1][x-1] == BLACK && im[y-1][x] == BLACK && im[y-1][x+1] == BLACK &&
             im[y  ][x-1] == BLACK && im[y  ][x] == BLACK && im[y  ][x+1] == BLACK &&
             im[y+1][x-1] == BLACK && im[y+1][x] == BLACK && im[y+1][x+1] == BLACK)
            tmp_im[y][x] = BLACK;
      }

   free_image(im);
   im = tmp_im;
   
}

// Function: pp_for_sketchup
// Post process for sketchup
void pp_for_sketchup(BYTE ** &im, char *str_pad, int k)
{

   // post-procesing for the integrated image
   // step 1: closing on the boundary images.
   // step 2(optional): boundary extraction.

   // Closing on the data: dilation followed by erosion
   image_dilation(im);
   image_erosion(im);

   char file_name[1000];
   sprintf(file_name, "result\\step2_1_pp_boundary_%s%d.png", str_pad, k);
   Save2File(file_name, im, NULL, image_width, image_height, 0, NULL);
   
   // Computing the boundary extraction.
   BYTE **bound_im = boundary_detect(im, image_height, image_width);
   
   free_image(im);
   
   im = bound_im;
}

// Function: HD_similarity_measure
// Similarity measurement using HD
void HD_similarity_measure(vector<int> &key_frame, const char *format, int frame_num)
{
   FILE *comp_res = fopen("result/comp_result.txt", "w");
   FILE *vect_res = fopen("result/vect_result.txt", "w");
   assert(comp_res);
   assert(vect_res);
   
   fprintf(comp_res, "image index | HD | REV. HD");

   int START=0; 
   int k = START;
   int NUM = START+frame_num;
   char str_pad[6];
   char str[100];
   int  start_ref = 0;
   BYTE **cur_im, **ref_im, **int_im, **pre_im;
   int change_ref = 0;
   char file_name[256];
   char result_name[256];
   int w, h;
   
#ifndef LINUX
   Bitmap* bitmap_mimio = NULL;
#else
   CImg<BYTE> *bitmap_mimio = NULL;
#endif

   while (true)
   {
      printf("processing slice %d ...\n", k);
      if (k < 10)
         strcpy(str_pad,"00"); 
      else if (k < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      sprintf(file_name, format, str_pad, k);
      sprintf(result_name, "result/step1_integrated_image_%s%d.png", str_pad, k);
      sprintf(str, "\n%s", file_name);
      fprintf(comp_res, str);

      // free bitmap in every iteration.
      if (bitmap_mimio)
         delete bitmap_mimio;
      
      bitmap_mimio = load_image(file_name, h, w);
      set_image(cur_im,bitmap_mimio);
      
      if (k == START) {
         ref_im = cur_im;
         int_im = copy_image(cur_im, h, w);
         k++;
         continue;
      }
      else
      {
         int len = h*w;
         for (int i = 0; i < len; i++)
            int_im[0][i] |= cur_im[0][i];
      }

      // compute the Hausdorff distance between the images
      vector<int> *v1 = compute_Hausdorff(ref_im, cur_im, h, w);
      vector<int> *v2 = compute_Hausdorff(cur_im, ref_im, h, w);

      sort(v1->begin(), v1->end(), greater<int>());
      sort(v2->begin(), v2->end(), greater<int>());      

      // for testing - compare the hausdorff distance - better use emacs.
      //for (int i = 0; i < v1->size(); i ++)
      // fprintf(comp_res, "%3d",  (*v1)[i]);

      // based on observation, 10% is the best ratio for comparison.
      // compute the average value for the 10% biggest distance.
      // e.g., use 83 as reference image, the average value until 92 is 1.2-1.5,
      // starting from 93, it is 5.x - 6.x.. If use 93 as reference, the average
      // value until 115 around 3.x. so use the middle vale 4-4.5 as the threshold.
      const float HD_THRESH = 4.0;

      double average_dis  = average_HD(v1, 0.1);
      double average_dis2 = average_HD(v2, 0.1);

      // free v1 and v2
      // make sure NEW <=> DELETE && MALLOC <=> FREE pair
      delete v1;
      delete v2;

      //printf("The average distance of biggest 0.1 is %4f\n", average_dis);
      //printf("The reverse average distance of biggest 0.1 is %4f\n", average_dis2);
      fprintf(comp_res, " %4f", average_dis);
      fprintf(comp_res, " %4f", average_dis2);

      //average_dis = (average_dis + average_dis2)/2;
      average_dis = max(average_dis, average_dis2);
      fprintf(comp_res, " %4f", average_dis);

      if (average_dis > HD_THRESH )
      {
         free_image(ref_im);
         ref_im = cur_im;
         printf("\nChange the reference image to current image %d\n", k);
         fprintf(comp_res, "\nChange the reference image to current image %d\n", k);

         Save2File(result_name, int_im , NULL, w, h, 0, NULL);
         key_frame.push_back(k);
         fprintf(vect_res, "%d\n", k);

         // post-process the integrated images
         pp_for_sketchup(int_im, str_pad, k);
         
         // save the post-process image for ras2vec
         sprintf(result_name, "result\\step2_2_pp_boundary_%s%d.png", str_pad, k);
         Save2File(result_name, int_im, NULL, image_width, image_height, 0, NULL);

         char command[1000];
         sprintf(command, "..\\ras2vec.exe -p -o result %s > temp", result_name);
         system(command);

      
         free_image(int_im);
         int_im = copy_image(cur_im, h, w);

      }
      else      // free current image, no use anymore
         free_image(cur_im);

      k++;
      if (k > NUM) break;

   }

   // the last one.
   if (key_frame.back() < NUM)
   {
      Save2File(result_name, int_im , NULL, w, h, 0, NULL);
      key_frame.push_back(NUM);
      fprintf(vect_res, "%d\n", NUM);

      // post-process the integrated images
      pp_for_sketchup(int_im, str_pad, NUM);
         
      // save the post-process image for ras2vec
      sprintf(result_name, "result\\step2_2_pp_boundary_%s%d.png", str_pad, NUM);
      Save2File(result_name, int_im, NULL, image_width, image_height, 0, NULL);

      char command[1000];
      sprintf(command, "..\\ras2vec.exe -p -o result %s > temp", result_name);
      system(command);

   }

   // free int_im anyway
   free_image(int_im);

   // free  bitmap in every iteration.
   if (bitmap_mimio)
      delete bitmap_mimio;
   
   fclose(comp_res);
   fclose(vect_res);
   
}

void load_data_2_vector(char *fn, vector<int> &key_frame)
{
   FILE *fd = fopen(fn, "r");
   assert(fd);

   int id;
   
   while (fscanf(fd, "%d\n", &id) != EOF)
      key_frame.push_back(id);

   fclose(fd);
          
}

/* Function: generate_dxf_for_sketchup

   Output: a dxf file with line segments.
*/
void generate_dxf_for_sketchup()
{
   // try to construct the dxf with output from ras2vec
   // 
   // step 1:  system() call to get result of ras2vec
   // step 2:  similiarity measure to identify key frames
   // step 3:  combine the result of HT with ras2vec
   // step 4:  generate dxf for google sketchup

   // check whether result folder is existed.
   // check_integrality();
   
   int  frame_num = 311;
   char format[1000] = "../data/new-slices/slice_1024_%s%d.png";

   if (output_fn)
   {
      if (sscanf(output_fn, "%s %d", format, &frame_num) != 2)
         assert(0);
      
      sprintf(format, "%s%%s%%d.png", format);
   }
   
   // int  frame_num = 110;
   // const char *format = "../data/clear_slices/slice_%s%d.png";
   // step 2:
   // compute the similarity of the images based on Hausdorff distance.
   vector<int> key_frame_id;

   // real time computation
   if (!fopen("result/vect_result.txt", "r"))
   {
      HD_similarity_measure(key_frame_id, format, frame_num);
      assert(key_frame_id.size() > 0);
      
   }
   else {
      // load from historical data
      load_data_2_vector("result/vect_result.txt", key_frame_id);
   }
   

   // saperate the LINUX from WINDOWS - no ras2vec.exe on LINUX
   // return;
   
   // step 4:
   FILE *fd = copy_dxf_head("sketchup.dxf");
   assert(fd);

   char str_pad[10];
   char file_name[1000];
   int  line_no = 20;
   float depth_bottom = -2.116044;
   float depth_top    = 43.216660;
   float depth_inter  = (depth_top - depth_bottom) / frame_num;
   float depth = depth_bottom;

   int i, pre_loc = 0;
   for (int iter = 0; iter < key_frame_id.size(); iter++)
   {
      i = key_frame_id[iter];
      
      if (i < 10)
         strcpy(str_pad,"00"); 
      else if (i < 100)
         strcpy(str_pad,"0");
      else strcpy(str_pad, "");

      // load image and post-process for further integration
      sprintf(file_name, "result/step2_2_pp_boundary_%s%d.png", str_pad, i);
      // HT followed by Combination
      vector<int> line_set;
      hough_transform(file_name, line_set, 1);

      
      sprintf(file_name, "result/step3_HT_Ras2Vec_%s%d.png", str_pad, i);
      write_lines_to_image(file_name, line_set, image_height,image_width);
      
      while (pre_loc <= i)
      {
         for (int k = 0; k < line_set.size(); k+=4)
         {
            float x1 = (line_set[k]   + 316.971701) / 15.604761;
            float y1 = (line_set[k+1] + 340.620716) / 15.604761;
            float x2 = (line_set[k+2] + 316.971701) / 15.604761;
            float y2 = (line_set[k+3] + 340.620716) / 15.604761;
            
            // reflect the building along y axis.
            //y1 = image_height - y1;
            //y2 = image_height - y2;
            fprintf(fd, "\nLINE\n");
            fprintf(fd, "5\n%d\n8\n0\n62\n\5\n",line_no);
            fprintf(fd, "10\n%f\n20\n%f\n30\n%f\n", x1, y1, depth);
            fprintf(fd, "11\n%f\n21\n%f\n31\n%f\n", x2, y2, depth);
            fprintf(fd, "0");
            line_no ++;
         }

         depth += depth_inter;
         printf("adding the %d frame\n", pre_loc);

         pre_loc ++;
      }
      
   }

   fprintf(fd, "\nENDSEC\n0\nEOF\n");
   fclose(fd);
}

// Function: valid_pixel
// Helper function for validing the pixel
inline bool valid_pixel(int x, int y)
{
   if (x > -1 && y > -1 &&
       x < image_width && y < image_height)
      return true;
   
   return false;
}

// Function: angle_arc
//
// here we need to consider 4 parameters:
// 1. m     - slope -> m > 0 or m < 0 or m = 0
// 2. sign  - above line or below line -> sign > 0 or sign < 0 or sign = 0
// 3. dir   - pivot clock wise or anti-clock wise -> dir = -1 or dir = 1
// 4. arrow - (P0P1) point to left or right -> x0 > x1 or x0 < x1
// direction == -1, means clock-wise, 1 - anti-clock wise.
double angle_arc(double x1, double y1, double x0, double y0, double x2, double y2, int dir)
{

   // here caculate y = mx + c, a, b is parameters
   double m = 0.0;
   double c = 0.0;
   if (abs(x0 - x1) > FLOAT_SIGMA)
   {
      m = (double)(y1 - y0)/(double)(x1 - x0);
      c = y0 - m*x0;
   }

   // refer to http://en.wikipedia.org/wiki/Law_of_cosines
   // equation : r = arcos(a^2+b^2-c^2/2ab)

   double a_power = (x1-x0)*(x1-x0) + (y1-y0)*(y1-y0);
   double b_power = (x2-x0)*(x2-x0) + (y2-y0)*(y2-y0);
   double c_power = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);

   if (b_power == 0 || c_power == 0)
      return 0.0;
   
   double a = sqrt(a_power);
   double b = sqrt(b_power);

   // here we need the same treatment as in label TREAT_ARCOS.
   // bug fixed here.
   double tmp1 = a_power + b_power - c_power;
   double tmp2 = 2*a*b;

   assert(abs(tmp1) < abs(tmp2) + 2); // sometime abs(tmp1) / abs(tmp2) > 1 ;
   assert(tmp2 != 0);

   tmp1 = abs(tmp1) <= abs(tmp2) ? tmp1 : tmp1 > 0 ? tmp2 : -tmp2; // in case there is some round off error.

   double result = 180.0*acos(tmp1/tmp2)/PI;

   double sign = 0.0;

   // here test the clock-wise angle
   // if y - mx - c > 0, means counter clock-wise.
   // acos is between [0, PI];
   if (abs(x1 - x0) > FLOAT_SIGMA)
      sign = y2 - m*x2 -c;
   else
      sign = x0 - x2;

   // here we need to consider 4 parameters:
   // 1. m     - slope -> m > 0 or m < 0 or m = 0
   // 2. sign  - above line or below line -> sign > 0 or sign < 0 or sign = 0
   // 3. dir   - pivot clock wise or anti-clock wise -> dir = -1 or dir = 1
   // 4. arrow - (P0P1) point to left or right -> x0 > x1 or x0 < x1
   // direction == -1, means clock-wise, 1 - anti-clock wise.
   /*
   if ( (m > 0 && sign * dir < 0 ) || // && (x0 < x2)) || 
        (m < 0 && sign * dir > 0 ) || // && (x0 > x2)) ||
        (x0 == x1 && y1 < y0 && sign * dir < 0) ||
        (x0 == x1 && y1 > y0 && sign * dir > 0) ) // if verticle line, fix a bug
      result = 360 - result;
   */

   // BUGGGG!!!!: for y, the high, the smaller, exactly reverse to normal reference coordinate
   // in image, the starting point is up-left corner, instead of bottom left as usual.
   if ( (x1 > x0 && sign * dir > 0) ||
        (x1 < x0 && sign * dir < 0) ||
        (x0 == x1 && y1 < y0 && sign * dir < 0) ||
        (x0 == x1 && y1 > y0 && sign * dir > 0) )
      result = 360.0 - result;

   return result;
}

/* Function arc_region
   This function is a helper for <ball_pivoting>

  (x0, y0) is the center, and (x1, y1) is the end point
  arc is the clock-wise angle.
*/
vector<int> *arc_region(double x0, double y0, double x1, double y1, double arc, int rad, int dir, BYTE **im = NULL)
{
   // CAUTION: it will be much fast if arc is 360. Since angle_arc() is bypassed for 360.
   vector<int> *result = new vector<int>;

   int rad_power = rad*rad;
   for (int y = (int)(y0 - rad + .5); y < y0 + rad; y++)
      for (int x = (int)(x0 - rad + .5); x < x0 + rad; x++)
      {
         // if this point is WHITE, just ignore it.
         if (im != NULL && valid_pixel(x,y) && im[y][x] == WHITE)
            continue;
         
         if (!valid_pixel(x, y))
            continue;

         if (rad_power < (x-x0)*(x-x0) + (y-y0)*(y-y0))
            continue;

         if (arc < 360 && angle_arc(x1,y1,x0,y0,x,y,dir) > arc)
            continue;

         result->push_back(index(x, y));
      }
   
   return result;
}

void get_the_starting_point_from_left(BYTE **cur_im, BYTE **boundary_im, deque<int> &points, int rad, int &p1)
{
   // a thresh hold here
   int BOUNDARY_DIFF = gbl_opts->BPA_starting_point_boundary_diff_threshold == 0 ? 1 : gbl_opts->BPA_starting_point_boundary_diff_threshold;
   int land_thresh = gbl_opts->BPA_starting_point_landing_len == 0 ? 5 : gbl_opts->BPA_starting_point_landing_len;
   int h = image_height;
   int w = image_width;

   // sweep left to right
   int *a = new int[h];
   memset(a, 0, h*4);
   int min_x = w;
   int min_x_y = -1;
   for (int y = h-1; y > 0; y --)
   {
      int mid_pos = w / 2;
      if (gbl_opts->BPA_starting_point_sweeping_cut_off)
         mid_pos = gbl_opts->BPA_starting_point_sweeping_cut_off;
            
      if ( gbl_opts->BPA_simple_starting_point )
         mid_pos = w;
      
      if ( mid_pos > 2 )
         mid_pos = w;

      for (int x = 0; x < mid_pos; x++)
      {
         if (boundary_im[y][x] == BLACK)
            break;
         
         if (cur_im[y][x] == BLACK)
         {
            a[y] = x;

            if ( x < min_x ) {
               min_x = x;
               min_x_y = y;
            }
               
            break;
         }
      }
   }

   if ( gbl_opts->BPA_simple_starting_point ) {

      if (min_x_y != -1 ) {
         points.push_back(index(min_x, min_x_y));
         p1 = index(min_x - 2*rad, min_x_y);
      }
      
      delete [] a;
      return;
   }
       
   for (int i = h-land_thresh ; i > land_thresh; i --)
   {
      if (!a[i]) continue;
      
      int sum = 0, counter = 0;
      for (int j = -land_thresh; j <land_thresh ; j ++)
         if (a[i+j] != 0)
         {
            counter ++;
            sum += abs(a[i+j]-a[i]);
         }
      
      if (counter > land_thresh &&
          sum/(double)counter < BOUNDARY_DIFF)
      {

         // here we should test whether the circle contains no other data or not.
         //vector<int> *ar = arc_region(i, a[i]+rad, i, a[i], 360,rad, -1); // -1 is clock-wise
         vector<int> *ar = arc_region(a[i]-rad, i, a[i], i, 360, rad, -1); // -1 is clock-wise
         vector<int> *data = find(cur_im[0], ar, BLACK);

         if (gbl_opts->BPA_clear_first_circle_data) {
            for (int i = 0; i < ar->size(); i ++)
               if (cur_im[0][(*ar)[i]] == BLACK)
                  cur_im[0][(*ar)[i]] = WHITE;
            data->clear(); // make sure data->size() <= 1
         }

         delete ar;
         if (data->size() <= 1)
         {
            points.push_back(index(a[i], i));
            //p1 = index(i, a[i] + 2*rad);
            p1 = index(a[i] - 2*rad, i);
            my_printf("The starting point is from left at: [%d, %d]\n", a[i], i);
			delete [] a;

            delete data;
            return;
         } else {
            counter = 0;
         }

         delete data;
      }
         
   }

   delete [] a;
   
   // end of remove
   
   
}

void get_the_starting_point_from_right(BYTE **cur_im, BYTE **boundary_im, deque<int> &points, int rad, int &p1)
{
   // a thresh hold here
   int BOUNDARY_DIFF = gbl_opts->BPA_starting_point_boundary_diff_threshold == 0 ? 1 : gbl_opts->BPA_starting_point_boundary_diff_threshold;
   int land_thresh = gbl_opts->BPA_starting_point_landing_len == 0 ? 5 : gbl_opts->BPA_starting_point_landing_len;
   int h = image_height;
   int w = image_width;

   // sweep right to left
   int *a = new int[h];
   memset(a, 0, h*4);
   int min_x = -1;
   int min_x_y = -1;
   for (int y = h-1; y > 0; y --)
   {
      int mid_pos = w / 2;
      if (gbl_opts->BPA_starting_point_sweeping_cut_off)
         mid_pos = gbl_opts->BPA_starting_point_sweeping_cut_off;
            
      if ( gbl_opts->BPA_simple_starting_point )
         mid_pos = 0;
      
      for (int x = w-1; x > mid_pos; x--)
      {
         if (boundary_im[y][x] == BLACK)
            break;
         
         if (cur_im[y][x] == BLACK)
         {
            a[y] = x;

            if ( x > min_x ) {
               min_x = x;
               min_x_y = y;
            }
               
            break;
         }
      }
   }

   if ( gbl_opts->BPA_simple_starting_point ) {

      if (min_x_y != -1 ) {
         points.push_back(index(min_x, min_x_y));
         p1 = index(min_x + 2*rad, min_x_y);
      }
      
      delete [] a;
      return;
   }
       
   for (int i = h-land_thresh ; i > land_thresh; i --)
   {
      if (!a[i]) continue;
      
      int sum = 0, counter = 0;
      for (int j = -land_thresh; j < land_thresh; j ++)
         if (a[i+j] != 0)
         {
            counter ++;
            sum += abs(a[i+j]-a[i]);
         }
      
      if (counter > land_thresh &&
          sum/(double)counter < BOUNDARY_DIFF)
      {

         // here we should test whether the circle contains no other data or not.
         //vector<int> *ar = arc_region(i, a[i]+rad, i, a[i], 360,rad, -1); // -1 is clock-wise
         vector<int> *ar = arc_region(a[i]+rad, i, a[i], i, 360, rad, -1); // -1 is clock-wise
         vector<int> *data = find(cur_im[0], ar, BLACK);

         if (gbl_opts->BPA_clear_first_circle_data) {
            for (int i = 0; i < ar->size(); i ++)
               if (cur_im[0][(*ar)[i]] == BLACK)
                  cur_im[0][(*ar)[i]] = WHITE;
            data->clear(); // make sure data->size() <= 1
         }

         delete ar;
         if (data->size() <= 1)
         {
            points.push_back(index(a[i], i));
            //p1 = index(i, a[i] + 2*rad);
            p1 = index(a[i] + 2*rad, i);
            my_printf("The starting point is from right at: [%d, %d]\n", a[i], i);
			delete [] a;

            delete data;
            return;
         } else {
            counter = 0;
         }

         delete data;
      }
         
   }

   delete [] a;
   
   // end of remove
   
   
}

void get_the_starting_point_from_top(BYTE **cur_im, BYTE **boundary_im, deque<int> &points, int rad, int &p1)
{
   // a thresh hold here
   int BOUNDARY_DIFF = gbl_opts->BPA_starting_point_boundary_diff_threshold == 0 ? 1 : gbl_opts->BPA_starting_point_boundary_diff_threshold;
   int land_thresh = gbl_opts->BPA_starting_point_landing_len == 0 ? 5 : gbl_opts->BPA_starting_point_landing_len;
   int h = image_height;
   int w = image_width;
   
   // sweep from top to bottom
   int *a = new int[w];
   memset(a, 0, w*4);
   int min_y = h;
   int min_y_x = -1;
   for (int x = 0; x < w; x ++)
   {
      int mid_pos = h / 2;
      if (gbl_opts->BPA_starting_point_sweeping_cut_off)
         mid_pos = gbl_opts->BPA_starting_point_sweeping_cut_off;

      if ( gbl_opts->BPA_simple_starting_point )
         mid_pos = h;

      if ( mid_pos > h )
         mid_pos = h;
      
      for (int y = 0; y < mid_pos; y++)
      {
         if (boundary_im[y][x] == BLACK)
            break;
         
         if (cur_im[y][x] == BLACK)
         {
            a[x] = y;

            if ( y < min_y ) {
               min_y = y;
               min_y_x = x;
            }
               
            break;
         }
      }
   }

   if ( gbl_opts->BPA_simple_starting_point ) {

      if (min_y_x != -1 ) {
         points.push_back(index(min_y_x, min_y));
         p1 = index(min_y_x, min_y - 2*rad);
      }
      
      delete [] a;
      return;
   }
       
   for (int i = land_thresh ; i < w-land_thresh; i ++)
   {
      if (!a[i]) continue;
      
      int sum = 0, counter = 0;
      for (int j = -land_thresh; j < land_thresh; j ++)
         if (a[i+j] != 0)
         {
            counter ++;
            sum += abs(a[i+j]-a[i]);
         }
      
      if (counter > land_thresh &&
          sum/(double)counter < BOUNDARY_DIFF)
      {

         // here we should test whether the circle contains no other data or not.
         vector<int> *ar = arc_region(i, a[i]-rad, i, a[i], 360,rad, -1); // -1 is clock-wise
         vector<int> *data = find(cur_im[0], ar, BLACK);

         if (gbl_opts->BPA_clear_first_circle_data) {
            for (int i = 0; i < ar->size(); i ++)
               if (cur_im[0][(*ar)[i]] == BLACK)
                  cur_im[0][(*ar)[i]] = WHITE;
            data->clear(); // make sure data->size() <= 1
         }
         
         delete ar;
         if (data->size() <= 1)
         {
            points.push_back(index(i, a[i]));
            p1 = index(i, a[i] - 2*rad);
            my_printf("The starting point is from top at: [%d, %d]\n", i, a[i]);
			delete [] a;

            delete data;
            return;
         } else {
            counter = 0;
         }

         delete data;
      }
         
   }

   delete [] a;

}

void get_the_starting_point_from_bottom(BYTE **cur_im, BYTE **boundary_im, deque<int> &points, int rad, int &p1)
{
   // a thresh hold here
   int BOUNDARY_DIFF = gbl_opts->BPA_starting_point_boundary_diff_threshold == 0 ? 1 : gbl_opts->BPA_starting_point_boundary_diff_threshold;
   int land_thresh = gbl_opts->BPA_starting_point_landing_len == 0 ? 5 : gbl_opts->BPA_starting_point_landing_len;
   int h = image_height;
   int w = image_width;

   // sweep from bottom up
   int *a = new int[w];
   memset(a, 0, w*4);
   int min_y = -1;
   int min_y_x = -1;
   for (int x = 0; x < w; x ++)
   {
      int mid_pos = h / 2;
      if (gbl_opts->BPA_starting_point_sweeping_cut_off)
         mid_pos = gbl_opts->BPA_starting_point_sweeping_cut_off;
            
      if ( gbl_opts->BPA_simple_starting_point )
         mid_pos = 0;

      for (int y = h-1; y > mid_pos; y--)
      {
         if (boundary_im[y][x] == BLACK)
            break;
         
         if (cur_im[y][x] == BLACK)
         {
            a[x] = y;

            if ( y > min_y ) {
               min_y = y;
               min_y_x = x;
            }
               
            break;
         }
      }
   }

   if ( gbl_opts->BPA_simple_starting_point ) {

      if (min_y_x != -1 ) {
         points.push_back(index(min_y_x, min_y));
         p1 = index(min_y_x, min_y + 2*rad);
      }
      
      delete [] a;
      return;
   }
       
   for (int i = land_thresh ; i < w-land_thresh; i ++)
   {
      if (!a[i]) continue;
      
      int sum = 0, counter = 0;
      for (int j = -land_thresh; j < land_thresh; j ++)
         if (a[i+j] != 0)
         {
            counter ++;
            sum += abs(a[i+j]-a[i]);
         }
      
      if (counter > land_thresh &&
          sum/(double)counter < BOUNDARY_DIFF)
      {

         // here we should test whether the circle contains no other data or not.
         vector<int> *ar = arc_region(i, a[i]+rad, i, a[i], 360,rad, -1); // -1 is clock-wise
         vector<int> *data = find(cur_im[0], ar, BLACK);

         if (gbl_opts->BPA_clear_first_circle_data) {
            for (int i = 0; i < ar->size(); i ++)
               if (cur_im[0][(*ar)[i]] == BLACK)
                  cur_im[0][(*ar)[i]] = WHITE;
            data->clear(); // make sure data->size() <= 1
         }
         
         delete ar;
         if (data->size() <= 1)
         {
            points.push_back(index(i, a[i]));
            p1 = index(i, a[i] + 2*rad);
            my_printf("The starting point is from bottom at: [%d, %d]\n", i, a[i]);
			delete [] a;

            delete data;
            return;
         } else {
            counter = 0;
         }

         delete data;
      }
         
   }

   delete [] a;

   // remove me later
}

// Function: get_the_starting_point
// A helper function for <BPA_boundary>
// Parameter - dir:
// 0   -   first from botttom, then rest of the sides.
// 1   -   first from left 
// 2   -   first from top
// 3   -   first from right
void get_the_starting_point(BYTE **cur_im, BYTE **boundary_im, deque<int> &points, int rad, int &p1, int dir = 0)
{
   int a[4];

   assert(points.size() == 0);
   
   for (int i = 0; i < 4; i ++)
      a[i] = 0;

   int direction = dir;
   a[dir] = 1;

   while (true) {
      
      bool found = false;
      switch (direction) {
         case 0:
            get_the_starting_point_from_bottom(cur_im, boundary_im, points, rad, p1);
            break;
         case 1:
            get_the_starting_point_from_left(cur_im, boundary_im, points, rad, p1);
            break;
         case 2:
            get_the_starting_point_from_top(cur_im, boundary_im, points, rad, p1);
            break;
         case 3:
            get_the_starting_point_from_right(cur_im, boundary_im, points, rad, p1);
            break;
         default:
            printf("Wrong direction for getting the first point!\n");
            exit(0);
      }

      if (points.size() > 0)
         break;

      for (int i = 0; i < 4; i ++)
         if (a[i] == 0) {
            found = true;
            a[i] = 1;
            direction = i;
            break;
         }

      if (!found)
         break;
   }
   
}


void draw_circle(BYTE **cur_im, int x, int y, int rad)
{
   for (int i = 0; i < 360; i ++)
   {
      int temp_y =  y + (int)(rad*sin((double)i*PI/180.0)) ;
      int temp_x =  x + (int)(rad*cos((double)i*PI/180.0)) ;
      if (valid_pixel(temp_x, temp_y))
          cur_im[temp_y][temp_x] = BLACK;
   }
}

void draw_debug_image(vector<int> a,  int num)
{

   BYTE ** im = new_image(image_height, image_width);

   for (int i = 0; i < a.size(); i ++)
      im[0][a[i]] = BLACK;

   char fn[100];
   char *ds = digit_string(4, num);
   sprintf(fn, "bpa_check_area_%s.png", ds);
   free(ds);
   Save2File(fn, im, NULL, image_width, image_height, 0, NULL);
   free_image(im);
}

void bpa_compute_connect1(vector<int> data_points, int &result_point, double &smallest_angle, int &result_center, int rad, int x0, int y0, int x1, int y1)
{
   for (int i = 0; i < data_points.size(); i++)
   {
      int data_x = x_axis(data_points[i]);
      int data_y = y_axis(data_points[i]);

      // get the big angle, refer to image eq1.png
      double side_c_2 = (data_x-x1)*(data_x-x1) + (data_y-y1)*(data_y-y1);
      double side_b_2 = (data_x-x0)*(data_x-x0) + (data_y-y0)*(data_y-y0);

      // refer to http://en.wikipedia.org/wiki/Law_of_cosines
      // equation : r = arcos(a^2+b^2-c^2/2ab)
      double dia = 2.0 * rad;

      // TREAT_ARCOS: treatment for arcosin calculation - the arg many beyong [-1, +1] because of round-off;
      double tmp1 = dia*dia + side_b_2 - side_c_2;
      double tmp2 = 2*dia*sqrt(side_b_2);

      assert(abs(tmp1) < abs(tmp2) + 2); // sometime abs(tmp1) / abs(tmp2) > 1 ;
      assert(tmp2 != 0);

      tmp1 = abs(tmp1) <= abs(tmp2) ? tmp1 : tmp1 > 0 ? tmp2 : -tmp2; // in case there is some round off error.
      double angle_big = acos(tmp1/tmp2);
      double angle_sma = acos(side_b_2/(2*rad*sqrt(side_b_2)));

      double result_angle = angle_big - angle_sma;

      assert(result_angle >= 0);

      if (result_angle < smallest_angle)
      {
         smallest_angle = result_angle;
         result_point = data_points[i];
      }
   }

}

// Function: bpa_compute_connect
// A helper function for <ball_pivoting>
void bpa_compute_connect(vector<int> data_points, int &result_point, double &smallest_angle, int &result_center, int rad, int x0, int y0, int x1, int y1, int dir, int scan_angle)
{
   for (int i = 0; i < data_points.size(); i++)
   {
      int data_x = x_axis(data_points[i]);
      int data_y = y_axis(data_points[i]);

      double half_len = ((data_x - x0)*(data_x - x0) + (data_y - y0)*(data_y - y0))/4.0;
      half_len = sqrt(rad*rad - half_len);
      
      // check the boundary cases:
      // either horizontal or vertical lines
      double point1_x, point1_y;
      double point2_x, point2_y;
      double mid_x = (double)(x0 + data_x)/2.0;
      double mid_y = (double)(y0 + data_y)/2.0;

      if (data_x == x0 ) // vertical line
      {
         point1_x = (x0 + half_len);
         point1_y = (mid_y);
         point2_x = (x0 - half_len);
         point2_y = point1_y;
      }
      else if (data_y == y0)
      {
         point1_x = (mid_x);
         point1_y = (y0 - half_len);
         point2_x = point1_x;
         point2_y = (y0 + half_len);
      }
      else
      {
         double mid_line_m = (double)(x0 - data_x)/(double)(y0 - data_y);
         double theta = atan(mid_line_m);

         // compute the two points, and select the close one based on angle_arc
         point1_x = (mid_x + half_len*cos(theta));
         point1_y = (mid_y - half_len*sin(theta));
         point2_x = (mid_x - half_len*cos(theta));
         point2_y = (mid_y + half_len*sin(theta));
      }

      double diff = abs(sqrt((x0 - point1_x)*(x0 - point1_x) + (y0 - point1_y)*(y0 - point1_y)) - rad);
      assert(diff < 1.0);
      diff = abs(sqrt((x0 - point2_x)*(x0 - point2_x) + (y0 - point2_y)*(y0 - point2_y)) - rad);
      assert(diff < 1.0);

      double arc1 = angle_arc(x1, y1, x0, y0, (int)point1_x, (int)point1_y, dir);
      double arc2 = angle_arc(x1, y1, x0, y0, (int)point2_x, (int)point2_y, dir);

      int point_x = (int) (point1_x + .5);
      int point_y = (int) (point1_y + .5);

      // here, first check the distance between the two points and P1,
      // because it might be the case that the real angle is close to 360,
      // which is big than the false angel.
      if (scan_angle < 51)
      {
         double d1 = (point1_x - x1)*(point1_x - x1) + (point1_y - y1)*(point1_y - y1);
         double d2 = (point2_x - x1)*(point2_x - x1) + (point2_y - y1)*(point2_y - y1);

         if (d1 > d2)
         {
            point_x = (int) (point2_x + .5);
            point_y = (int) (point2_y + .5);
            arc1 = arc2;
         }
      }
      else if (arc1 > arc2)
      {
         point_x = (int) (point2_x + .5);
         point_y = (int) (point2_y + .5);
         arc1 = arc2;
      }

      arc1 = PI * arc1/180.0;

      // here, if two points have the same angle, which happens when the ball hit two planes simultaneously.
      // then, we choose point with large distance from the pivot point.
      if (arc1 < smallest_angle)
      {
         smallest_angle = arc1;
         result_point = data_points[i];
         result_center = index(point_x, point_y);
      }
      /*
      else if (arc1 == smallest_angle)
      {
         int temp_x = x_axis(result_point);
         int temp_y = y_axis(result_point);
         double d1 = (data_x - x0)*(data_x - x0) + (data_y - y0)*(data_y - y0);
         double d2 = (temp_x - x0)*(temp_x - x0) + (temp_y - y0)*(temp_y - y0);

         if (d1 > d2)
         {
            result_point = data_points[i];
         }
      }
      */
      
   }

}

/* function: ball_turning_around_check

   Check the angle from back to front.

   return 0 if the new one is ok, otherwise return the number which indicates
   how many points we should discard.
   
   The current latest point is located at looked_num%look_ahead_num
*/
int  ball_turning_around_check( int looked_num, int look_ahead_num, double *looked_angle, double orig_angle)
{
   if ( gbl_opts->BPA_do_not_check_turning_around )
      return 0;
   
   int data_len = min(looked_num, look_ahead_num);

   for (int i = 0; i < data_len ; i ++)
   {
      // check backwards
      int index = (looked_num - 1 - i) % look_ahead_num;
      double starting_orig_angle = looked_angle[index];

      // The reason we put && < is because it may have 360 change at the corner case
      // return i+1 to ensure it is large than 0.
      double diff_angle = abs(starting_orig_angle - orig_angle);
      if ( gbl_opts->BPA_turning_around_angle ) {
         if ( diff_angle > 180 - gbl_opts->BPA_turning_around_angle &&
              diff_angle < 180 + gbl_opts->BPA_turning_around_angle)
            return i+1;
      }
      else if (diff_angle > (180 - 5*look_ahead_num) &&
               diff_angle < (180 + 5*look_ahead_num))
         return i+1;

   }

   return 0;
}

// Function: ball_pivot_touch_data
// Helper and stragetic function for pivoting the ball
//
void ball_pivot_touch_data_refine(double &scan_angle,
                           vector<int> &data_points,
                           int &last_x1, int &last_y1, bool &found,
                           int rad, double orig_angle, int direction,
                           int x0, int y0, double pace_degree,
                           BYTE **cur_im, int local_counter,
                           int starting_point,
                           st_table *st_single_pivot,
                           st_table *st_connected_points )
{
   // let's start from a tiny angle to avoid noise???? - for some cases, the data can be found at the scan_angle 0
   // the reason is the previous pivoting found a point, and maybe more than 1 point. Then, the next round may find
   // a point which is not in the previous round (since these points will be cleared), but very close to them, because
   // of the floating point error.
   // set the scan_angle should be safe here.
   scan_angle = 5.0;
   
   double lower_bound = scan_angle;
   double searching_angle = 10.0;
   bool searching_status = true;
   bool found_data_at_first_time = false;
   bool never_found_data = true;
   int  PACE_DEGREE_NUM = 8;
   //printf("Entering pivot with scan_angle: %4f", scan_angle);
   while (scan_angle < 360)
   {
      // use double to get more accurate value
      // *1_prime is the end point
      // *_prime  is the middle point, i.e., the center of the circle.
      double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
      double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
      double y_prime = (y1_prime + y0)/2;
      double x_prime = (x1_prime + x0)/2;

      // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
      // be touch too early.
      vector<int> *cir_area = arc_region(x_prime, y_prime, x1_prime, y1_prime, 360, rad - 1, direction, cur_im);
      //vector<int> *cir_area = arc_region(x_prime, y_prime, (int)x1_prime, (int)y1_prime, 180, rad-1, direction);

      if (0)  // this is for the arc area between lower_bound and scan_angle
      {
         vector<int> *arc_area = arc_region(x0, y0, x1_prime, y1_prime, scan_angle - lower_bound, 2*rad -2, direction*-1);
         for(int i = 0; i < arc_area->size(); i++)
            if ((*arc_area)[i] != index(x0,y0))
               cir_area->push_back((*arc_area)[i]);

         delete arc_area;
      }

      last_x1 = (int)x1_prime;
      last_y1 = (int)y1_prime;

      // here let's speed up the search by binary search
      if (searching_status) {

         // if data found, calculate the center of the circle, compare all the centers.
         if (cir_area->size() == 0) {

            if (never_found_data) {  // incremental

               if (lower_bound == 359.9) { // no real data found  , here may go into infinit loop.
                  assert(lower_bound == scan_angle);
                  searching_status = false;
                  delete cir_area;
                  continue;
               }
               
               lower_bound = scan_angle;
               scan_angle += searching_angle;
               scan_angle = min(scan_angle, 359.9);
               
            } else { // decremental
               
               double tmp = scan_angle + (scan_angle - lower_bound)/2;
               lower_bound = scan_angle;
               scan_angle = tmp;
               if (scan_angle - lower_bound < (pace_degree * PACE_DEGREE_NUM)) {
                  searching_status = false;
                  scan_angle = lower_bound + pace_degree;
               }
            }
         } else {
            
            if (scan_angle - lower_bound > (pace_degree * PACE_DEGREE_NUM))
            {
               scan_angle = (lower_bound + scan_angle) / 2;
               never_found_data = false;
            } else {
               searching_status = false;
               if (scan_angle == lower_bound) // first time
                  found_data_at_first_time = true;
               else 
                  scan_angle = lower_bound + pace_degree;
            }
         }

         if (!found_data_at_first_time ) {
            delete cir_area;
            continue;
         }

      } // end of speed up
      

      vector<int> *test_vec = new vector<int>;

      for (int i = 0; i < cir_area->size(); i++)
         if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
         {
            st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
            test_vec->push_back((*cir_area)[i]);
         }

      // if data found, calculate the center of the circle, compare all the centers.
      // vector<int> *tmp = find(cur_im[0], test_vec, BLACK);
      data_points = *test_vec;
      
      // local_counter is used to make sure that the ball at least pivoted a number of times
      // before reaching the starting points itself.
      // Also, if the a potential point in data_points is the boundary point, don't think it again
      // AND we should clear all points in data_points since they are all checked at this iteration.
      for (int i = 0 ; i < data_points.size(); i++)
         if (st_is_member(st_connected_points, (char *) data_points[i]))
         {
            if (local_counter > 10 && data_points[i] == starting_point)
               continue;
               
            data_points.erase(data_points.begin() + i);
            i--;
         }
      /*
         else  // clear orignal image, this is used to fix the bug of stopped when dir=1;
         {
            cur_im[0][data_points[i]] = WHITE;
         }
      */

      // if do debug_image, comment the 3 lines out
      delete test_vec;
      delete cir_area;

      if (data_points.size() > 0)
      {
         found = true;
         my_printf("==@ degree %3f", scan_angle);
         //draw_debug_image(*cir_area, counter);

         break;
      } 

      // else, go back to while with scan_angle += 10;
      scan_angle += pace_degree;

   } // end of while, ball pivot for data

   //printf(" --> Exiting pivot with scan_angle: %4f\n", scan_angle);

}


#if 1
// Function: ball_pivot_touch_data
// Helper and stragetic function for pivoting the ball
//
void ball_pivot_touch_data(double &scan_angle,
                           vector<int> &data_points,
                           int &last_x1, int &last_y1, bool &found,
                           int rad, double orig_angle, int direction,
                           int x0, int y0, double pace_degree,
                           BYTE **cur_im, int local_counter,
                           int starting_point,
                           st_table *st_single_pivot,
                           st_table *st_connected_points )
{
   // let's start from a tiny angle to avoid noise???? - for some cases, the data can be found at the scan_angle 0
   // the reason is the previous pivoting found a point, and maybe more than 1 point. Then, the next round may find
   // a point which is not in the previous round (since these points will be cleared), but very close to them, because
   // of the floating point error.
   // set the scan_angle should be safe here.
   scan_angle = 1.0;
   
   double lower_bound = scan_angle;
   double searching_angle = 20.0;
   bool searching_status = true;
   bool found_data_at_first_time = false;
   bool never_found_data = true;
   int  PACE_DEGREE_NUM = 8;
   while (scan_angle < 360)
   {
      // use double to get more accurate value
      // *1_prime is the end point
      // *_prime  is the middle point, i.e., the center of the circle.
      double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
      double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
      double y_prime = (y1_prime + y0)/2;
      double x_prime = (x1_prime + x0)/2;

      // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
      // be touch too early.
      vector<int> *cir_area = arc_region(x_prime, y_prime, x1_prime, y1_prime, 360, rad-1, direction, cur_im);

      if (0)  // this is for the arc area between lower_bound and scan_angle
      {
         vector<int> *arc_area = arc_region(x0, y0, x1_prime, y1_prime, scan_angle - lower_bound, 2*rad -2, direction*-1);
         for(int i = 0; i < arc_area->size(); i++)
            if ((*arc_area)[i] != index(x0,y0))
               cir_area->push_back((*arc_area)[i]);

         delete arc_area;
      }

      last_x1 = (int)x1_prime;
      last_y1 = (int)y1_prime;

      // here let's speed up the search by binary search
      if (searching_status) {

         // if data found, calculate the center of the circle, compare all the centers.
         
         if (cir_area->size() == 0) {

            if (never_found_data) {  // incremental

               if (lower_bound == 359.9) { // no real data found  , here may go into infinit loop.
                  assert(lower_bound == scan_angle);
                  searching_status = false;
                  delete cir_area;
                  continue;
               }
               
               lower_bound = scan_angle;
               scan_angle += searching_angle;
               scan_angle = min(scan_angle, 359.9);
               
            } else { // decremental
               
               double tmp = scan_angle + (scan_angle - lower_bound)/2;
               lower_bound = scan_angle;
               scan_angle = tmp;
               if (scan_angle - lower_bound < (pace_degree * PACE_DEGREE_NUM)) {
                  searching_status = false;
                  scan_angle = lower_bound + pace_degree;
               }
            }
         } else {
            
            if (scan_angle - lower_bound > (pace_degree * PACE_DEGREE_NUM))
            {
               scan_angle = (lower_bound + scan_angle) / 2;
               never_found_data = false;
            } else {
               searching_status = false;
               if (scan_angle == lower_bound) // first time
                  found_data_at_first_time = true;
               else 
                  scan_angle = lower_bound + pace_degree;
            }
         }

         if (!found_data_at_first_time ) {
            delete cir_area;
            continue;
         }
         
      } // end of speed up
      

      vector<int> *test_vec = new vector<int>;

      for (int i = 0; i < cir_area->size(); i++)
         if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
         {
            st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
            test_vec->push_back((*cir_area)[i]);
         }

      // if data found, calculate the center of the circle, compare all the centers.
      data_points = *test_vec;
      
      // local_counter is used to make sure that the ball at least pivoted a number of times
      // before reaching the starting points itself.
      // Also, if the a potential point in data_points is the boundary point, don't think it again
      // AND we should clear all points in data_points since they are all checked at this iteration.
      for (int i = 0 ; i < data_points.size(); i++)
         if (st_is_member(st_connected_points, (char *) data_points[i]))
         {
            if (local_counter > 10 && data_points[i] == starting_point)
               continue;
               
            data_points.erase(data_points.begin() + i);
            i--;
         }
         else  // clear orignal image, this is used to fix the bug of stopped when dir=1;
         {
            cur_im[0][data_points[i]] = WHITE;
         }

      // if do debug_image, comment the 3 lines out
      delete test_vec;
      delete cir_area;

      if (data_points.size() > 0)
      {
         found = true;
         my_printf("==@ degree %3.2f", scan_angle);
         //draw_debug_image(*cir_area, counter);

         break;
      } 

      // else, go back to while with scan_angle += 10;
      scan_angle += pace_degree;

   } // end of while, ball pivot for data

}

#else
// Function: ball_pivot_touch_data
// Helper and stragetic function for pivoting the ball
//
void ball_pivot_touch_data(double &scan_angle,
                           vector<int> &data_points,
                           int &last_x1, int &last_y1, bool &found,
                           int rad, double orig_angle, int direction,
                           int x0, int y0, double pace_degree,
                           BYTE **cur_im, int local_counter,
                           int starting_point,
                           st_table *st_single_pivot,
                           st_table *st_connected_points )
{
   while (scan_angle < 360)
   {
      // use double to get more accurate value
      // *1_prime is the end point
      // *_prime  is the middle point, i.e., the center of the circle.
      double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
      double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
      int y_prime = (int)((y1_prime + y0)/2);
      int x_prime = (int)((x1_prime + x0)/2);

      // test the data in this new area.
      //vector<int> *arc_area = new vector<int>;
      // vector<int> *arc_area = arc_region(x0, y0, last_x1, last_y1, pace_degree, 2*rad, direction);
      // vector<int> *cir_area = new vector<int>;


      // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
      // be touch too early.
      vector<int> *cir_area = arc_region(x_prime, y_prime, (int)x1_prime, (int)y1_prime, 180, rad-1, direction);
      //vector<int> *cir_area = arc_region(x_prime, y_prime, x0, y0, 360);
      //vector<int> *arc_area = arc_region(x0, y0, last_x1, last_y1, scan_angle);

      last_x1 = (int)x1_prime;
      last_y1 = (int)y1_prime;

      vector<int> *test_vec = new vector<int>;
      /*
        for (int i = 0; i < arc_area->size(); i++)
        if (!st_is_member(st_single_pivot, (char *)((*arc_area)[i])))
        {
        st_insert(st_single_pivot, (char *) ((*arc_area)[i]), (char *) 1);
        test_vec->push_back((*arc_area)[i]);
        }
      */
      for (int i = 0; i < cir_area->size(); i++)
         if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
         {
            st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
            test_vec->push_back((*cir_area)[i]);
         }

      // if data found, calculate the center of the circle, compare all the centers.
      vector<int> *tmp = find(cur_im[0], test_vec, BLACK);
      data_points = *tmp;
      delete tmp;  // here, since we have copied the data into data_points, so we can delete it.

      // local_counter is used to make sure that the ball at least pivoted a number of times
      // before reaching the starting points itself.
      // Also, if the a potential point in data_points is the boundary point, don't think it again
      // AND we should clear all points in data_points since they are all checked at this iteration.
      for (int i = 0 ; i < data_points.size(); i++)
         if (st_is_member(st_connected_points, (char *) data_points[i]))
         {
            if (local_counter > 10 && data_points[i] == starting_point)
               continue;
               
            data_points.erase(data_points.begin() + i);
            i--;
         }
         else  // clear orignal image, this is used to fix the bug of stopped when dir=1;
         {
            cur_im[0][data_points[i]] = WHITE;
         }

      // if do debug_image, comment the 3 lines out
      //delete arc_area;
      delete test_vec;
      delete cir_area;

      if (data_points.size() > 0)
      {
         found = true;
         my_printf("==@ degree %3f", scan_angle);
         //draw_debug_image(*cir_area, counter);

         break;
      } 

      // else, go back to while with scan_angle += 10;
      scan_angle += pace_degree;

   } // end of while, ball pivot for data
}
#endif

// Function: ball_pivoting
// function for pivoting the ball
//
void ball_pivoting(BYTE **cur_im, deque<int>& points, int rad, int p1, BYTE **&debug_im, int sep_num, POINTS_AUX *points_aux)
{
   DEBUG_BPA = gbl_opts->BPA_debug_mode;
   int look_ahead_num = 20/rad + 4 ; // threshold look_ahead_num is used to check whether the ball has turn around.
   if ( gbl_opts->BPA_turning_check_pool_size )
      look_ahead_num = gbl_opts->BPA_turning_check_pool_size;
   
   int looked_num = 0;               // record how many times we have seen
   double starting_orig_angle = 0.0; // record the starting point of the angle.
   bool reversed_direction = false;  // indication of reverse direction.
   double *looked_angle = (double *) malloc(sizeof(double) * look_ahead_num); // circle FIFO like recording.
   
   
   int h = image_height;
   int w = image_width;

   // for debug only
   // points[0] = index(985, 102); // right side.
   // end

   // draw a circle of radius rad
   // assume normal (0,1);
   int x = x_axis(points[0]);
   int y = y_axis(points[0]);
   
   // temp test
   assert(points.size() == 1);
   int starting_point = index(x, y);

   // define a debug image, which contains the circles and the original image
   bool isShowDebugImage = false;  // for debuging BPA circling drawing only.
   if (!debug_im && (isShowDebugImage ||DEBUG_BPA))
      debug_im = copy_image(cur_im, h, w);

   // st_connected_points is used to record all points in the trajactory of the boundary.
   st_table *st_connected_points = st_init_table(st_numcmp, st_numhash);
   st_insert(st_connected_points, (char *)points[0], (char *)1);

   // this is for starting point looking up. If the point found is falling inside
   // this hash table, then it is considered a closed boundary is found.
   // right now, the neighbor-hood is 3x3 mask.
   // However, for very big radius, namely the first rough radius, we should enlarge the region.
   st_table *st_starting_points = st_init_table(st_numcmp, st_numhash);

   if (rad < BPA_ROUGH_BOUNDARY_RADIUS)
   {
      for (int i = -3; i < 4; i ++)
         for (int j = -3; j < 4; j ++)
            st_insert(st_starting_points, (char *)index(x+i, y+j), (char *)1);
   } else { // for very big radius, we set it as a 20x10, since we assume we only start from horizontal lines.
      for (int i = -10; i < 11; i ++)
         for (int j = -10; j < 11; j ++)
            st_insert(st_starting_points, (char *)index(x+i, y+j), (char *)1);
   }
   
   int x0 = x, y0 = y ;                  // the starting point of the data
   int x1 = x_axis(p1), y1 = y_axis(p1); // the ending point of the pivot axis.
   int direction = -1;        // -1 is clock-wise, 1 is counter clock-wise.
   static int counter = 0;
   int local_counter = 0;
   // for debug only
   // x0 = 294;  y0 = 392;
   // x1 = 292;  y1 = 432;
   // direction = 1;
   // end

   double pace_degree = gbl_opts->pace_degree;
   int starting_x0 = x0, starting_x1 = x1;
   int starting_y0 = y0, starting_y1 = y1;
   BYTE ***boundary_im = new_3D_image(image_height, image_width);
   int color_switch = 0;
   while (true)
   {
      bool found = false;

      counter ++;
      local_counter ++;
      my_printf("\nNo[%3d]:", counter);
      
      // st_single_pivote is used to record a single pivot of the data point
      // That is, a record of old points visited.
      st_table *st_single_pivot = st_init_table(st_numcmp, st_numhash);

      // start pivot/rolling around a point, until a point is touched.
      double scan_angle = 0.0;
      double orig_angle = 0.0;
      vector<int> data_points;

      assert(x1 != x0 || y1 != y0);
      // compute the line with 10 degree from the orignal line
      if (x0 == x1)
         orig_angle = y0 > y1 ? 90.0 : -90.0;
      else
      {
         // here, we assume the angle is from right-bound x axis to the L(P0-P1)
         // counter-clock wise is positive (0 - 180), clock-wise is negative (-0.0 - -180.0)
         orig_angle = (atan((double)(-1)*(y1-y0)/(double)(x1-x0))) * 180.0 / PI;

         if (y1 < y0 && orig_angle < 0)
            orig_angle += 180.0;
         else if (y1 > y0 && orig_angle > 0)
            orig_angle -= 180.0;
         else if (y1 == y0 && x1 > x0)
            orig_angle = 0.0;
         else if (y1 == y0 && x1 < x0)
            orig_angle = direction * 180.0;
      }

      // This is used to check whether the ball is turning around, which should be avoided and stopped.
      // The solution is to maintain a circle array, say size of 5 (a parameter).
      // If the new position has a normal has a diffenrent angle large than a threshold with any of the angle
      // in the circle array, we consider this new one is reached a turning point.
      if (looked_num == 0)
      {
         looked_angle[looked_num ++] = orig_angle;
      }
      // for a big radius ball, we don't want to check the turning back case. Because the large ball will give
      // us a connected but very low resolution boundary. Later on, we will do refinement based on this rough boundary.
      // the above description is not accurate?.
      //else if (rad < BPA_ROUGH_BOUNDARY_RADIUS) // Let's put something like a flag here to enable open polygon first time turning around check later on.
      else if (gbl_opts->BPA_check_turning_point_for_first_iteration)
      {
         /*
         if ( looked_num == 1 && abs(starting_orig_angle - orig_angle) < (180.0/(double)look_ahead_num) )
         {
            starting_orig_angle = orig_angle;
         }
         else
            looked_num ++;
         */

         // one possible bug is for the boundary of this shape:
         //  __    __
         //    |  |
         //    |__|
         // since it will consider this case a turning point.

         /*
         if (abs(starting_orig_angle - orig_angle) > (180 - 5*look_ahead_num) &&
             abs(starting_orig_angle - orig_angle) < (180 + 5*look_ahead_num))
         */

         int ret = ball_turning_around_check( looked_num, look_ahead_num, looked_angle, orig_angle);
         if ( ret )
         {
            reversed_direction = true;
                  
            // remove those points found after revsersing.
            for (int i = 0; i < ret && (gbl_opts->BPA_do_not_remove_extra_turning_around_pts == 0); i++)
            {
               direction == -1 ? points.pop_back() : points.pop_front();
               direction == -1 ? points_aux->end_points.pop_back() : points_aux->end_points.pop_front();
               direction == -1 ? points_aux->radius.pop_back() : points_aux->radius.pop_front();
               direction == -1 ? points_aux->colors.pop_back() : points_aux->colors.pop_front();
            }

            looked_num = 0; // reset looked_num;
      
            scan_angle = 360.0; // so that we do NOT enter the while loop.

            if (DEBUG_BPA > LOW_INFO)
            {
               printf("########################################\n");
               printf("########BPA####### Found a Turning on %d\n", counter);
               printf("########################################\n");
            }
            
         } else {

            looked_angle[looked_num++ % look_ahead_num] = orig_angle;
         }

         /*
         if ( looked_num > look_ahead_num )
         {
            looked_num = 1;
            starting_orig_angle = orig_angle;
         }
         */

      }
         

      my_printf("==<P1_P0_X>[%4.2f], P0[%3d,%3d], P1[%3d,%3d]", orig_angle, x0, y0, x1, y1);

      int last_x1 = x1, last_y1 = y1;
      int last_x0 = x0, last_y0 = y0;
      ball_pivot_touch_data(scan_angle, data_points, last_x1, last_y1, found, rad, orig_angle,
                            direction, x0, y0, pace_degree, cur_im, local_counter, starting_point,
                            st_single_pivot, st_connected_points);

      // some sanity check here
      st_free_table(st_single_pivot);

      
      // if no data found, or direction has been reversed, consider revise point.
      if (!found || reversed_direction)
      {
         reversed_direction = false;
         if (direction == -1) 
         {
            direction = 1;
            scan_angle = 0;
            //counter = 0;
            local_counter = 0;

            my_printf("\n======== Now we change back to orignal point, in another direction! =====\n");

            // change the P0, P1 back
            x0 = starting_x0; x1 = starting_x1;
            y0 = starting_y0; y1 = starting_y1;
            
            continue;
         }
         else
         {
            // exit now!

            if (DEBUG_BPA > LOW_INFO)
               printf("After 360 degree pivot, no data found, so quit....\n");
            
            break;
         }
      }

      // new data was found, find the smallest angle 
      // if found new data, add the new data into points, and st_connected_points
      // check if this new added data is already in the st_connected_points, if so, means the job is done.
      double smallest_angle = 2*PI+.1; // here, we add .1 to avoid assert error on LINUX only / no problem on Windows.
      int result_center;
      int result_point = -1;
      bpa_compute_connect(data_points, result_point, smallest_angle, result_center, rad, x0, y0, x1, y1, direction, scan_angle);
      assert(result_point != -1);

      // check if we have reach the starting point
      bool reach_starting = false;
      for (int i = 0 ; i < data_points.size(); i ++)
         if (starting_point == data_points[i])
         {
            reach_starting = true;
            break;
         }

      // when a new point is located, record the point itself, and the line between this
      // point and the center of the circle, which will be treated as a new starting point.
      // (x0, y0) - pivot point
      // (x1, y1) - arc end point
      
      // compute the (x1, y1) based on the result_point.
      x0 = x_axis(result_point);
      y0 = y_axis(result_point);

      // for (x1, y1), we know the angle between the reference line to the line [O, L0], so we
      // can get the O, then, it is trival to get the end point
      // algorithm 1
      // double center_y = y0 - rad*sin(PI*(orig_angle + direction*smallest_angle)/180.0);
      // double center_x = x0 - rad*cos(PI*(orig_angle + direction*smallest_angle)/180.0);
      // algorithm 2
      double center_y = y_axis(result_center);
      double center_x = x_axis(result_center);

      y1 = (int)(y0 - 2*(y0 - center_y));
      x1 = (int)(x0 - 2*(x0 - center_x));
      int points1 = index(x1, y1);

      st_insert(st_connected_points, (char *) result_point, (char *)1);
      direction == -1 ? points.push_back(result_point) : points.push_front(result_point);
      direction == -1 ? points_aux->end_points.push_back(points1) : points_aux->end_points.push_front(points1);
      direction == -1 ? points_aux->radius.push_back(rad) : points_aux->radius.push_front(rad);
      direction == -1 ? points_aux->colors.push_back(points_aux->colors.size() % 3) : points_aux->colors.push_front((points_aux->colors[0] + 1) % 3);

      
      //if(result_point == starting_point||st_is_member(st_connected_points, (char *) result_point))
      if (reach_starting)
      {
         // a closed boundary was found, break;
         /* INVARIANTS:
            1. it is impossible that a ball can NOT pivot to starting point from clockwise direction,
               but is able to pivot from counter clockwise direction.

            2. the last 1 - 2 points of the points_aux->end_points is meaningless.
            3. the length of points and points_aux fields are equal.
         */    
         direction == -1 ? points.push_back(starting_point) : points.push_front(starting_point);
         direction == -1 ? points_aux->end_points.push_back(starting_point) : points_aux->end_points.push_front(starting_point);
         direction == -1 ? points_aux->radius.push_back(rad) : points_aux->radius.push_front(rad);
         direction == -1 ? points_aux->colors.push_back(points_aux->colors.size() % 3) : points_aux->colors.push_front((points_aux->colors[0] + 1) % 3);

         if (DEBUG_BPA > LOW_INFO)
            my_printf("Reached starting points with radius %d, so quit....\n", rad);
            
         break;
      }

      // 2nd check if we have reached the starting point
      if (local_counter > 10)
      {
         if (st_lookup(st_starting_points, (char *)result_point, (char **)NULL))
         {
            if (starting_point != result_point){  // make sure that its a closed boundary.
               direction == -1 ? points.push_back(starting_point) : points.push_front(starting_point);
               direction == -1 ? points_aux->end_points.push_back(starting_point) : points_aux->end_points.push_front(starting_point);
               direction == -1 ? points_aux->radius.push_back(rad) : points_aux->radius.push_front(rad);
               direction == -1 ? points_aux->colors.push_back(points_aux->colors.size() % 3) : points_aux->colors.push_front((points_aux->colors[0] + 1) % 3);
            }

            if (DEBUG_BPA > LOW_INFO)
               my_printf("Reached starting points with radius %d during 2nd check, so quit....\n", rad);
            
            break;
         }
      }
      

      my_printf("==new P0[%3d,%3d], P1[%3d,%3d]", x0, y0, x1, y1);
      // draw the new circle for debug
      if (isShowDebugImage || DEBUG_BPA)
         draw_circle(debug_im, (int) center_x, (int) center_y, rad);
      if (isShowDebugImage || (DEBUG_BPA) && counter % sep_num == 0)
      {
         if ((gbl_opts->min_debug == gbl_opts->max_debug) ||
             ((counter >= gbl_opts->min_debug && gbl_opts->min_debug > 0) ||
             counter <= gbl_opts->max_debug))
         {
            char fn[1000];
            char *ds = digit_string(4, counter);
            strncpy(fn, output_fn, strlen(output_fn) - 4);
            fn[strlen(output_fn) - 4] = 0;
            sprintf(fn, "%s_bpa_debug_pivot__%s_rad_%d.png", fn, ds, rad);
            free(ds);
            Save2File(fn, debug_im, NULL, image_width, image_height, 0, NULL);
         }
      }

      /*
      // draw the x0, y0
      BYTE **im = new_image(image_height, image_width);
      im[y0][x0] = BLACK;
      im[y1][x1] = BLACK;
      char fn[100];
      sprintf(fn, "bpa_points_%3d.png", counter);
      Save2File(fn, im, NULL, image_width, image_height, 0, NULL);
      free_image(im); 

      color_switch ++;
      if (color_switch % 3 == 0)
         draw_line(boundary_im, h, w, last_x0, last_y0, x0, y0, 255, 0, 0);
      else if (color_switch % 3 == 1)
         draw_line(boundary_im, h, w, last_x0, last_y0, x0, y0, 0, 255, 0);
      else
         draw_line(boundary_im, h, w, last_x0, last_y0, x0, y0, 0, 0, 255);
      //char fn[100];
      //sprintf(fn, "bpa_boundary_image_%3d.png", counter);
      //Save2File(fn, NULL ,NULL, w, h, 1, boundary_im);
      */


      // free the arc_region at the end of loop.

   }

   // free the 3D image memory
   free_image_3D(boundary_im);
}

/* Function: is_good_matched
   Check whether this is a good matched
*/
bool is_good_matched(BYTE **im, int h, int w, int x1, int y1, int x2, int y2, float ratio)
{
   vector<int> *line_pixels = pixels_between_2_points(h, w, x1, y1, x2, y2);

   // two choices:
   // 1. use this as a reference, check how many data falling on this line
   // 2. define a neighbor region, say 3x3, check how many data falling in this region.

   vector<int> *matched_pixels = find(im[0], line_pixels, BLACK);

   if ((double) matched_pixels->size() / (double) line_pixels->size() > ratio)
   {
      delete (matched_pixels);
      return 1;
   }

   delete (matched_pixels);
   return 0;
   
}

/* Function: is_gap_line_detected_by_large_radius
   Check whether this is a gap line
*/
bool is_gap_line_detected_by_large_radius(int x_1st, int y_1st,int x_2nd, int y_2nd)
{
   if ( gbl_opts->BPA_ignore_gap_line )
      return false;
   
   int a = abs(x_1st - x_2nd);
   int b = abs(y_1st - y_2nd);

   if ( a + b < gbl_opts->BPA_gap_line_length)
      return false;

   if (sqrt((double)(a*a + b*b)) < gbl_opts->BPA_gap_line_length)
      return false;
   
   return true;
}

/* Function: clear_data_for_new_boundary
   Clear the data for a boundary
*/
void clear_data_for_new_boundary(BYTE **cur_im, deque<int> *points, int rad)
{
   int points_size = points->size();

   int h = image_height;
   int w = image_width;

   for (int i = 0; i < points_size-1; i ++)
   {
      int x1 = x_axis((*points)[i])  ;
      int y1 = y_axis((*points)[i])  ;
      int x2 = x_axis((*points)[i+1]);
      int y2 = y_axis((*points)[i+1]);

      draw_line_and_clear_data(NULL, h, w,
                               (int)x1, (int)y1,(int) x2,(int) y2,
                               0, 0, 0, cur_im,
                               WHITE, gbl_opts->BPA_clear_data_mask);

   }

   if (DEBUG_BPA > MID_INFO) {
      char fn[1000];
      sprintf(fn, "bpa_debug_clear_boundary_rad_%d_%d.png", rad, rand());
      Save2File(fn, cur_im, NULL, image_width, image_height, 0, NULL);
   }
}

/* Function: ball_pivoting_refinement

   This func is used to implement adaptive BPA.
   The basic idea is to check the line seg clockwisely starting from the beginning of the points,
   If a line seg is large than a threshold, say radius of a new ball size, try to re-pivot on this point based on the direction
   (stored in POINTS_AUX) and try to reach the next point.
      * what if the next point can never be reached? such as a new boundary is found, like ex3.
      * what if the next point was not exactly matched?

   Parameters:

   refine_ignore_mutli_boundaries  - This flag indicates there is only one boundary (big one). If we have multiple boundaries,
                                     like 8 circle, should set this flag
   BPA_clear_first_circle_data     - This flag will clear the data in the first circle detected by the function <get_the_starting_point()>
   BPA_starting_point_sweeping_dir - This flag is used by <get_the_starting_point()> to indicate which direction we want to sweep first.
                                     Often, this is a prior knowledge.
   BPA_refine_speed_up             - This flag is used to switch between traditional refinement or speed up refinement.
                                     The speed up refinement may have not be so accurate in some cases.
                                     Note: after improveing the arc_region() function, there is not much diffrent now.
                                      Usually traditional one is more accurate. So the default vaue is 0.

*/
void ball_pivoting_refinement(BYTE **cur_im, deque<int>& points, int rad, BYTE **&debug_im, int sep_num, POINTS_AUX *points_aux,
                              array_t *&new_boundary_array, array_t *&new_boundary_array_aux, vector<int> *&replaced_index, int current_points_index)
{
   assert(points.size() == points_aux->end_points.size());
   assert(points.size() == points_aux->radius.size());
   
   int look_ahead_num = 20/rad + 4 ; // threshold look_ahead_num is used to check whether the ball has turn around.
   if ( gbl_opts->BPA_turning_check_pool_size )
      look_ahead_num = gbl_opts->BPA_turning_check_pool_size;
   double *looked_angle = (double *) malloc(sizeof(double) * look_ahead_num); // circle FIFO like recording.
   int MAX_REFINE_NUMBER = rad == BPA_AFTER_ROUGH_RADIUS ? BPA_AFTER_ROUGH_REFINE_NUM : BPA_REGULAR_REFINE_NUM;
   if ( gbl_opts->BPA_refine_number != 0 )
      MAX_REFINE_NUMBER = gbl_opts->BPA_refine_number;
   
   
   int h = image_height;
   int w = image_width;

   /* To get more accurate boundary, a refinement process is applied after this initial pivoting.
      During the initial pivoting, we shall keep track of some information for further refinement, such as the coordinates and order of
      the boundary points detected by the BPA algorithm, and their directions. For debugging and visualization purpose, each boundary point
      is assigned a color (either red, green or blue). The first iteration of the refinement takes the half length of the original ball,
      namely 32/2 = 16 pixels. For each line (defined by two adjacent boundary points) detected by the initial BPA, we check whether it
      needs to be refined or not based on the following two criteria: 1. if this line is shorter than a threshold (half radius, namely
      16/2 = 8 pixel),  then this line needs no refinement during this iteration (may need refinement for further iteration where the
      radius is reduced.). 2. if the length of this line is larger than the threshold, then I checked how many real data landing on this
      line. If it exceeds a certain percentage, say 50%, then we do not need to do refinement on this line either (permanently).
   
      If refinement is needed on a line, the BPA algorithm with smaller ball size is applied as following: the first point and its direction
      are taken as input, and the smaller ball was pivoting on the original image, until EITHER it reached the end point of this line OR it
      turned around at a place where the refinement ball size is smaller than the gap. If it reached the other point of the line, which means
      this pivoting is effective and new points detected during the process are inserted into the boundary deque, together with their direction
      and colors assigned for further refinement. If the ball could not reach the other end of the line, all new points it detected are discarded.

      We can keep doing this refinement process (for each iteration, the ball size is reduced by half, namely 32, 16, 8, 4, ...) until the
      boundary detected is good enough for representing the original image. 
   */
 
   /* CHECK the length of the lines for re-pivot. */
   double thres_len = rad*rad;  // threshold for the length squre of the new radius.
   vector<int> insert_points;   // points: old points, insert_points: new found points with smaller radius pivoting.
   POINTS_AUX *insert_points_aux = new POINTS_AUX; // aux structure for new found points, this is similiar to points_aux.
   int refine_num = 1;
   int is_boundary_starting_point = 1;
   int raw_idx_pts_num = 0;
   int is_boundary_splitted = 0;
   int boundary_starting_index = 0;
   st_table *st_boundary_starting_points = st_init_table(st_numcmp, st_numhash);
   for (int point_index = 0; point_index < points.size()-1; point_index ++)
   {

      int x_1st = x_axis(points[point_index]);
      int y_1st = y_axis(points[point_index]);
      int x_2nd = x_axis(points[point_index+1]);
      int y_2nd = y_axis(points[point_index+1]);

      if ( x_1st == x_2nd && y_1st == y_2nd ) {
         my_printf("\nWARNING: two IDENTICAL boundary points adjancent: [%d, %d],[%d, %d]\n", x_1st, y_1st, x_2nd, y_2nd);
         continue;
      }
      
      int x_diff = x_2nd - x_1st;
      int y_diff = y_2nd - y_1st;

      raw_idx_pts_num ++;
      
      // this is for boundary starting point looking up. If the point found is falling inside
      // this hash table, then it is considered a closed boundary is found.
      // right now, the neighbor-hood is 6x6 mask.
      if (is_boundary_starting_point)
      {
         is_boundary_starting_point = 0;
         boundary_starting_index = point_index;
         for (int i = -3; i < 4; i ++)
            for (int j = -3; j < 4; j ++)
               st_insert(st_boundary_starting_points, (char *)index(x_1st+i, y_1st+j), (char *)1);
      }
      
      // IF the line is short, continue,
      // Or if the the line is almost horizontal or vertical (this is just used as skipping lines, could be removed),continue,
      // The above is not so good, for example: --___--, assume it is connection vertically.
      // remove the 2nd condition for now.
      if (!is_boundary_splitted && ((x_diff*x_diff + y_diff*y_diff < thres_len/4)))
         // || is_gap_line_detected_by_large_radius(x_1st, y_1st, x_2nd, y_2nd)))
          //is_good_matched(cur_im, h, w, x_1st, y_1st, x_2nd, y_2nd)
      {
         my_printf("\n ####BREAK### Boundary split or too short or gap line detected !\n");
         continue;
      }

      assert(points.size() == points_aux->end_points.size());
      assert(points.size() == points_aux->radius.size());
      
      my_printf("\n The %dth point [%d, %d], 2nd [%d, %d] at pos:%d ", refine_num++, x_1st, y_1st, x_2nd, y_2nd, point_index);
      // reset the insert_points.
      if (insert_points.size() > 0)
      {
         assert (insert_points.size() == insert_points_aux->end_points.size());
         insert_points.clear();
         insert_points_aux->end_points.clear();
      }
      
      // re-pivot from (x_lst, y_lst) to (x_2nd, y_2nd) using new smaller ball.
      int x = x_1st;
      int y = y_1st;
      int starting_point = index(x, y);

      // define a debug image, which contains the circles and the original image
      if (!debug_im && DEBUG_BPA)
         debug_im = copy_image(cur_im, h, w);

      // st_connected_points is used to record all points in the trajactory of the boundary, the same as points, but
      // points is not good for search - O(n), this one is O(1)
      st_table *st_connected_points = st_init_table(st_numcmp, st_numhash);
      st_insert(st_connected_points, (char *)points[0], (char *)1);

      // this is for starting point looking up. If the point found is falling inside
      // this hash table, then it is considered a closed boundary is found.
      // right now, the neighbor-hood is 3x3 mask.
      st_table *st_starting_points = st_init_table(st_numcmp, st_numhash);
      for (int i = -3; i < 4; i ++)
         for (int j = -3; j < 4; j ++)
            st_insert(st_starting_points, (char *)index(x_2nd+i, y_2nd+j), (char *)1);
   
      int x0 = x, y0 = y ;                  // the starting point of the data
      int p1 = points_aux->end_points[point_index];
      int x1 = x_axis(p1), y1 = y_axis(p1); // the ending point of the pivot axis.

      // ISSUE: when doing multiple resolution of the BPA, the P1, i.e., the end point for direction,
      //        might be not the same. For example, the first P1 is from the basic BPA, but the next one
      //        could from the first refinement. THEREFORE, we need to record the radius in POINTS_AUX as well.
      int rad_old = points_aux->radius[point_index];
      x1 = (int) (0.5 + x0 + ((double)rad/(double)rad_old*(x1 - x0)));
      y1 = (int) (0.5 + y0 + ((double)rad/(double)rad_old*(y1 - y0)));
      
      int direction = -1;        // -1 is clock-wise, 1 is counter clock-wise.
      static int counter = 0;
      int local_counter = 0;
      // for debug only
      // x0 = 294;  y0 = 392;
      // x1 = 292;  y1 = 432;
      // direction = 1;
      // end
      double pace_degree = 1.;
      int starting_x0 = x0, starting_x1 = x1;
      int starting_y0 = y0, starting_y1 = y1;
      int color_switch = 0;
      int looked_num = 0;               // record how many times we have seen
      while (local_counter < MAX_REFINE_NUMBER)
      {
         bool found = false;

         counter ++;
         local_counter ++;
         my_printf("\nNo[%3d]:", counter);

         // st_single_pivot is used to record a single pivot of the data point
         // That is, a record of old points visited.
         st_table *st_single_pivot = st_init_table(st_numcmp, st_numhash);

         // start pivot/rolling around a point, until a point is touched.
         double scan_angle = 0;
         double orig_angle = 0.0;
         vector<int> data_points;

         //assert(x1 != x0 || y1 != y0);
         if (x1 == x0 && y1 == y0)
            break;
         // compute the line with 10 degree from the orignal line
         if (x0 == x1)
            orig_angle = y0 > y1 ? 90.0 : -90.0;
         else
         {
            // here, we assume the angle is from right-bound x axis to the L(P0-P1)
            // counter-clock wise is positive (0 - 180), clock-wise is negative (-0.0 - -180.0)
            orig_angle = (atan((double)(-1)*(y1-y0)/(double)(x1-x0))) * 180.0 / PI;

            if (y1 < y0 && orig_angle < 0)
               orig_angle += 180.0;
            else if (y1 > y0 && orig_angle > 0)
               orig_angle -= 180.0;
            else if (y1 == y0 && x1 > x0)
               orig_angle = 0.0;
            else if (y1 == y0 && x1 < x0)
               orig_angle = direction * 180.0;
         }

         // This is used to check whether the ball is turning around, which should be avoided and stopped.
         // The solution is to maintain a circle array, say size of 5 (a parameter).
         // If the new position has a normal has a diffenrent angle large than a threshold with any of the angle
         // in the circle array, we consider this new one is reached a turning point.
         if (looked_num == 0)
         {
            looked_angle[looked_num ++] = orig_angle;
         }
         else
         {
            int ret = ball_turning_around_check( looked_num, look_ahead_num, looked_angle, orig_angle);
            if ( ret )
            {
               if (DEBUG_BPA)
               {
                  printf("########################################\n");
                  printf("#####BPA Ref###### Found a Turning on %d\n", counter);
                  printf("########################################\n");
               }

               break; // break the while (true) to continue the next point
            
            } else {

               looked_angle[looked_num++ % look_ahead_num] = orig_angle;
            }

         }

         my_printf("==<P1_P0_X>[%4.2f], P0[%3d,%3d], P1[%3d,%3d]", orig_angle, x0, y0, x1, y1);

         int last_x1 = x1, last_y1 = y1;
         int last_x0 = x0, last_y0 = y0;

         ///////////////////////////////////////////////////////
         ///////////////////////////////////////////////////////
         if (gbl_opts->BPA_refine_speed_up == 0) {

            while (scan_angle < 360)
            {
               // use double to get more accurate value
               // *1_prime is the end point
               // *_prime  is the middle point, i.e., the center of the circle.
               double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
               double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
               int y_prime = (int)((y1_prime + y0)/2);
               int x_prime = (int)((x1_prime + x0)/2);

               // test the data in this new area.
               // vector<int> *arc_area = new vector<int>;
               // vector<int> *arc_area = arc_region(x0, y0, last_x1, last_y1, pace_degree, 2*rad, direction);
               // vector<int> *cir_area = new vector<int>;


               // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
               // be touch too early.
               vector<int> *cir_area = arc_region(x_prime, y_prime, (int)x1_prime, (int)y1_prime, 180, rad-1, direction, cur_im);
               //vector<int> *cir_area = arc_region(x_prime, y_prime, x0, y0, 360);
               //vector<int> *arc_area = arc_region(x0, y0, last_x1, last_y1, scan_angle);

               last_x1 = (int)x1_prime;
               last_y1 = (int)y1_prime;

               vector<int> *test_vec = new vector<int>;
               /*
                 for (int i = 0; i < arc_area->size(); i++)
                 if (!st_is_member(st_single_pivot, (char *)((*arc_area)[i])))
                 {
                 st_insert(st_single_pivot, (char *) ((*arc_area)[i]), (char *) 1);
                 test_vec->push_back((*arc_area)[i]);
                 }
               */
               for (int i = 0; i < cir_area->size(); i++)
                  if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
                  {
                     st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
                     test_vec->push_back((*cir_area)[i]);
                  }

               // if data found, calculate the center of the circle, compare all the centers.
               // vector<int> *tmp = find(cur_im[0], test_vec, BLACK);
               data_points = *test_vec;

               /* if do debug_image, comment the 3 lines out
                  delete test_vec;
                  delete arc_area;
                  delete cir_area;
               */

               for (int i = 0 ; i < data_points.size(); i++)
                  if (st_is_member(st_connected_points, (char *) data_points[i]))
                  {
                     if (local_counter > 10 && data_points[i] == starting_point)
                        continue;
               
                     data_points.erase(data_points.begin() + i);
                     i--;
                  }

               // if do debug_image, comment the 3 lines out
               //delete arc_area;
               delete test_vec;
               delete cir_area;

               if (data_points.size() > 0)
               {
                  found = true;
                  my_printf("==@ degree %3f", scan_angle);
                  //draw_debug_image(*cir_area, counter);

                  break;
               }
            
               // else, go back to while with scan_angle += 10;
               scan_angle += pace_degree;

            } // end of while (angle < 360)

         }
         else {

            // this is refinement speedup, sometimes is not so accurate.
            ball_pivot_touch_data_refine(scan_angle, data_points, last_x1, last_y1, found, rad, orig_angle,
                                         direction, x0, y0, pace_degree, cur_im, local_counter, starting_point,
                                         st_single_pivot, st_connected_points);
         }

         // some sanity check here
         st_free_table(st_single_pivot);

      
         // if no data found, or direction has been reversed, consider revise point.
         if (!found)
         {
            my_printf("\n ####BREAK### No data found !\n");
            break;
         }

         // new data was found, find the smallest angle 
         // if found new data, add the new data into points, and st_connected_points
         // check if this new added data is already in the st_connected_points, if so, means the job is done.
         double smallest_angle = 2*PI+.1; // here, we add .1 to avoid assert error on LINUX only / no problem on Windows.
         int result_center;
         int result_point = -1;
         bpa_compute_connect(data_points, result_point, smallest_angle, result_center, rad, x0, y0, x1, y1, direction, scan_angle);
         assert(result_point != -1);


         // Move this section above the 2nd check for computing the (x1, y1);
         // when a new point is located, record the point itself, and the line between this
         // point and the center of the circle, which will be treated as a new starting point.
         // (x0, y0) - pivot point
         // (x1, y1) - arc end point
      
         st_insert(st_connected_points, (char *) result_point, (char *)1);
         insert_points.push_back(result_point);
         x0 = x_axis(result_point);
         y0 = y_axis(result_point);

         double center_y = y_axis(result_center);
         double center_x = x_axis(result_center);

         y1 = (int)(y0 - 2*(y0 - center_y));
         x1 = (int)(x0 - 2*(x0 - center_x));
         insert_points_aux->end_points.push_back(index(x1,y1));

         my_printf("==new P0[%3d,%3d], P1[%3d,%3d]", x0, y0, x1, y1);

         // draw the new circle for debug
         if (DEBUG_BPA)
            draw_circle(debug_im, (int) center_x, (int) center_y, rad);
         if (DEBUG_BPA && counter % sep_num == 0)
         {
            if ((gbl_opts->min_debug == gbl_opts->max_debug) ||
                ((counter >= gbl_opts->min_debug && gbl_opts->min_debug > 0) ||
                 counter <= gbl_opts->max_debug))
            {
               char fn[100];
               char *ds = digit_string(4, counter);
               strncpy(fn, output_fn, strlen(output_fn) - 4);
               fn[strlen(output_fn) - 4] = 0;
               sprintf(fn, "bpa_debug_refine_rad_%d__%s.png", rad, ds);
               free(ds);
               Save2File(fn, debug_im, NULL, image_width, image_height, 0, NULL);
            }
         }

         // free the arc_region at the end of loop.
         
         // 2nd check if we have reached the 2nd point of the line segment
         // if so, meaning we have pivoted the smaller ball from the starting point (x_1st, y_1st) to
         // the end point (x_2nd, y_2nd), so we need to insert the intermedia points, i.e., insert_points
         // into the points at proper positions.
         {
            if (st_lookup(st_starting_points, (char *)result_point, (char **)NULL))
            {
               // now insert the small points inside of the points
               // we might ignore the 2nd point in the points for it is from the old ball.
               for (int i = insert_points.size() - 1 ; i >= 0; i --)
               {
                  points.insert(points.begin() + point_index + 1, insert_points[i]);

                  // have to pad some aux in points_aux->end_points to make them equal length.
                  // Also this might be useful for further refinement.
                  points_aux->end_points.insert(points_aux->end_points.begin() + point_index + 1, insert_points_aux->end_points[i]);
                  points_aux->radius.insert(points_aux->radius.begin() + point_index + 1, rad);

                  // color insertion: we want to insert a new point with color different from both points.
                  // invariant: c1 + c2 + color = 3;
                  int c1 = points_aux->colors[point_index];
                  int c2 = points_aux->colors[point_index+1];
                  assert(c1 != c2);
                  assert(c1 > -1 && c1 < 3);
                  assert(c2 > -1 && c2 < 3);
                  int color = 3 - (c1 + c2);
                  points_aux->colors.insert(points_aux->colors.begin() + point_index + 1, color);
               }

               // adjust the index, sine we removed one (-1), and inserted a list (size()).
               point_index += insert_points.size();

               my_printf("\n ####BREAK### Find the 2nd point. counter: %d, x0 %d, y0 %d\n", counter, x0, y0);

               break;
            }
         }
      
         // 3rd check if we have reached the boundary starting point.
         // if so, meaning we have pivoted the smaller ball from the starting point (x_1st, y_1st) to
         // the boundary starting point, so we need to break the line, and insert a new boundary
         // into the boundary_array. And do proper processing accordingly.
         if (gbl_opts->refine_ignore_mutli_boundaries == 0)
         {
            // here > 10 to avoid itself, >4 to avoid some strange results where the boundaries are lost when rad is equal to 2 or 1.
            //if (local_counter > 10 && rad > 4 && st_lookup(st_boundary_starting_points, (char *)result_point, (char **)NULL))
            // here local_counter is not good since it is the counter of the refine number, not the index points we have visited.
            // this fixed case 12, where the last pivot is less than 10, but the accumulated index pts are much larger.
            // However, the fix undermine the final cases, where index pts is less than 10. so we can do either.
            // Also, we should create a new boundary if this boundary is splitted already,
            // and the remain part of index points is larger than a threshold, say 10 points. This fixed a bunch of cases, like 372, etc.
            if ((local_counter > 10 || raw_idx_pts_num > 10) &&
                rad >= 16 &&
                st_lookup(st_boundary_starting_points, (char *)result_point, (char **)NULL))
            {

               my_printf("\n ####BREAK### Find a sub boundary. counter: %d, local_counter:%d\n", counter, local_counter);
               
               // set this flag, so it will reset the st_boundary_starting_points.
               is_boundary_splitted = 1;
               is_boundary_starting_point = 1;
               raw_idx_pts_num = 0;
               st_free_table(st_boundary_starting_points);
               st_boundary_starting_points = st_init_table(st_numcmp, st_numhash);

               // check whether we need to do initilization at this point
               if (new_boundary_array == NULL)
               {
                  assert(!new_boundary_array_aux && !replaced_index);
                  new_boundary_array = array_alloc(deque<int> *, 0);
                  new_boundary_array_aux = array_alloc(POINTS_AUX *, 0);
                  replaced_index = new vector<int>;
               }

               // first insert the points and aux into new points deque;
               deque<int> *new_points = new deque<int>;
               POINTS_AUX *new_points_aux = new POINTS_AUX;
               for (int i = boundary_starting_index; i <= point_index; i ++)
               {
                  new_points->push_back(points[i]);
                  new_points_aux->end_points.push_back(points_aux->end_points[i]);
                  new_points_aux->radius.push_back(points_aux->radius[i]);
                  new_points_aux->colors.push_back(points_aux->colors[i]);
               }

               // BUG: for a 8-circle slice, the generated txt contains 10 - 15 circles, though
               //      it only shows 8 circles on the output image. This will cause problem when
               //      as input for sketchup.
               // REASON: the next point is too close to the current point, which belongs to the
               //         current circle.
               // Solution: Remove those close adjunct points.
               // This does NOT work - since the 4th circle is blocked. The problems are:
               // 1. the same circle may not be adjunct points.
               // 2. if we remove all closed points, the end point may also be removed, which produced a circle like - D
               //    that is, only half circle, since the end point is reached.

               /*
               int x_old = x_axis(points[point_index]);
               int y_old = y_axis(points[point_index]);
               int check_len = points.size();
               printf("BPA: Breaking boundary around [%d, %d], next [%d, %d]...\n", x_old, y_old, x_2nd, y_2nd);
               for (int i = point_index + 1; i < check_len ; i ++ )
               {
                  int x_test = x_axis(points[i]);
                  int y_test = y_axis(points[i]);

                  double x_dis = (double)(x_test - x_old);
                  double y_dis = (double)(y_test - y_old);
                  double dis = sqrt(x_dis*x_dis + y_dis*y_dis);

                  if ( dis > gbl_opts->BPA_boundary_break_len )
                     continue;

                  points.erase(points.begin() + i);
                  points_aux->end_points.erase(points_aux->end_points.begin() + i);
                  points_aux->radius.erase(points_aux->radius.begin() + i);
                  points_aux->colors.erase(points_aux->colors.begin() + i);

                  check_len = points.size();
                  i --;
                  printf("BPA: Erase extra point [%d, %d],  around [%d, %d]\n", x_test, y_test, x_old, y_old);
               }
               */
               
               // now insert the new found points inside of the points (partial points).
               // we might ignore the 2nd point in the points for it is from the old ball.
               int color = points_aux->colors[point_index];
               for (int i = 0; i < insert_points.size(); i++)
               {
                  new_points->push_back(insert_points[i]);

                  // have to pad some aux in points_aux->end_points to make them equal length.
                  // Also this might be useful for further refinement.
                  new_points_aux->end_points.push_back(insert_points_aux->end_points[i]);
                  new_points_aux->radius.push_back(rad);
                  color = (color + 1) % 3;
                  new_points_aux->colors.push_back(color);
               }

               // Finally, let's put this into arrays
               // With some CONDITIONS: If a similar boundary has already been created, ignore this one.
               // To check this, we can compare the size of the boundary and the centroid of the boundary.
               // BUG: for a 8-circle slice, the generated txt contains 10 - 15 circles, thought
               //      it only shows 8 circles on the output image. This will cause problem when
               //      as input for sketchup.
               // REASON: the next point is too close to the current point, which belongs to the
               //         current circle.
               // Solution: compare the centroid of a new boundary with existed boundaries.
               bool is_qualified = true;
               int total_x = 0, total_y = 0;
               for (int i = 0; i < new_points->size(); i ++)
               {
                  total_x += x_axis(new_points->at(i));
                  total_y += y_axis(new_points->at(i));
               }
               double centroid_x = total_x/new_points->size();
               double centroid_y = total_y/new_points->size();
               
               deque<int> * test_points;
               int k;
               arrayForEachItem(deque<int> *, new_boundary_array, k, test_points) {
                  if ( abs((int)( test_points->size() - new_points->size()) ) > gbl_opts->BPA_boundary_break_len / 2)
                     continue;
                  
                  total_x = 0; total_y = 0;
                  for (int i = 0; i < test_points->size(); i ++)
                  {
                     total_x += x_axis(test_points->at(i));
                     total_y += y_axis(test_points->at(i));
                  }
                  double centroid_test_x = total_x/test_points->size();
                  double centroid_test_y = total_y/test_points->size();

                  double diff_x = centroid_test_x - centroid_x;
                  double diff_y = centroid_test_y - centroid_y;
                  if ( sqrt(diff_x*diff_x + diff_y*diff_y) < gbl_opts->BPA_boundary_break_len )
                     is_qualified = false;
               }
               
               if ( is_qualified ) {
                  array_insert_last(deque<int> *, new_boundary_array, new_points);
                  array_insert_last(POINTS_AUX *, new_boundary_array_aux, new_points_aux);
                  if ( gbl_opts->BPA_clear_data_for_new_boundary)
                     clear_data_for_new_boundary(cur_im, new_points, rad);
               }

               // if we already insert this index, don't do it again.
               if (replaced_index->size() == 0 || replaced_index->back() != current_points_index )
                  replaced_index->push_back(current_points_index);

               break; // break the while loop
            }
         }


      } // end of while (true)

   } //end of for.


   // create another boundary if we have already splitted the boundary, and the remaining part
   // is big enough for a new boundary.
   if (gbl_opts->BPA_keep_remaining_boundary_point_after_split && is_boundary_splitted && points.size() - boundary_starting_index > 10 )
   {

      // we don't need to initilize any more.
      assert(new_boundary_array);
      assert(new_boundary_array_aux);
      
      // first insert the points and aux into new points deque;
      deque<int> *new_points = new deque<int>;
      POINTS_AUX *new_points_aux = new POINTS_AUX;
      for (int i = boundary_starting_index; i < points.size(); i ++)
      {
         new_points->push_back(points[i]);
         new_points_aux->end_points.push_back(points_aux->end_points[i]);
         new_points_aux->radius.push_back(points_aux->radius[i]);
         new_points_aux->colors.push_back(points_aux->colors[i]);
      }

#if 0
      /* This section is useless since we assume the insert_points is not good if the program
         can reach this point.
      */
      
      // now insert the small points inside of the points
      // we might ignore the 2nd point in the points for it is from the old ball.
      int color = points_aux->colors[point_index];
      for (int i = 0; i < insert_points.size(); i++)
      {
         new_points->push_back(insert_points[i]);

         // have to pad some aux in points_aux->end_points to make them equal length.
         // Also this might be useful for further refinement.
         new_points_aux->end_points.push_back(insert_points_aux->end_points[i]);
         new_points_aux->radius.push_back(rad);
         color = (color + 1) % 3;
         new_points_aux->colors.push_back(color);
      }
#endif       

      // Finally, let's put this into arrays
      array_insert_last(deque<int> *, new_boundary_array, new_points);
      array_insert_last(POINTS_AUX *, new_boundary_array_aux, new_points_aux);
   }
   
}


/*
  Function: BPA_image_translation

  This is used to translate orignal image for ball pivoting
  
  The global var image_height/image_width should also be changed.
 */
BYTE** BPA_image_translation(BYTE **cur_im, int rad)
{
   int h = image_height;
   int w = image_width;

   int offset = 2*rad + 4; // 4 pixel for buffering for each side
   image_height += 2 * offset;
   image_width  += 2 * offset;
   
   BYTE **new_im = new_image(image_height, image_width);

   for (int y = 0; y < h; y ++)
      for (int x = 0; x < w; x ++)
         new_im[y+offset][x+offset] = cur_im[y][x];

   free_image(cur_im);

   return new_im;
}

BYTE ** draw_boundaries_on_image(array_t *arr_all_boundaries, int rad)
{
   int offset = 2*rad + 4;
   int image_h = image_height - 2*offset;
   int image_w = image_width  - 2*offset;

   BYTE **im = new_image(image_h, image_w);

   int k, index;
   deque<int>  *points_const;
   array_t *boundary_array;
   arrayForEachItem(array_t *, arr_all_boundaries, index, boundary_array) {
      arrayForEachItem(deque<int> *, boundary_array, k, points_const) {
         for (int i=0; i < points_const->size()-1; i ++)
         {
            int x1 = x_axis((*points_const)[i]) - offset;
            int y1 = y_axis((*points_const)[i]) - offset;
            int x2 = x_axis((*points_const)[i+1]) - offset;
            int y2 = y_axis((*points_const)[i+1]) - offset;
            draw_line_on_2D_image(im, image_h, image_w, x1, y1, x2, y2);
         }
      }
   }

   return im;
}

void dump_boundaries_to_file(array_t *arr_all_boundaries, int rad, FILE *fd)
{
   int offset = 2*rad + 4;
   int image_h = image_height - 2*offset;
   int image_w = image_width  - 2*offset;

   int k, index;
   deque<int>  *points_const;
   array_t *boundary_array;
   arrayForEachItem(array_t *, arr_all_boundaries, index, boundary_array) {
      arrayForEachItem(deque<int> *, boundary_array, k, points_const) {
         for (int i=0; i < points_const->size()-1; i ++)
         {
            int x1 = x_axis((*points_const)[i]) - offset;
            int y1 = y_axis((*points_const)[i]) - offset;
            int x2 = x_axis((*points_const)[i+1]) - offset;
            int y2 = y_axis((*points_const)[i+1]) - offset;
            fprintf(fd, "%d %d\n%d %d\n", x1, image_h - y1, x2, image_h - y2);
         }
      }
   }
}

void draw_boundary_image(array_t *boundary_array, array_t *boundary_array_aux, int rad, char *fn)
{
   // draw the final image
   // should also translate back to orignal image size.
   // But it won't work if we change the two global vars. (image is messed up).

   int offset = 2*rad + 4;
   int image_h = image_height - 2*offset;
   int image_w = image_width  - 2*offset;

   /*BUG: we did NOT copy the points but change the value of points directly.
     By doing this way, we cannot reuse the value of the points, which store
     the boundary information of the points. So here we make a copy to fix the bug.
    */
   vector<int> lines;
   deque<int>  *points_const;
   vector<int> colors;
   POINTS_AUX  *pa;
   int k;
   arrayForEachItem(deque<int> *, boundary_array, k, points_const) {

      if ( boundary_array_aux ) {
         pa = array_fetch(POINTS_AUX *, boundary_array_aux, k);
         assert(points_const->size() == pa->colors.size());
      }

      for (int i=0; i < points_const->size()-1; i ++)
      {
         lines.push_back(x_axis((*points_const)[i])-offset);
         lines.push_back(y_axis((*points_const)[i])-offset);
         lines.push_back(x_axis((*points_const)[i+1])-offset);
         lines.push_back(y_axis((*points_const)[i+1])-offset);
         // here if BPA_debug_color_boundary is set, all lines in the same boundary share the same color, otherwise,
         // each line segment uses a RGB color
         if (gbl_opts->BPA_debug_color_boundary || boundary_array_aux == NULL)
            colors.push_back(k % 3);
         else
            colors.push_back(pa->colors[i]);
            
      }

   }

   if (fn == NULL)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_radius_%d.png", de_fn, rad);
      fn = de_fn;
   }

   write_lines_to_image(fn, lines,  image_h,  image_w, &colors);
   
   printf("\n\n$$$$$$For %s: total %d bounaries!$$$$$\n\n", fn, array_n(boundary_array));
   
}

void load_options(char *string, int& argc, char **argv)
{
   char seps[]   = " ";
   char *token;
   {
      // we have to set argv[0] to sth.
      argv[argc++] = "Tokens";
      /* Establish string and get the first token: */
      token = strtok( string, seps );
      while( token != NULL )
      {
         /* While there are tokens in "string" */
         argv[argc++] = strdup(token);
         /* Get next token: */
         token = strtok( NULL, seps );
      }

      assert(argc < 60);
   }      

}


// Function: BPA_search_for_closest_boundary
// a helper function for <BPA_check_local_match>
int BPA_search_for_closest_boundary(BYTE **bo_im, vector<int> &points, int &pos, int mode)
{
   // let assume if this line has replace, it should be in 3x3 or 5x5?
   int mask = 5;
   int x0, y0;
   int point_idx;

   // let assume there is only one point closest to this point.
   // here, we want to make sure that it search smaller region first
   if (mode == 0) // forward
   {
      for (int j = 0; j < points.size(); j ++)
      {
         x0 = x_axis(points[j]);
         y0 = y_axis(points[j]);
         for (int i = 0; i < mask+1; i ++) // here must start from 0!!!, instead of 1.
         {
            for (int x = -mask; x < mask+1; x ++)
            {
               if (abs(x) != i) continue;
            
               for (int y = -mask; y < mask+1; y++)
               {
                  if (abs(y) != i) continue;

                  if (bo_im[y0+y][x0+x] == BLACK)
                  {
                     pos = points[j];
                     my_printf("x: %d, y: %d, mode: 0", x_axis(pos), y_axis(pos));
                     int point_tmp = index(x0 + x, y0 + y);
                     return point_tmp;
                  }
               }
            }
         }
      }
   }

   if (mode == 1) // backword
   {
      for (int j = points.size() - 1; j >= 0; j --)
      {
         x0 = x_axis(points[j]);
         y0 = y_axis(points[j]);
         for (int i = 0; i < mask+1; i ++)
         {
            for (int x = -mask; x < mask+1; x ++)
            {
               if (abs(x) != i) continue;
            
               for (int y = -mask; y < mask+1; y++)
               {
                  if (abs(y) != i) continue;

                  if (bo_im[y0+y][x0+x] == BLACK)
                  {
                     pos = points[j];
                     my_printf("x: %d, y: %d, mode: 0", x_axis(pos), y_axis(pos));
                     int point_tmp = index(x0 + x, y0 + y);
                     return point_tmp;
                  }
               }
            }
         }
      }
   }

   return -1;
}

/* Function: BPA_check_local_match

   compute a closest boundary points in pts2index around the point point_comp, a helper function for <combine_HT_with_BPA>

   Return:
      0 - could not find such a boundary point
      otherwise, the index of the boundary point

   Potential issue: may have index out of boundary problem.
   
 */
int BPA_check_local_match(BYTE **bo_im, int point_1, int point_2, int &loc1, int &loc2, int &pos1, int &pos2, BYTE **im)
{
   int x0 = x_axis(point_1);
   int y0 = y_axis(point_1);
   int x1 = x_axis(point_2);
   int y1 = y_axis(point_2);

   vector<int> pixels = (*pixels_between_2_points(image_height, image_width, x0, y0, x1, y1));

   int counter = 0;
   int total_num = pixels.size();
   for (int i = 0; i < total_num; i ++)
      if (im[y_axis(pixels[i])][x_axis(pixels[i])] == BLACK)
         counter ++;

   if ((double)counter/(double)total_num < .9)
      return 0;


   loc1 = BPA_search_for_closest_boundary(bo_im, pixels, pos1, 0);
   loc2 = BPA_search_for_closest_boundary(bo_im, pixels, pos2, 1);

   if (loc1 == -1 || loc2 == -1 || loc1 == loc2 )
   {
      // do something?
      return 0;
   }

   //assert(loc1 != loc2);

   return 1;
   
}

/* Function: combine_HT_with_BPA

   Try to combine the result of HT and BPA, namely "beautify" the boundary image.

   Algorithm:

      1. get the HT lines.
      2. translate the coordinates for BPA reference.
      3. check the cloese points and replace them using HT lines.
   
 */
void combine_HT_with_BPA(char *fn, int rad, BYTE **orig_im, array_t *boundary_array, array_t *boundary_array_aux, BYTE **bo_im)
{
   char de_fn[1000];
         
   // do HT to get points. hough_transform
   int pdetect;
   int tetadetect;
   vector<int> temp;      
   vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
   
   int offset = 2*rad + 4;
   int h = image_height;  // translate it back to original size.
   int w = image_width;

   BYTE **Imbinary = copy_image(orig_im, h, w);
   while (true)
   {
      my_HT(Imbinary, h, w, pdetect, tetadetect);

      // draw line on the image
      draw_line_on_data(pdetect, tetadetect, Imbinary, h, w, NULL, orig_im, line_set);

      temp = find(*Imbinary,h*w, BLACK);
      if (temp.size() == 0) break;
   }

   // debug the HT results
   if (DEBUG_BPA)
   {
      sprintf(de_fn, "%s_HT_result.png", fn);
      write_lines_to_image(de_fn, line_set, h, w);
   }

   // check the length of the HT lines and translate the HT points coordinate.
   vector<int> HT_length;
   vector<int> replace_lines;
   map<double, int> dummy;
   compute_length(line_set, HT_length, dummy, THRES_HT_BPA_COMBINE_LEN*THRES_HT_BPA_COMBINE_LEN);

   // Actually, this has been sorted. KEEP IN MIND
   for (int i = 0 ; i < HT_length.size(); i ++)
   {
      int x1 = line_set[HT_length[i]]  ;
      int y1 = line_set[HT_length[i]+1];
      int x2 = line_set[HT_length[i]+2];
      int y2 = line_set[HT_length[i]+3];

      replace_lines.push_back(index(x1, y1));
      replace_lines.push_back(index(x2, y2));
   }

   // After HT, the line segments have been sorted from longer to shorter. Choose a threshold (40 pixels) to rule out short lines.
   // Now, the HT lines are stored in replace_lines, and ready to be used as a substitutions for BPA points.
   // A dilation image of the BPA skeleton has been generated, the width is define by HT_MASK in clear_data() function. This image
   // is used as a reference, in which each HT lines is mapped back. By counting what percentage of the pixles on HT line are falling
   // inside the dilation image, this HT line is determined whether it should be used as a substitution or not. If half of its points (.5)
   // is falling inside the dark dilation region, it is chosen.
   // If a HT line is chosen to replace BPA points, two closest BPA points are computed with respect to the two end points of this HT line.
   // The HT line pixels are checked from both sides, until a pixel is found to close enough to a BPA point. There two new pixels on the HT line
   // are determined, so that extra points of HT line can be eliminated. All these have been done in BPA_check_local_match().
   // The rest of the task is to maintain the points structure, so that the order of the boundary points are preserved. To do this, three extra
   // vars are introduced:
   //   pts2idx - a hash table mapping a BPA point to its index in the points (deque<int>). This is useful when a closest BPA point is found for
   //             HT end point, this end point will be added into the final boundary (by adding this BPA point with this end point indirectly -
   //             using idx2pts map the index to the position).
   //   idx2pts - a hash table mapping an index (of a BPA point which is very close to end points of HT line) to a HT point coordinates.
   //   mark    - a vector to indicate whether the BPA points (by index) in points has been elimated or not.

   
   // construct a hash table for looking up the mask points around the HT points.*/
   int k;
   deque<int>  *points;
   vector<int> final_lines;
   vector<int> colors;
   POINTS_AUX  *pa;   
   arrayForEachItem(deque<int> *, boundary_array, k, points) {

      int points_size = points->size();
      vector<int> mark(points_size);
      for (int i = 0; i < points_size; i++)
         mark[i] = 0;

      st_table *pts2idx = st_init_table(st_numcmp, st_numhash);
      for (int i = 0 ; i < points_size; i ++)
         st_insert(pts2idx, (char *)(*points)[i], (char *)i);

      st_table *idx2pts = st_init_table(st_numcmp, st_numhash);
      
      // highlight the boundary - dilation image generation.
      BYTE **im = new_image(h, w);
      for (int i = 0; i < points_size-1; i ++)
      {
         int x1 = x_axis((*points)[i])  ;
         int y1 = y_axis((*points)[i])  ;
         int x2 = x_axis((*points)[i+1]);
         int y2 = y_axis((*points)[i+1]);

         draw_line_and_clear_data(NULL, h, w,
                                  (int)x1, (int)y1,(int) x2,(int) y2,
                                  0, 0, 0, im,
                                  BLACK);

      }
      
      // now do the replacement in the points.
      int counter = 0;
      int need_special_treat = 0;
      for (int i = 0; i < replace_lines.size(); i += 2)
      {
         /*
           bo_im: image marked by IR lines.
           loc1: the index/location of the vertex in bo_im closest to replaced line pixel in pos1.
           pos1: the matched pixel which is closest to a vertex in bo_im.
          */
         int loc1, loc2;
         int pos1, pos2;
         int found = BPA_check_local_match(bo_im, replace_lines[i], replace_lines[i+1], loc1, loc2, pos1, pos2, im);

         counter++;

         // printf("HT line [%d, %d] -> [%d, %d] is %s\n", x_axis(replace_lines[i]), y_axis(replace_lines[i]), x_axis(replace_lines[i+1]), y_axis(replace_lines[i+1]), found ? "matched" : "NOT matched");
                
         // if found, then remove this line out of the vector, also simply the points
         if (found)
         {
            // remove this line from the replace_lines
            replace_lines.erase(replace_lines.begin() + i);
            replace_lines.erase(replace_lines.begin() + i);
            i -= 2;

            int idx1, idx2;

            // This assertion is not an invariant any more after considering the splitting.
            // If two points do not belong to the same boundary, let's ignore this one.
            if (!st_lookup(pts2idx, (char *)loc1, (char **)&idx1) ||
                !st_lookup(pts2idx, (char *)loc2, (char **)&idx2))
            {
               // printf(" ignore by assertion\n");
               continue;
            }

            loc1 = idx1; loc2 = idx2;
            // printf("loc1: %d, loc2: %d, total points %d\n", loc1, loc2, points->size());
            
            // make sure loc1 is smaller than loc2
            if (loc1 > loc2) //switch both location and boundary points.
            {
               int temp = loc1;
               loc1 = loc2; loc2 = temp;
               temp = pos1;
               pos1 = pos2; pos2 = temp;
            }

            // observation: the # of replaced points are always significantly less than the total #
            int num1 = loc2 - loc1;
            int num2 = loc1 + (points->size() - loc2);

            int marked = 0;
            if (num1 < num2 || gbl_opts->BPA_no_circle_when_replace_with_HT) // means a regular replacement
            {
               // if any of the middle points has been marked, ignore this line (longer line has been applied).
               // this has fixed some problem, but the lines still has problem - twisted.
               int total_marked = 0;
               for (int index = loc1 ; index <= loc2; index ++)
                  if (mark[index]) total_marked ++;

               if (total_marked > 3) {
                  // printf(" ignore due to %d/%d marked in regular case\n", total_marked, loc2-loc1);
                  continue;
               }

               for (int index = loc1; index <= loc2; index ++)
                  mark[index] = 1;
               st_insert(idx2pts, (char *)(loc1), (char *)pos1);
               st_insert(idx2pts, (char *)(loc2), (char *)pos2);
               //st_insert(idx2pts, (char *)(loc2-1), (char *)pos2);


            } else {   // means a complicate case, like 365,366,...388|0,1,2...  (2, 365)
            
               // if any of the middle points has been marked, ignore this line (longer line has been applied).
               int total_marked = 0;
               for (int index = loc2; index < points->size(); index ++)
                  if (mark[index]) total_marked ++;

               for (int index = 0; index < loc1; index ++)
                  if (mark[index]) total_marked ++;

               if (total_marked > 3) {
                  // printf(" ignore due to %d/%d marked in complicated case\n", total_marked, loc1 + (points->size() - loc2));
                  continue;
               }

               for (int index = loc2; index < points->size(); index ++)
                  mark[index] = 1;

               for (int index = 0; index <= loc1; index ++)
                  mark[index] = 1;

               // a potential bug here, since this wont' pass to the final_points array.
               st_insert(idx2pts, (char *)(loc1), (char *)pos1);
               st_insert(idx2pts, (char *)(loc2), (char *)pos2);

               need_special_treat = 1;
            }

         }
         
      }
      
      vector<int> final_points;
      pa = array_fetch(POINTS_AUX *, boundary_array_aux, k);
      assert(points->size() == pa->colors.size());
      for (int i = 0; i < points->size(); i ++)
      {
         int pos;
         if (mark[i] != 1)
         {
            final_points.push_back((*points)[i]);
            colors.push_back(pa->colors[i]);
         }
         
         if (st_lookup(idx2pts, (char *)i, (char **)&pos))
         {
            final_points.push_back(pos);
            colors.push_back(pa->colors[i]);
         } else {
            // assert(0); // a point is either unmarked (not replaced by HT line), or is replaced by a HT end point, or removed here.
         }
        
      }
      // insert the first point as a closed boundary?
      // final_points.push_back(final_points[0]);

      // has to pop out a color
      if (need_special_treat)
      {
         final_points.push_back(final_points[0]);
      }else {
         colors.pop_back();
      }


      for (int i = 0; i < final_points.size() - 1; i ++)
      {
         final_lines.push_back(x_axis(final_points[i])  );
         final_lines.push_back(y_axis(final_points[i])  );
         final_lines.push_back(x_axis(final_points[i+1]));
         final_lines.push_back(y_axis(final_points[i+1]));
      }

      final_points.clear();
   }

   {
      if (final_lines.size() == 0)
      {
         printf("There is no line found to be combined for file %s\n", fn);
         return;
      }

      {
         strncpy(de_fn, output_fn, strlen(output_fn) - 4);
         de_fn[strlen(output_fn) - 4] = 0;
         sprintf(de_fn, "%s_combine_HT_BPA_rad_%d.png", de_fn, rad);
         write_lines_to_image(de_fn, final_lines, h, w, &colors);
      }
   }            

   if ( gbl_opts->BPA_dump_the_vectors )
   {

      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_dumped_%d.txt", de_fn, 1);
      FILE *fp = fopen(de_fn, "w");
      assert(fp);

      int restart = 1;
      int x0, y0;
      fprintf(fp, "ImageSize %dx%d\n", image_width - 2*offset, image_height - 2*offset);
      for (int i = 0; i < final_lines.size(); i+=4)
      {
         if (restart) {

            // if a gap line, igore.
            if (colors[i/4] == -1)
               continue;
            
            restart = 0;
            fprintf(fp, "BEGIN POLYGON\n");
            fprintf(fp, "%d %d\n", final_lines[ i ], final_lines[i+1]);
            fprintf(fp, "%d %d\n", final_lines[i+2], final_lines[i+3]);
            x0 = final_lines[i+2];
            y0 = final_lines[i+3];
            continue;
         }

         if ((x0 == final_lines[i] && y0 == final_lines[i+1]) &&
             colors[i/4] != -1) // If a color is "-1", should be invisible.
         {
            x0 = final_lines[i+2];
            y0 = final_lines[i+3];
            fprintf(fp, "%d %d\n", x0, y0);
            continue;
         }

         // A new boundary starting point
         fprintf(fp, "END POLYGON\n");
         restart = 1;

         if (colors[i/4] != -1)
            i -= 4;

      }

      fprintf(fp, "END POLYGON\n");

      fclose(fp); // 3.24.08 found a bug, if not close, the file is empty.
      
   }
}

/* Function: BPA_remove_gap_lines

   Get rid of gap lines
   Postconditions: Keep the length and color in boundary_array_aux consistent.
 */
void BPA_remove_gap_lines(array_t *boundary_array, array_t *boundary_array_aux, int rad, int rad_new)
{
   int k;
   deque<int> *points;
   POINTS_AUX *points_aux;
   arrayForEachItem(deque<int> *, boundary_array, k, points) {
      points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
      my_printf("Remove Bef BOUNDARY %d: %d points, %d colors, %d end_points, %d radius\n", k, points->size(), points_aux->colors.size(),
             points_aux->end_points.size(), points_aux->radius.size());

      // Be careful of the image_height, image_width
      int len = points->size() - 1;
      for (int i = 0 ; i < len;  i++)
      {
         bool remove_middle = false;
         int x0 = x_axis((*points)[i]);
         int y0 = y_axis((*points)[i]);
         int x1 = x_axis((*points)[i+1]);
         int y1 = y_axis((*points)[i+1]);

         if(is_gap_line_detected_by_large_radius(x0, y0, x1, y1))
            points_aux->colors[i] = -1;
         
      }
      
      my_printf("Remove Aft BOUNDARY %d: %d points, %d colors, %d end_points, %d radius\n", k, points->size(), points_aux->colors.size(),
             points_aux->end_points.size(), points_aux->radius.size());
   }

   if (DEBUG_BPA > MID_INFO)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_refine_with_rad_%d_and_removed_gap_lines.png", de_fn, rad_new);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }         
   

}  

/* Function: BPA_reshape_boundary_points

   merge those points on the same lines, such as points on |, -, \ ,etc.
   Postconditions: Keep the length and color in boundary_array_aux consistent.
 */
void BPA_reshape_boundary_points(array_t *boundary_array, array_t *boundary_array_aux, int rad, int rad_new, BYTE **cur_im)
{
   int k;
   deque<int> *points;
   POINTS_AUX *points_aux;
   arrayForEachItem(deque<int> *, boundary_array, k, points) {
      points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
      my_printf("Reshape B BOUNDARY %d: %d points, %d colors, %d end_points, %d radius\n", k, points->size(), points_aux->colors.size(),
             points_aux->end_points.size(), points_aux->radius.size());

      // Be careful of the image_height, image_width
      int len = points->size() - 2;
      for (int i = 0 ; i < len;  i++)
      {
         bool remove_middle = false;
         int x0 = x_axis((*points)[i]);
         int y0 = y_axis((*points)[i]);
         int x1 = x_axis((*points)[i+1]);
         int y1 = y_axis((*points)[i+1]);
         int x2 = x_axis((*points)[i+2]);
         int y2 = y_axis((*points)[i+2]);

         // if this line is a gap line, ignore it;
         if (points_aux->colors[i] == -1 || points_aux->colors[i+1] == -1)
            continue;
         
         if ( x0 != x1 && gbl_opts->BPA_reshape_slope_line ) {
            // if the line is longer than say, 128, and slope is around 1, and no data points between two points,
            // reshape this line based on the minimun area creteria.
            float len = (x0 - x1)*(x0 - x1) + (y0 - y1)*(y0 - y1);
            float slope = abs( (y0 - y1) / (float)(x0 - x1));
            
            if ( slope > 0.1 && slope < 10.0
                 && i > 1
                 && len > (gbl_opts->BPA_reshape_slope_line * gbl_opts->BPA_reshape_slope_line)
                 && ! is_good_matched(cur_im, image_height, image_width, x0, y0, x1, y1, 0.2) ) {

               int x_extra, y_extra;
               /*
               // assume the key slice is from bottom up. If the y0,y1 < h/2, use larger y. else, use smaller y
               float y = (y0 + y1)/2;
               if ( y <  image_height/2 ) {
                  x_extra = y0 > y1 ? x1 : x0;
                  y_extra = y0 > y1 ? y0 : y1;
               } else {
                  x_extra = y0 > y1 ? x0 : x1;
                  y_extra = y0 > y1 ? y1 : y0;
               }
               */
               int pre_x = x_axis((*points)[i-1]);
               int pre_y = y_axis((*points)[i-1]);
               int pos_x = x_axis((*points)[(i+1)%points->size()]);
               int pos_y = y_axis((*points)[(i+1)%points->size()]);
               bool isVert2Hori = abs(pre_y - y0) > abs(pre_x - x0);
               if ( isVert2Hori ) {
                  x_extra = x0;
                  y_extra = y1;
               } else {
                  x_extra = x1;
                  y_extra = y0;
               }
               
               int new_point = index(x_extra, y_extra);
               points->insert(points->begin() + i + 1, new_point);

               // erase aux points
               points_aux->end_points.insert(points_aux->end_points.begin() + i + 1, points_aux->end_points[i]);
               points_aux->radius.insert(points_aux->radius.begin() + i + 1, points_aux->radius[i]);
               points_aux->colors.insert(points_aux->colors.begin() + i + 1, points_aux->colors[i]);

               i ++;
               len ++;
            }
         }
      }
   }
}

/* Function: BPA_merge_boundary_points

   merge those points on the same lines, such as points on |, -, \ ,etc.
   Postconditions: Keep the length and color in boundary_array_aux consistent.
 */
void BPA_merge_boundary_points(array_t *boundary_array, array_t *boundary_array_aux, int rad, int rad_new, BYTE **cur_im)
{
   int k;
   deque<int> *points;
   POINTS_AUX *points_aux;
   arrayForEachItem(deque<int> *, boundary_array, k, points) {
      points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
      my_printf("Merge B BOUNDARY %d: %d points, %d colors, %d end_points, %d radius\n", k, points->size(), points_aux->colors.size(),
             points_aux->end_points.size(), points_aux->radius.size());

      // Be careful of the image_height, image_width
      int len = points->size() - 2;
      for (int i = 0 ; i < len;  i++)
      {
         bool remove_middle = false;
         int x0 = x_axis((*points)[i]);
         int y0 = y_axis((*points)[i]);
         int x1 = x_axis((*points)[i+1]);
         int y1 = y_axis((*points)[i+1]);
         int x2 = x_axis((*points)[i+2]);
         int y2 = y_axis((*points)[i+2]);

         // if this line is a gap line, ignore it;
         if (points_aux->colors[i] == -1 || points_aux->colors[i+1] == -1)
            continue;
         
         if ( ((x0 == x1) && (x1 == x2)) ||
              ((y0 == y1) && (y1 == y2)) ||
              ((y2 - y1)*(x1 - x0) == (y1 - y0)*(x2 - x1) ) )  // same as (y2-y1)/(x2-x1) == (y1-y0)/(x1-x0)
         {
            remove_middle = true;
            points->erase(points->begin() + i + 1);

            // erase aux points
            points_aux->end_points.erase(points_aux->end_points.begin() + i + 1);
            points_aux->radius.erase(points_aux->radius.begin() + i + 1);
            points_aux->colors.erase(points_aux->colors.begin() + i + 1);
         }

         // update i and len if needed.
         if (remove_middle)
         {
            i --;
            len --;
         } 
      }
      
      my_printf("Merge A BOUNDARY %d: %d points, %d colors, %d end_points, %d radius\n", k, points->size(), points_aux->colors.size(),
             points_aux->end_points.size(), points_aux->radius.size());
   }

   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_refine_with_rad_%d_and_merged.png", de_fn, rad_new);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }         
   
}

/* Function: log_2
   return log 2
*/
int log_2(int val)
{
   int ret_val = 0;

   val -= 1;
   while (val > 0)
   {
      val /= 2;
      ret_val ++;
   }

   return ret_val;
}

int upper_bound_power_2(int val)
{

   int ret_val = log_2(val);
   
   ret_val = (int) pow(2.0, ret_val -1);
   if (ret_val < 32)
      ret_val = 32;
   
   return ret_val;
}

/* Function: BPA_rough_radius
   Get a rough radius for the image

   So far, only test from top to bottom
*/
int BPA_rough_radius(BYTE **cur_im)
{
   // only test top line gap
   int h = image_height;
   int w = image_width;
   
   // sweep from top to bottom
   int *a = new int[w];
   memset(a, 0, w*4);
   bool first_touched = false;
   int max_gap = 0;
   int walk_gap = 0;
   for (int x = 0; x < w; x ++)
   {
      int mid_pos = h / 2 + 10; // add a little offset
      for (int y = 0; y < mid_pos; y++)
      {
         if (cur_im[y][x] == BLACK)
         {
            a[x] = y;
            break;
         }
      }

      if (a[x])
      {
         if (!first_touched)
         {
            first_touched = true;
            walk_gap = 0;
            continue;
         }

         if (walk_gap > max_gap)
            max_gap = walk_gap;
         
         walk_gap = 0;
      }
      else
      {
         walk_gap ++;
      }
      
   }

   delete [] a;

   int val = upper_bound_power_2(max_gap);
   return val;

   
}

/* Function: BPA_dump_image_vectors
   Dump the image vectors into files
*/
void BPA_dump_image_vectors(array_t *boundary_array, array_t *boundary_array_aux, int mode, int rad, int offset)
{
   char de_fn[1000];
   int tmp_h, tmp_w;

   if ( gbl_opts->BPA_dump_the_vectors == 0 ) {
      return;
   }
   
   strncpy(de_fn, output_fn, strlen(output_fn) - 4);
   de_fn[strlen(output_fn) - 4] = 0;
   sprintf(de_fn, "%s_dumped_%d.txt", de_fn, mode);
   FILE *fp = fopen(de_fn, "w");
   assert(fp);

   int k;
   deque<int> *points;
   POINTS_AUX *points_aux;
   arrayForEachItem(deque<int> *, boundary_array, k, points) {
      points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);

      assert(points->size() == points_aux->colors.size());
      fprintf(fp, "ImageSize %dx%d\nBEGIN POLYGON\n", image_width - 2*offset, image_height - 2*offset);

      int pre_pt = -1; // avoid duplicated point
      for (int i = 0; i < points->size(); i++)
      {
         if ( (*points)[i] == pre_pt )
            continue;
         
         if (!gbl_opts->BPA_ignore_gap_line && points_aux->colors[i] == -1)
         {
            fprintf(fp, "END POLYGON\n");
            fprintf(fp, "BEGIN POLYGON\n");
         }
         else // MAKE SURE the image_height/image_width are correct.
            fprintf(fp, "%d %d\n", x_axis((*points)[i]) - offset, y_axis((*points)[i]) - offset);

         pre_pt = (*points)[i];
      }

      fprintf(fp, "END POLYGON\n");

   }

   fclose(fp);

}

/* Function: do_2nd_round_BPA_and_refinement

   Another round of the BPA and refinement. Basically, we will combine the first round results with this round.
   At the beginning, the data around the boundaries in the first round will be cleared.
   Restart the process to obtained the 2nd round results.

   This is particular useful when the underlying structure is complicated.
*/
void do_2nd_round_BPA_and_refinement(BYTE **&cur_im,
                                     array_t *boundary_array_1st_round,
                                     array_t *boundary_array_aux_1st_round,
                                     int rad_init)
{

   // initialize some parameter for 2nd round BPA
   GLOBAL_OPTIONS *gbl_opts_backup = gbl_opts; // backup the old parameters for 1st round
   project_init();
   load_parameter(gbl_opts_backup->BPA_2nd_round_parameter_file);
   DEBUG_BPA = gbl_opts->BPA_debug_mode;
   
   // preprocess the cur_im:
   // 1. clear the data based on the first round boundairies.
   // 2. apply HT on the remaining image, choose those line segments longer than a threshold
   // 3. keep the data "connected" to the line segments.
   // 4. 2nd round on the obtained image.

   // clear the data based on the first round boundaries.
   {
      deque<int> *points;
      int k;
      arrayForEachItem(deque<int> *, boundary_array_1st_round, k, points) {
         clear_data_for_new_boundary(cur_im, points, 2000);
      }

      if (DEBUG_BPA > KEY_INFO) {
         Save2File("bpa_debug_2nd_round_clear_image.png", cur_im, NULL, image_width, image_height, 0, NULL);
      }

      if ( find(*cur_im, image_height*image_width, BLACK).size() == 0 ) {
         my_printf("INFO: clean image, so quit 2nd round computation. \n");
         return;
      }
   }

   // HT on the cleared image
   if ( ! gbl_opts->BPA_2nd_round_need_no_HT_process )
   {
      // do HT to get points. hough_transform
      int pdetect;
      int tetadetect;
      vector<int> temp;      
      vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
   
      int h = image_height;  // translate it back to original size.
      int w = image_width;

      BYTE **Imbinary = copy_image(cur_im, h, w);
      while (true)
      {
         my_HT(Imbinary, h, w, pdetect, tetadetect);

         // draw line on the image
         draw_line_on_data(pdetect, tetadetect, Imbinary, h, w, NULL, cur_im, line_set);

         temp = find(*Imbinary,h*w, BLACK);
         if (temp.size() == 0) break;
      }
      free_image(Imbinary);

      // debug the HT results
      if (DEBUG_BPA > KEY_INFO) {
         printf("The size of line set is %d\n", line_set.size());
         write_lines_to_image("HT_2nd_run_result.png", line_set, h, w);
      }

      // check the length of the HT lines and hightlight the HT lines with dilation.
      BYTE **im = new_image(h, w);
      for (int i = 0 ; i < line_set.size(); i += 4)
      {
         int x1 = line_set[i  ];
         int y1 = line_set[i+1];
         int x2 = line_set[i+2];
         int y2 = line_set[i+3];
         int x = x1 - x2;
         int y = y1 - y2;

         int HT_thresh = gbl_opts->BPA_2nd_round_HT_length;
         if ( ( x*x + y*y) > HT_thresh * HT_thresh ) {  // valid line
            draw_line_and_clear_data(NULL, h, w,
                                  x1,y1,x2,y2,
                                  0, 0, 0, im,
                                  BLACK);
         }
      }

      // mark the data points as seeds.
      st_table *st_seeds = st_init_table(st_numcmp, st_numhash);
      for ( int i = 0; i < h*w; i ++ ) {
         im[0][i] &= cur_im[0][i];
         if ( im[0][i] == BLACK ) {
            st_insert(st_seeds, (char *)i, (char *)NULL);
         }
      }
      if ( DEBUG_BPA > KEY_INFO ) {
         Save2File("HT_2nd_run_seeds.png", im, NULL, w, h, 0, NULL);
      }

      // dilation the cur_im with marked data points (seeds)
      // propogate the seeds with a mask size defined in the flag.
      // use the hash table and image for indexing.
      int mask = gbl_opts->BPA_2nd_round_HT_dilation_mask;
      BYTE **new_im = new_image(h, w);
      while ( true ) {
         st_table *st_new_points = st_init_table(st_numcmp, st_numhash);

         int *cur_point;
         st_generator *gen;
         st_foreach_item(st_seeds, gen, (char **) &cur_point, (char **)NULL) {
            int pt_coord = (int) cur_point;
            int x = x_axis(pt_coord);
            int y = y_axis(pt_coord);
            new_im[y][x] = BLACK;
            for ( int i = x - mask; i < x + mask; i ++ )
               for ( int j = y - mask; j < y + mask; j ++ ) {
                  if ( i >= 0 && j >= 0 && i < w && j < h ) {
                     if ( cur_im[j][i] == BLACK && im[j][i] == WHITE ) { // this means a new data point
                        st_insert(st_new_points, (char *)index(i, j), (char *) NULL);
                        im[j][i] = BLACK;
                     }
                  }
               }
         }
         
         st_free_table(st_seeds);
         st_seeds = st_new_points;
         if ( st_count(st_new_points) == 0 ) { // reached a fixed point.
            break;
         }
      }
      free_image(im);
      free_image(cur_im);
      cur_im = new_im;

   }

   if ( DEBUG_BPA > KEY_INFO ) {
      int offset = 2*rad_init + 4;
      image_height -= 2*offset;
      image_width  -= 2*offset;
      BYTE **im = new_image(image_height, image_width);
      for ( int x = 0; x < image_width; x ++ )
         for ( int y = 0; y < image_height; y ++)
            im[y][x] = cur_im[y+offset][x+offset];
      Save2File("bpa_debug_2nd_round_start_image.png", im, NULL, image_width, image_height, 0, NULL);
      free(im);
      image_height += 2*offset;
      image_width  += 2*offset;
   }
   

   // starting the 2nd round computation.
   int sep_num  = gbl_opts->BPA_debug_image_interval;
   int do_refinement = gbl_opts->BPA_need_do_refinement;
   int refine_num = 10;
   int do_HT_BPA_combination = gbl_opts->BPA_need_do_HT_BPA_combination;
   
   int rad = gbl_opts->radius; // the radius of the circle

   // from this point, the code is copied from BPA_boundary() with slight changes.
   deque<int> *points;
   int h, w;
   BYTE  **boundary_im = new_image(image_height, image_width);

   array_t *boundary_array = array_alloc(deque<int> *, 0);
   array_t *boundary_array_aux = array_alloc(POINTS_AUX *, 0);
   POINTS_AUX *points_aux;

   int num_set = 0;
   int p1 = 0;
   BYTE **debug_im = NULL;
   BYTE **backup_im = NULL;
   // BUG (12/30/08): why true? If we find a boundary from a certain direction, that's enough for big radius, like 512.
   // BECAUSE we want to infer multiple boundary in this loop.
   while (true)
   {
      points = new deque<int>;
      points_aux = new POINTS_AUX;

      /*
      TWO things: 1. param for which slide to sweep, left, top, bottom, right
                  2. param for whether sweep away the data in first circle.
      */
                                          
      get_the_starting_point(cur_im, boundary_im, *points, rad, p1, gbl_opts->BPA_starting_point_sweeping_dir);
      points_aux->end_points.push_back(p1);
      points_aux->radius.push_back(rad);
      points_aux->colors.push_back(0);

      // here, if we are going to clear up the first circle, we should use this for
      // later refinement stage.
      backup_im = copy_image(cur_im, image_height, image_width);

      if (points->size() == 0 ) {
         printf("WARNING: No starting point is valid, so quit...2nd round\n");
         return;
      }
      else {
         array_insert_last(deque<int> *, boundary_array, points);
         array_insert_last(POINTS_AUX *, boundary_array_aux, points_aux);
      }

      ball_pivoting(cur_im, *points, rad, p1, debug_im, sep_num, points_aux);

      for (int i = 0 ; i < points->size()-1; i ++)
         draw_line_on_2D_image(boundary_im, image_height, image_width,
                               x_axis((*points)[i]),
                               y_axis((*points)[i]),
                               x_axis((*points)[i+1]),
                               y_axis((*points)[i+1]));

      if (DEBUG_BPA > LOW_INFO)
      {
         char fn[100];
         sprintf(fn, "bpa_boundary_%d_image.png",num_set);
         Save2File(fn, boundary_im, NULL, image_width, image_height, 0, NULL);
      }

      if ( gbl_opts->refine_ignore_mutli_boundaries == 1 )
         break;

      // remove points around new boundary
      clear_data_for_new_boundary(cur_im, points, 2000);
      vector<int> tmp_vec = find(cur_im[0], image_width * image_height, BLACK );
      if ( tmp_vec.size() == 0 )
         break;

      
   }

   if (array_n(boundary_array) == 0) {
      printf("WARNING: Cannot find any boundary on 2nd round  image \n");
      return;
   }

   if (DEBUG_BPA > LOW_INFO)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_debug.png", de_fn);
      Save2File(de_fn, debug_im, NULL, image_width, image_height, 0, NULL);
   }

   if (DEBUG_BPA > KEY_INFO)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }

   int rad_new = rad;
   if (do_refinement)
   {
      int counter = 0;
      // how many refinement we should do?
      // either reach the number of interation, OR the radius is too small.
      while (counter < refine_num && rad_new >= gbl_opts->radius_min*2 )
      {
         counter ++;

         if (gbl_opts->refine_counter > 0 && counter > gbl_opts->refine_counter )
            DEBUG_BPA = 1;
         
         /* do adaptive refinement based on new ball size, half radius? */
         rad_new /= 2;

         if (rad_new > BPA_AFTER_ROUGH_RADIUS) rad_new = BPA_AFTER_ROUGH_RADIUS;

         my_printf("\n##### REFINEMENT %dth with radius %d #######\n", counter, rad_new);
         if (cur_im) free_image(cur_im);
         if (debug_im) free_image(debug_im);
         debug_im = NULL;
      
         // image translation
         assert(backup_im != NULL);
         cur_im = copy_image(backup_im, image_height, image_width);

         // for refinement, we need to consider the multiple polygon cases.
         // for this case, we will define a new boundary_array and boundary_array_aux.
         // Also, we define a vector<int> replaced_index, to remember which boundaries have been broken
         // into multiple smaller boundaries.

         array_t *new_boundary_array = NULL;
         array_t *new_boundary_array_aux = NULL;
         vector<int> *replaced_index = NULL;
         
         deque<int> *points;
         int k;
         arrayForEachItem(deque<int> *, boundary_array, k, points) {
            points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
            ball_pivoting_refinement(cur_im, *points, rad_new, debug_im, sep_num, points_aux,
                                     new_boundary_array, new_boundary_array_aux, replaced_index, k);
         }

         if (new_boundary_array)
         {
            assert(new_boundary_array_aux);
            assert(replaced_index);

            int tmp_index = 0;
            arrayForEachItem(deque<int> *, boundary_array, k, points) {
               points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
               // here fix a bug, where replaced_index->size() may equal to tmp_index.
               if (replaced_index->size() > tmp_index && k == (*replaced_index)[tmp_index] )
               {
                  tmp_index ++;
                  delete points;
                  delete points_aux;
                  
               } else {

                  array_insert_last(deque<int> *, new_boundary_array, points);
                  array_insert_last(POINTS_AUX *, new_boundary_array_aux, points_aux);
               }
            }

            boundary_array     = new_boundary_array;
            boundary_array_aux = new_boundary_array_aux;
            new_boundary_array = new_boundary_array_aux = NULL;
         }
            
         if (DEBUG_BPA)
         {
            char de_fn[1000];
            strncpy(de_fn, output_fn, strlen(output_fn) - 4);
            de_fn[strlen(output_fn) - 4] = 0;
            sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad_new);
            draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
         }         
      }
   }

   // cur_im should be freed
   if (cur_im) {
      free_image(cur_im);
      cur_im = backup_im;
   }

   // do reverse for Open Inventor visualization
   if ( 1 ) //gbl_opts->need_reverse_2nd_round )
   {
      array_t *new_boundary_array = array_alloc(deque<int> *, 0);
      array_t *new_boundary_array_aux = array_alloc(POINTS_AUX *, 0);
      int k;
      arrayForEachItem(deque<int> *, boundary_array, k, points) {
         deque<int> *reverse = new deque<int>();
         POINTS_AUX *reverse_pa = new POINTS_AUX;
         points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
         assert(points->size() == points_aux->colors.size());
         assert(points->size() == points_aux->radius.size());
         assert(points->size() == points_aux->end_points.size());

         for ( int i = points->size() - 1; i >= 0; i -- )
         {
            reverse->push_back(points->at(i));
            reverse_pa->end_points.push_back(points_aux->end_points[i]);
            reverse_pa->colors.push_back(points_aux->colors[i]);
            reverse_pa->radius.push_back(points_aux->radius[i]);
         }
         
         array_insert_last(deque<int> *, new_boundary_array, reverse);
         array_insert_last(POINTS_AUX *, new_boundary_array_aux, reverse_pa);

         delete points;
         delete points_aux;
      }

      if ( array_n(new_boundary_array) > 0 ) {
         boundary_array = new_boundary_array;
         boundary_array_aux = new_boundary_array_aux;
      }
   }
   
   // now let's merge two parts
   array_append(boundary_array_1st_round, boundary_array);
   array_append(boundary_array_aux_1st_round, boundary_array_aux);

   // restore the old parameters
   if ( gbl_opts ) {
      free(gbl_opts);
   }
   gbl_opts = gbl_opts_backup; // restore the old parameters for 1st round
   
}



/*
Function: BPA_boundary_image

Input:
     The BPA algorithm with image input to be computed

Output:
     The polygons to represent the data in the input image
     
     st_all_regions:   the segments and its regions defined by the threshold
     st_all_data   :   the real segment data

*/
void BPA_boundary_image(BYTE **im, array_t *&boundary_array)
{

   if ( gbl_opts->BPA_parameter_file )
      load_parameter(gbl_opts->BPA_parameter_file);
   
   int sep_num  = gbl_opts->BPA_debug_image_interval;
   int do_refinement = gbl_opts->BPA_need_do_refinement;
   int refine_num = 10;    // 10 to guarantee the final rad is 1.
   int do_HT_BPA_combination = gbl_opts->BPA_need_do_HT_BPA_combination;

   int rad = gbl_opts->radius; // the radius of the circle
   DEBUG_BPA = gbl_opts->BPA_debug_mode;

   deque<int> *points;
   POINTS_AUX *points_aux;
   array_t *boundary_array_aux = array_alloc(POINTS_AUX *, 0);

   BYTE **debug_im = NULL;
   BYTE **backup_im = NULL;
   BYTE **boundary_im;
   BYTE **cur_im = copy_image(im, image_height, image_width);

   // image translation
   cur_im = BPA_image_translation(cur_im, rad);
   boundary_im = new_image(image_height, image_width);

   int num_set = 0;
   int p1 = 0;
   {
      points = new deque<int>;

      /* the points_aux is initilized */
      points_aux = new POINTS_AUX;

      /*
      TWO things: 1. param for which slide to sweep, left, top, bottom, right
                  2. param for whether sweep away the data in first circle.
      */
                                          
      get_the_starting_point(cur_im, boundary_im, *points, rad, p1, gbl_opts->BPA_starting_point_sweeping_dir);
      points_aux->end_points.push_back(p1);
      points_aux->radius.push_back(rad);
      points_aux->colors.push_back(0);

      // here, if we are going to clear up the first circle, we should use this for
      // later refinement stage.
      if (gbl_opts->BPA_clear_first_circle_data)
         backup_im = copy_image(cur_im, image_height, image_width);

      if (points->size() == 0 ) {
         printf("WARNING: No starting point is valid, so quit... BPA_boundary\n");
         return;
      }
      else {
         array_insert_last(deque<int> *, boundary_array, points);
         array_insert_last(POINTS_AUX *, boundary_array_aux, points_aux);
      }

      ball_pivoting(cur_im, *points, rad, p1, debug_im, sep_num, points_aux);

      // free resource
      free_image(boundary_im);
   }

   if (array_n(boundary_array) == 0) {
      printf("WARNING: Cannot find any boundary on the image\n");
      free_image(cur_im);
      return;
   }

   if ( DEBUG_BPA ) {
      char de_fn[1000];
      sprintf(de_fn, "test_refine_with_rad_%d.png", rad);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
      exit(0);
   }

   int rad_new = rad;
   if (do_refinement)
   {
      int counter = 0;
      while (counter < refine_num && rad_new >= gbl_opts->radius_min*2 )
      {
         counter ++;

         /* do adaptive refinement based on new ball size, half radius? */
         rad_new /= 2;

         if (rad_new > BPA_AFTER_ROUGH_RADIUS) rad_new = BPA_AFTER_ROUGH_RADIUS;

         my_printf("\n##### REFINEMENT %dth with radius %d #######\n", counter, rad_new);
         if (cur_im) free_image(cur_im);
         if (debug_im) free_image(debug_im);
         debug_im = NULL;
      
         // image translation
         if (gbl_opts->BPA_clear_first_circle_data) {
            assert(backup_im != NULL);
            cur_im = copy_image(backup_im, image_height, image_width);
         }
         else {
            cur_im = copy_image(im, image_height, image_width);
            cur_im = BPA_image_translation(cur_im, rad);
         }

         array_t *new_boundary_array = NULL;
         array_t *new_boundary_array_aux = NULL;
         vector<int> *replaced_index = NULL;
         
         deque<int> *points;
         int k;
         arrayForEachItem(deque<int> *, boundary_array, k, points) {
            points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
            ball_pivoting_refinement(cur_im, *points, rad_new, debug_im, sep_num, points_aux,
                                     new_boundary_array, new_boundary_array_aux, replaced_index, k);
         }

         // for refinement, we need to consider the multiple polygon cases.
         // for this case, we will define a new boundary_array and boundary_array_aux.
         // Also, we define a vector<int> replaced_index, to remember which boundaries have been broken
         // into multiple smaller boundaries.
         if (new_boundary_array)
         {
            assert(new_boundary_array_aux);
            assert(replaced_index);

            int tmp_index = 0;
            arrayForEachItem(deque<int> *, boundary_array, k, points) {
               points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
               // here fix a bug, where replaced_index->size() may equal to tmp_index.
               if (replaced_index->size() > tmp_index && k == (*replaced_index)[tmp_index] )
               {
                  tmp_index ++;
                  delete points;
                  delete points_aux;
                  
               } else {

                  array_insert_last(deque<int> *, new_boundary_array, points);
                  array_insert_last(POINTS_AUX *, new_boundary_array_aux, points_aux);
               }
            }

            boundary_array     = new_boundary_array;
            boundary_array_aux = new_boundary_array_aux;
            new_boundary_array = new_boundary_array_aux = NULL;
         }
      }

      // free resource
      if ( cur_im ) free_image(cur_im);
      if ( debug_im ) free_image(debug_im);
      if ( backup_im) free_image(backup_im);
     
   }

   // here, we want to simplify the boundary, namely merge the point on the same line
   // the image_width and image_height should be ok for x_axis, y_axis, index, computation.
   if (gbl_opts->BPA_merge_boundary_points) 
      BPA_merge_boundary_points(boundary_array, boundary_array_aux, rad, rad_new, cur_im);

   // dump the results
   BPA_dump_image_vectors(boundary_array, boundary_array_aux, 0, rad, 2*rad+4);
   
}

/* Function: BPA_boundary

   A new function here for Ball Pivot Algorithm (BPA)

   Test 3 cases:
   1. regular good image
   2. tappered thick image
   3. separated circle image

   Output:
   1. how many points (percentage) are touched so far
   2. use deque to record the order of the touched points
   3. pivote two balls (small v.s. big) simultaneously.

   Algorithm:
   1. sweep algrithm is applied to get normal and boundary pixels.
   2. initially choose 1 boundary pixel to start.
   3. the ball is pivoted along two directions.

   Command: project -B filename -O ""
   Default parameters for system call = "-r 512 -p 1 -R -o x -H";
   -o   -   default starting side, see <get_the_starting_point()> for details.
*/
void BPA_boundary(char *fn)
{
   if ( gbl_opts->BPA_parameter_file )
      load_parameter(gbl_opts->BPA_parameter_file);
   
   int sep_num  = gbl_opts->BPA_debug_image_interval;
   int do_refinement = gbl_opts->BPA_need_do_refinement;
   int refine_num = 10;    // 10 to guarantee the final rad is 1.
   int do_HT_BPA_combination = gbl_opts->BPA_need_do_HT_BPA_combination;

   int rad = gbl_opts->radius; // the radius of the circle
   DEBUG_BPA = gbl_opts->BPA_debug_mode;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:A:b:C:c:dEe:fHh:I:L:l:Mm:O:o:P:p:Rr:S:s:t:")) != EOF)
      {
         switch (c) {
            case 'r':
               /* radius size */
               cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
               sprintf(cmdline, "%s", util_optarg);
               rad = atoi(cmdline);
               break;
            case 'C':
               /* Minimun Length to break the circle sub unit */
               gbl_opts->BPA_boundary_break_len = atoi(util_optarg);
               break;
            case 'c':
               /* debug refinement counter */
               gbl_opts->refine_counter = atoi(util_optarg);
               break;
            case 'b':
               /* maxinum refinement counter */
               gbl_opts->BPA_refine_number = atoi(util_optarg);
               break;
            case 'M':
               /* gap lines matters - dynamically change */
               gbl_opts->BPA_gap_line_matters = 1;
               break;
            case 'l':
               /* gap line length */
               gbl_opts->BPA_gap_line_length = atoi(util_optarg);
               break;
            case 'I':
               /* whether to reshape the slope line, like / to _|. */
               gbl_opts->BPA_reshape_slope_line = atoi(util_optarg);
               assert(gbl_opts->BPA_reshape_slope_line > 0);
               break;
            case 'L':
               /* mininum refinement radius length */
               gbl_opts->radius_min = atoi(util_optarg);
               break;
            case 'm':
               /* do not ignore multiple boundaries */
               gbl_opts->refine_ignore_mutli_boundaries = atoi(util_optarg);
               break;
            case 'f':
               /* do not clear data in the First circle */
               gbl_opts->BPA_clear_first_circle_data = 0;
               break;
            case 'd':
               /* debug mode */
               DEBUG_BPA = 1;
               break;
            case 'H':
               /* debug mode */
               do_HT_BPA_combination = 1;
               break;
            case 'R':
               /* debug mode */
               do_refinement = 1;
               break;
            case 'S':
               /* no speedup, old fashion for refinement */
               gbl_opts->BPA_refine_speed_up = atoi(util_optarg);
               break;
            case 's':
               /* interval of the debug images */
               sep_num = atoi(util_optarg);
               break;
            case 'h':
               /* starting debug counter number */
               gbl_opts->min_debug = atoi(util_optarg);
               break;
            case 'p':
               /* set the pace degree for radius, big radius should always use 1 or less */
               gbl_opts->pace_degree = atof(util_optarg);
               break;
            case 'o':
               /* set the sweep direction */
               gbl_opts->BPA_starting_point_sweeping_dir = atoi(util_optarg);
               break;
            case 'e':
               /* ending debug counter number */
               gbl_opts->max_debug = atoi(util_optarg);
               break;
            case 't':
               /* how many times on refinement */
               refine_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   /* some threshold for BPA approach */
   assert(rad > 0);

   /* the output point queue */
   /* points is used to record one particular running of the touched points,
    and it will be inserted into boundary_array for later drawing
   */
   deque<int> *points;

   /* boundary_im is used for cases where multiple circle or objects exists.
      This is to indicate whether a part of the image is processed or not.
   */
   int h, w;
   BYTE **cur_im, **boundary_im;

   /* boundary_array is an array of points sequences, which represents one
      particular boundary.
   */
   array_t *boundary_array = array_alloc(deque<int> *, 0);

   /* INVARIANTS:
      1. it is impossible that a ball can NOT pivot to starting point from clockwise direction,
      but is able to pivot from counter clockwise direction.
      
      2. the last 1 - 2 points of the points_aux->end_points is meaningless.
      3. the length of points and points_aux fields are equal.
   */    
   /* boundary_array_aux is an array of POINTS_AUX, for storing information for further
      process on the boundary points
   */
   array_t *boundary_array_aux = array_alloc(POINTS_AUX *, 0);
   POINTS_AUX *points_aux;

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   orig_img = load_image(fn, h, w);
   set_image(cur_im, orig_img);

   // automatically determine the best radius for rough pivoting
   // rad = BPA_rough_radius(cur_im);

   // image translation
   cur_im = BPA_image_translation(cur_im, rad);
   if (DEBUG_BPA > ALL_INFO)
      Save2File("bpa_debug_resize_cur_im.png", cur_im, NULL, image_width, image_height, 0, NULL);
   boundary_im = new_image(image_height, image_width);

   //Save2File("bpa_cccc.png", cur_im, NULL, w, h, 0, NULL);

   int num_set = 0;
   int p1 = 0;
   BYTE **debug_im = NULL;
   BYTE **backup_im = NULL;
   // BUG (12/30/08): why true? If we find a boundary from a certain direction, that's enough for big radius, like 512.
   // BECAUSE we want to infer multiple boundary in this loop.
   while (true)
   {
      points = new deque<int>;

      /* the points_aux is initilized */
      points_aux = new POINTS_AUX;

      /*
      TWO things: 1. param for which slide to sweep, left, top, bottom, right
                  2. param for whether sweep away the data in first circle.
      */
                                          
      get_the_starting_point(cur_im, boundary_im, *points, rad, p1, gbl_opts->BPA_starting_point_sweeping_dir);
      points_aux->end_points.push_back(p1);
      points_aux->radius.push_back(rad);
      points_aux->colors.push_back(0);

      // here, if we are going to clear up the first circle, we should use this for
      // later refinement stage.
      if (gbl_opts->BPA_clear_first_circle_data)
         backup_im = copy_image(cur_im, image_height, image_width);

      if (points->size() == 0 ) {
         if ( array_n(boundary_array) > 0 )
            break;
         else {
            printf("WARNING: No starting point is valid, so quit... BPA_boundary\n");
            return;
         }
      }
      else {
         array_insert_last(deque<int> *, boundary_array, points);
         array_insert_last(POINTS_AUX *, boundary_array_aux, points_aux);
      }

      //printf("\n ==== Found %d set of boundary =====\n", ++num_set);
      ball_pivoting(cur_im, *points, rad, p1, debug_im, sep_num, points_aux);

      for (int i = 0 ; i < points->size()-1; i ++)
         draw_line_on_2D_image(boundary_im, image_height, image_width,
                               x_axis((*points)[i]),
                               y_axis((*points)[i]),
                               x_axis((*points)[i+1]),
                               y_axis((*points)[i+1]));

      if (DEBUG_BPA > ALL_INFO)
      {
         char fn[100];
         sprintf(fn, "bpa_boundary_%d_image.png",num_set);
         Save2File(fn, boundary_im, NULL, image_width, image_height, 0, NULL);
      }


      if ( gbl_opts->refine_ignore_mutli_boundaries == 1 )
         break;

      // remove points around new boundary
      clear_data_for_new_boundary(cur_im, points, 2000);
      vector<int> tmp_vec = find(cur_im[0], image_width * image_height, BLACK );
      if ( tmp_vec.size() == 0 )
         break;

      
   }

   if (array_n(boundary_array) == 0) {
      printf("WARNING: Cannot find any boundary on the image %s\n", fn);
      return;
   }

   if (DEBUG_BPA > LOW_INFO)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_debug.png", de_fn);
      Save2File(de_fn, debug_im, NULL, image_width, image_height, 0, NULL);
   }

   if (DEBUG_BPA > KEY_INFO)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }

   int rad_new = rad;
   if (do_refinement)
   {
      int counter = 0;
      // how many refinement we should do?
      // either reach the number of interation, OR the radius is too small.
      while (counter < refine_num && rad_new >= gbl_opts->radius_min*2 )
      {
         counter ++;

         if (gbl_opts->refine_counter > 0 && counter > gbl_opts->refine_counter )
            DEBUG_BPA = 1;
         
         /* do adaptive refinement based on new ball size, half radius? */
         rad_new /= 2;

         if (rad_new > BPA_AFTER_ROUGH_RADIUS) rad_new = BPA_AFTER_ROUGH_RADIUS;

         my_printf("\n##### REFINEMENT %dth with radius %d #######\n", counter, rad_new);
         if (cur_im) free_image(cur_im);
         if (debug_im) free_image(debug_im);
         debug_im = NULL;
      
         // image translation
         if (gbl_opts->BPA_clear_first_circle_data) {
            assert(backup_im != NULL);
            cur_im = copy_image(backup_im, image_height, image_width);
         }
         else {
            set_image(cur_im, orig_img);
            cur_im = BPA_image_translation(cur_im, rad);
         }

         // for refinement, we need to consider the multiple polygon cases.
         // for this case, we will define a new boundary_array and boundary_array_aux.
         // Also, we define a vector<int> replaced_index, to remember which boundaries have been broken
         // into multiple smaller boundaries.

         array_t *new_boundary_array = NULL;
         array_t *new_boundary_array_aux = NULL;
         vector<int> *replaced_index = NULL;
         
         deque<int> *points;
         int k;
         arrayForEachItem(deque<int> *, boundary_array, k, points) {
            points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
            ball_pivoting_refinement(cur_im, *points, rad_new, debug_im, sep_num, points_aux,
                                     new_boundary_array, new_boundary_array_aux, replaced_index, k);
         }

         if (new_boundary_array)
         {
            assert(new_boundary_array_aux);
            assert(replaced_index);

            int tmp_index = 0;
            arrayForEachItem(deque<int> *, boundary_array, k, points) {
               points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
               // here fix a bug, where replaced_index->size() may equal to tmp_index.
               if (replaced_index->size() > tmp_index && k == (*replaced_index)[tmp_index] )
               {
                  tmp_index ++;
                  delete points;
                  delete points_aux;
                  
               } else {

                  array_insert_last(deque<int> *, new_boundary_array, points);
                  array_insert_last(POINTS_AUX *, new_boundary_array_aux, points_aux);
               }
            }

            boundary_array     = new_boundary_array;
            boundary_array_aux = new_boundary_array_aux;
            new_boundary_array = new_boundary_array_aux = NULL;
         }
            
         if (DEBUG_BPA > KEY_INFO)
         {
            char de_fn[1000];
            strncpy(de_fn, output_fn, strlen(output_fn) - 4);
            de_fn[strlen(output_fn) - 4] = 0;
            sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad_new);
            draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
         }         
      }
   }

   // if we need to do another round of sweeping.
   if (gbl_opts->BPA_2nd_round_parameter_file) {
      do_2nd_round_BPA_and_refinement(cur_im, boundary_array, boundary_array_aux, rad);
   }

   // Remove the gap lines.
   if ( !gbl_opts->BPA_ignore_gap_line )
      BPA_remove_gap_lines(boundary_array, boundary_array_aux, rad, rad_new);

   // here, we want to reshape the boundary if needed
   if (gbl_opts->BPA_reshape_slope_line)
      BPA_reshape_boundary_points(boundary_array, boundary_array_aux, rad, rad_new, cur_im);

   // here, we want to simplify the boundary, namely merge the point on the same line
   // the image_width and image_height should be ok for x_axis, y_axis, index, computation.
   if (gbl_opts->BPA_merge_boundary_points) 
      BPA_merge_boundary_points(boundary_array, boundary_array_aux, rad, rad_new, cur_im);

   // dump the results
   BPA_dump_image_vectors(boundary_array, boundary_array_aux, 0, rad, 2*rad+4);
   
   // here, we donot need to translate the image back, but translate HT result to new coordinates.
   // only need to remember the translation factor: 2*rad + 4
   if (do_HT_BPA_combination)
   {
      if (cur_im) free_image(cur_im);
      if (debug_im) free_image(debug_im);

      // translate all points back to original coordinates.
      int k;
      int offset = 2*rad + 4;      
      deque<int>  *points_const;
      my_printf("Make sure this is big coords: x: %d, y: %d", image_width, image_height);
      int h1 = image_height;
      int w1 = image_width;
      int h0 = image_height - 2*offset;
      int w0 = image_width  - 2*offset;
      arrayForEachItem(deque<int> *, boundary_array, k, points_const) {
         for (int i = 0; i < points_const->size(); i++)
         {
            // inline the x_axis and y_axis
            int x0 = (*points_const)[i] % w1 - offset;
            int y0 = (*points_const)[i] / w1 - offset;

            // inline the index function
            (*points_const)[i] = x0 + y0 * w0;
         }
      }

      // reset the globle var image_width and image_height
      set_image(cur_im, orig_img);

      // debug image is used to check the HT points with BPA points
      BYTE **de_im = new_image(image_height, image_width);
      arrayForEachItem(deque<int> *, boundary_array, k, points_const) {
         for (int i = 0; i < points_const->size(); i++)
            de_im[y_axis((*points_const)[i])][x_axis((*points_const)[i])] = BLACK;
      }
      
      combine_HT_with_BPA(output_fn, rad, cur_im, boundary_array, boundary_array_aux, de_im);
      //BPA_dump_image_vectors(boundary_array, boundary_array_aux, 1, rad, 0);

      free_image(de_im);
   } else {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_final_result_with_rad_%d.png", de_fn, rad_new);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }

   // free resources
   {

      deque<int>  *points;
      POINTS_AUX  *pa;
      int k;
      arrayForEachItem(deque<int> *, boundary_array, k, points) {
         pa = array_fetch(POINTS_AUX *, boundary_array_aux, k);

         delete points;
         delete pa;
      }
      
      if (cur_im) free_image(cur_im);
      if (debug_im) free_image (debug_im);
      if (boundary_im) free_image (boundary_im);
      if (orig_img) delete orig_img;
   }
   
}

// Function: draw_3D_bounding_box_test
// test for 3D bounding box
//
void draw_3D_bounding_box_test()
{
   // find a key point on slice 137, where the coord of (z, x) is (78, 965)
   // x_i = (int)(((slice_data[i+2] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
   // z_i = IMAGE_HEIGHT - (int)((slice_data[i] - BOX_MIN_Z) * scale + .5) - 1; // z
   // scale = (double)IMAGE_WIDTH / diff_x;
   // x_i is in [20, 90], z_i is in [20, 60]
   // x_i_data = ((x_i - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   // z_i_data = ((IMAGE_HEIGHT - 1 - z_i) - .5)/scale + BOX_MIN_Z;
   // so x_i_data is about 86.0, z_i_data is about 41.4

   // for another point (386, 939), [(40, 328), (71, 13), (939, 91)]
   int h = 392, w = 1024;
   BYTE **im = new_image(h, w);
   int x1, y1, x2, y2;
   double diff_x = 70;
   int IMAGE_HEIGHT = h, IMAGE_WIDTH = w;
   double BOX_MIN_X = 20, BOX_MIN_Z = 20;
   double scale = (double)IMAGE_WIDTH / diff_x;
   int x_i, x_i_1, y_i, y_i_1;
   double x_f, x_f_1, y_f, y_f_1;

   // right box (69/76, 965), (386, 939)
   x_f   = ((939 - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   x_f_1 = ((965  - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   y_f   = ((IMAGE_HEIGHT - 1 - 386) - .5)/scale + BOX_MIN_Z;
   y_f_1 = ((IMAGE_HEIGHT - 1 - 76 ) - .5)/scale + BOX_MIN_Z;
   printf("right box: %f, %f, %f, %f\n", x_f, y_f, x_f_1, y_f_1);
   x_i   = (int)(((x_f   - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   x_i_1 = (int)(((x_f_1 - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   y_i   = IMAGE_HEIGHT - (int)((y_f   - 20) * scale + .5) - 1; // z
   y_i_1 = IMAGE_HEIGHT - (int)((y_f_1 - 20) * scale + .5) - 1; // z
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i_1, y_i);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i_1, y_i);

   // bottom box (386, 939) (328, 40)
   // 84.155273, 20.307617, 85.932617, 41.977539 (41.499023)
   // 84.155273, 20.307617, 22.700195, 24.272461
   // 24.819336, 45.805664, 22.700195, 24.272461
   // 24.819336, 45.805664, 84.155273, 40.473633   
   x_f   = ((939 - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   x_f_1 = ((40  - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   y_f   = ((IMAGE_HEIGHT - 1 - 386) - .5)/scale + BOX_MIN_Z;
   y_f_1 = ((IMAGE_HEIGHT - 1 - 328) - .5)/scale + BOX_MIN_Z;
   printf("bottom box: %f, %f, %f, %f\n", x_f, y_f, x_f_1, y_f_1);
   x_i   = (int)(((x_f   - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   x_i_1 = (int)(((x_f_1 - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   y_i   = IMAGE_HEIGHT - (int)((y_f   - 20) * scale + .5) - 1; // z
   y_i_1 = IMAGE_HEIGHT - (int)((y_f_1 - 20) * scale + .5) - 1; // z
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i_1, y_i);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i_1, y_i);

   // bottom box (13, 71) (328, 40)
   // for another point (386, 939), [(40, 328), (71, 13), (939, 91)]
   x_f   = ((71 - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   x_f_1 = ((40  - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   y_f   = ((IMAGE_HEIGHT - 1 - 13) - .5)/scale + BOX_MIN_Z;
   y_f_1 = ((IMAGE_HEIGHT - 1 - 328) - .5)/scale + BOX_MIN_Z;
   printf("bottom box: %f, %f, %f, %f\n", x_f, y_f, x_f_1, y_f_1);
   x_i   = (int)(((x_f   - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   x_i_1 = (int)(((x_f_1 - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   y_i   = IMAGE_HEIGHT - (int)((y_f   - 20) * scale + .5) - 1; // z
   y_i_1 = IMAGE_HEIGHT - (int)((y_f_1 - 20) * scale + .5) - 1; // z
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i_1, y_i);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i_1, y_i);
   
   // bottom box (13, 71) (91, 939)
   // for another point (386, 939), [(40, 328), (71, 13), (939, 91)]
   x_f   = ((71   - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   x_f_1 = ((939  - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
   y_f   = ((IMAGE_HEIGHT - 1 - 13) - .5)/scale + BOX_MIN_Z;
   y_f_1 = ((IMAGE_HEIGHT - 1 - 91) - .5)/scale + BOX_MIN_Z;
   printf("bottom box: %f, %f, %f, %f\n", x_f, y_f, x_f_1, y_f_1);
   x_i   = (int)(((x_f   - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   x_i_1 = (int)(((x_f_1 - 20)/diff_x)*IMAGE_WIDTH  + .5); // x
   y_i   = IMAGE_HEIGHT - (int)((y_f   - 20) * scale + .5) - 1; // z
   y_i_1 = IMAGE_HEIGHT - (int)((y_f_1 - 20) * scale + .5) - 1; // z
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i, y_i, x_i_1, y_i);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i, y_i_1);
   draw_line_on_2D_image(im, h, w, x_i_1, y_i_1, x_i_1, y_i);
   
   Save2File("tttttt.png", im,  NULL, IMAGE_WIDTH, IMAGE_HEIGHT, 0, NULL);
   
}

// Function: inside_3D_container_for_dir_0
// Helper function to check whether a 3D point is in a special bounding box or not
//
// This func is only called by <load_point_cloud_as_image>, dir_0 means bottom up direction.
// manually cleaned: 0736, 0738, 0498
bool inside_3D_container_for_dir_0(double x, double y, double z)
{
   /* This is for debug purpose.
   if ( y < 8 )
      return true;
   else return false;
   */
   
   // starting from bottom, define a special 3D bounding box
   // for any height (y) not in the "if", return true;

   // assume y is between 0 and 44 as defined in BOX_MIN/MAX_Y
   // here I found that slice 250 and its following slices don't contain tree any more, so
   // 250/1000*(44 - 0) = 11.
   // 683/1000*(44 - 0) = 30.052
   if (y < 30.052)
   {
      // find a key point on slice 137, where the coord of (z, x) is (78, 965)
      // x_i = (int)(((slice_data[i+2] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
      // z_i = IMAGE_HEIGHT - (int)((slice_data[i] - BOX_MIN_Z) * scale + .5) - 1; // z
      // scale = (double)IMAGE_WIDTH / diff_x;
      // x_i is in [20, 90], z_i is in [20, 60]
      // x_i_data = ((x_i - .5)/IMAGE_WIDTH)*diff_x + BOX_MIN_X,
      // z_i_data = ((IMAGE_HEIGHT - 1 - z_i) - .5)/scale + BOX_MIN_Z;
      // so x_i_data is about 86.0, z_i_data is about 41.4
      // see <draw_3D_bounding_box_test> for details

      // if inside the boxes, return ture
      // if (41.362305) for slice before 250 (for removing vertical noise)
      double z0 = (y < 11.0) ? 41.499023 : 41.977539;
      if (x > 84.155273 && x < 85.932617 && z > 20.307617 && z < z0)
         return true;
      if (x > 22.700195 && x < 84.155273 && z > 20.307617 && z < 24.272461)
         return true;
      if (x > 22.700195 && x < 24.819336 && z > 24.272461 && z < 45.805664)
         return true;
      if (x > 24.819336 && x < 84.155273 && z > 40.473633 && z < 45.805664)
         return true;

      // otherwise, noise, return false.
      return false;
      
   }

   return true;
}

void clear_slices_using_mask(BYTE **im, int index)
{
   static int cur_mask_index = -1;
   static BYTE **mask_im = NULL;
   int max_mask = 1000;

#ifdef LINUX
   CImg<unsigned char> *bitmap_mimio = NULL;
#else
   Bitmap *bitmap_mimio = NULL;
#endif   

   if ( index > cur_mask_index ) {
      int i;
      for (i = index; i < max_mask; i ++) {
         char fn[1024];
         assert(gbl_opts->BBM_mask_folder);
         char *ds = digit_string(4, i);
         sprintf(fn, "%s/mask_slice_%s.png", gbl_opts->BBM_mask_folder, ds);
         free(ds);
         if ( file_exist(fn) ) {
            cur_mask_index = i;
            int w, h;

            if ( bitmap_mimio ) {
               delete bitmap_mimio;
            }
            bitmap_mimio = load_image(fn, h, w);

            if ( mask_im ) {
               free_image(mask_im);
            }
            set_image(mask_im, bitmap_mimio);
            printf("\nFound a new mask image: %s\n", fn);
            
            break;
         }
      }

      if ( i == max_mask ) {  // no need to do the above next time;
         cur_mask_index = max_mask;
      }
   }

   assert(mask_im);
   int data_len = image_width*image_height;
   for ( int i = 0; i < data_len; i ++ ) {
      im[0][i] &= mask_im[0][i];
   }

}

// Function: load_point_cloud_as_images_h_inside
// convert the txt file into image
//
// Command options - project.exe -l ..\data\Rotated.bpa -O "-s total_slices -x -X -y -Y -z -Z -d 0/1/2"
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -d 0" // get 1k sliced image bottom up
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -w 1000 -h 2048 -Z 45.0 -d 2" // get 1k sliced image left - right
// to mapping back from preprocessed key slice, using the following :
// z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1 - 40; =>
// 1053 = 2048 - ((x - 0.0) * (1000/(45.0 - 20.0)) + .5) - 41
// slice # = x/(44.0 - 0.0) = .542...
void load_point_cloud_as_images_h_inside(char *fn)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   // CHANGE: IMAGE_HEIGHT
   int IMAGE_WIDTH  = 1024;
   int IMAGE_HEIGHT = 1024;
   int pre_slice_num = -1;

   // direction: 0 - Y axis (bottom up), 1 - Z axis (face to face), 2 - X axis (left to right)
   int direction = 0;
   int has_set_size = 0;

   // BOX : -36.2841 82.3821 -2.4001 80.6962 -15.4828 136.499
   // TEST: -x 20 -X 90 -z 20 -Z 60 -y -3.0 -Y 44.0
   double BOX_MIN_X = 20.0;
   double BOX_MAX_X = 90.0;
   double BOX_MIN_Y =  0.0;
   double BOX_MAX_Y = 44.0;
   double BOX_MIN_Z = 20.0;
   double BOX_MAX_Z = 60.0;
   
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "d:h:w:x:X:y:Y:z:Z:s:t:p:")) != EOF)
      {
         switch (c) {
            case 'd':
               direction = atoi(util_optarg);
               assert(direction == 0 || direction == 1 || direction == 2);
               break;
            case 'h':
               IMAGE_HEIGHT = atoi(util_optarg);
               has_set_size = 1;
               break;
            case 'w':
               IMAGE_WIDTH  = atoi(util_optarg);
               has_set_size = 1;
               break;
            case 's':
               pre_slice_num = atoi(util_optarg);
               break;
            case 'p':
               path_prefix = strdup(util_optarg);
               break;
            case 'x':
               BOX_MIN_X = atof(util_optarg);
               break;
            case 'X':
               BOX_MAX_X = atof(util_optarg);
               break;
            case 'y':
               BOX_MIN_Y = atof(util_optarg);
               break;
            case 'Y':
               BOX_MAX_Y = atof(util_optarg);
               break;
            case 'z':
               BOX_MIN_Z = atof(util_optarg);
               break;
            case 'Z':
               BOX_MAX_Z = atof(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   
   if (!has_set_size && direction == 1)
   {
      IMAGE_WIDTH  = 1024;
      IMAGE_HEIGHT = 744;
   } else if (!has_set_size && direction == 2 ){
      IMAGE_WIDTH  = 600;
      IMAGE_HEIGHT = 1024;
      BOX_MAX_Z = 50.0;
   }

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   vector<double> data;
   printf("loading data from file...\n");
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         if (x < BOX_MIN_X || x > BOX_MAX_X ||
             y < BOX_MIN_Y || y > BOX_MAX_Y ||
             z < BOX_MIN_Z || z > BOX_MAX_Z)
            continue;

         // rule out noise for Y axis (direction == 0)
         // if (direction == 0 && BOX_MIN_Y == 0.0 && BOX_MAX_Y == 44.0 && !inside_3D_container_for_dir_0(x, y, z))
         //   continue;

         // This is to determine logic X, Y, Z
         data.push_back(y);
         data.push_back(x);
         data.push_back(z);
      }
   }

   fclose(fid);

   // comment out me later
   // this is just used to generate a smaller bpa for debugging purpose.
   /*
   FILE *f_de = fopen("../data/debug_rotate.bpa", "w");
   for (int index = 0; index < data.size(); index += 3) {
      fprintf(f_de, "%f %f %f\n", data[index+2], data[index], data[index+1]);
   }
   fclose(f_de);
   exit(0);
   */
   // end of comment
   
   // starting write data into image;
   assert(data.size() % 3 == 0);

   double diff_x = BOX_MAX_X - BOX_MIN_X;
   double diff_y = BOX_MAX_Y - BOX_MIN_Y;
   double diff_z = BOX_MAX_Z - BOX_MIN_Z;
   int slice_total = pre_slice_num == -1 ? 200 : pre_slice_num;
   int slice_number =  0;

   // CHANGE: diff_y
   double dir_diff = (direction == 0) ? diff_y : (direction == 1) ? diff_z : diff_x;
   double slice_int =  dir_diff / slice_total;

#if 1

   double BOX_MIN = (direction == 0) ? BOX_MIN_Y : (direction == 1) ? BOX_MIN_Z : BOX_MIN_X;
   vector<vector<int> > slice_group(slice_total);
   for (int index = 0; index < data.size(); index += 3)
   {
      // CHANGE: index
      int index_ = (direction == 0) ? index : (direction == 1) ? index+2 : index+1;
      int group_index = (int) (((data[index_] - BOX_MIN)/dir_diff)*slice_total);
      if ( group_index == slice_total )
         group_index --;
      
      slice_group[group_index].push_back(index);
   }
   
   
   
   for (int group_index = 0; group_index < slice_total; group_index ++)
   {
      printf("\nLoad: Processing slice #%d, ", group_index);

      // z - height, x - width, y - 3D high
      BYTE **im = new_image(IMAGE_HEIGHT, IMAGE_WIDTH);
      // CHANGE: diff_x
      double dir_scale_diff = (direction == 2) ? diff_z : diff_x;
      double scale = (double)IMAGE_WIDTH / dir_scale_diff;
      for (int i = 0; i < slice_group[group_index].size(); i++)
      {
         vector<double> slice_data;
         int data_index = slice_group[group_index][i];
         slice_data.push_back(data[data_index+2]);  // z axis
         slice_data.push_back(data[data_index]);    // y axis
         slice_data.push_back(data[data_index+1]);  // x axis
         
         // CHANGE: BOX_MIN_Z
         int z_i;
         if (direction == 0)
            z_i = IMAGE_HEIGHT - (int)((slice_data[0] - BOX_MIN_Z) * scale + .5) - 1; // z
         else
            z_i = IMAGE_HEIGHT - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1; // y
         if (z_i < 0)
            continue;

         int x_i;
         if (direction == 2)
            x_i = (int)(((slice_data[0] - BOX_MIN_Z)/diff_z)*IMAGE_WIDTH  + .5); // z
         else
            x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
         if (x_i == IMAGE_WIDTH)
            x_i -= 1;
         
         im[z_i][x_i] = BLACK;

      }

      char ofn[1000];
      char *ds = digit_string(4, slice_number++);
      sprintf(ofn, "%s/image_slice_%s.png", path_prefix, ds);
      free(ds);

      if ( gbl_opts->BBM_using_bounding_box_mask ) 
         clear_slices_using_mask(im, group_index);
      
      Save2File(ofn, im, NULL, IMAGE_WIDTH, IMAGE_HEIGHT, 0, NULL);
      free_image(im);
   }

#else

   for (int i = 0; i < slice_total; i ++)
   {
      printf("\nLoad: Processing slice #%d, ", i);
      // find out the appropriate points
      // CHANGE: BOX_MIN_Y   
      double BOX_MIN = (direction == 0) ? BOX_MIN_Y : (direction == 1) ? BOX_MIN_Z : BOX_MIN_X;
      double slice_min = i*slice_int + BOX_MIN;
      double slice_max = slice_min + slice_int;
      for (int index = 0; index < data.size(); index += 3)
      {
         // CHANGE: index
         int index_ = (direction == 0) ? index : (direction == 1) ? index+2 : index+1;
         if (data[index_] > slice_min && data[index_] < slice_max)
         {
            slice_data.push_back(data[index+2]);  // z axis
            slice_data.push_back(data[index]);    // y axis
            slice_data.push_back(data[index+1]);  // x axis
         }
      }

      /*
      if (slice_data.size() == 0)
         continue;
      */

      printf("found data/image, slice number: %d, slice_min: %f.", slice_number, slice_min);
      // z - height, x - width, y - 3D high
      BYTE **im = new_image(IMAGE_HEIGHT, IMAGE_WIDTH);
      // CHANGE: diff_x
      double dir_scale_diff = (direction == 2) ? diff_z : diff_x;
      double scale = (double)IMAGE_WIDTH / dir_scale_diff;
      for (int i = 0; i < slice_data.size(); i+=3)
      {
         // CHANGE: BOX_MIN_Z
         int z_i;
         if (direction == 0)
            z_i = IMAGE_HEIGHT - (int)((slice_data[i] - BOX_MIN_Z) * scale + .5) - 1; // z
         else
            z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1; // y
         if (z_i < 0)
            continue;

         int x_i;
         if (direction == 2)
            x_i = (int)(((slice_data[i] - BOX_MIN_Z)/diff_z)*IMAGE_WIDTH  + .5); // z
         else
            x_i = (int)(((slice_data[i+2] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
         if (x_i == IMAGE_WIDTH)
            x_i -= 1;
         
         im[z_i][x_i] = BLACK;

      }

      char ofn[1000];
      char *ds = digit_string(4, slice_number++);
      sprintf(ofn, "%s/image_slice_%s.png", path_prefix, ds);
      free(ds);

      if ( gbl_opts->BBM_using_bounding_box_mask ) 
         clear_slices_using_mask(im, i);
      
      Save2File(ofn, im, NULL, IMAGE_WIDTH, IMAGE_HEIGHT, 0, NULL);
      free_image(im);
      slice_data.clear();
   }

#endif   

   printf("\nExit: Finished the 3D point cloud data loading and slicing.\n");
}


// Function: load_point_cloud_as_images
// convert the txt file into image
//
// Command options - project.exe -l ..\data\Rotated.bpa -O "-s total_slices -x -X -y -Y -z -Z -d 0/1/2"
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -d 0" // get 1k sliced image bottom up
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -w 1000 -h 2048 -Z 45.0 -d 2" // get 1k sliced image left - right
// to mapping back from preprocessed key slice, using the following :
// z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1 - 40; =>
// 1053 = 2048 - ((x - 0.0) * (1000/(45.0 - 20.0)) + .5) - 41
// slice # = x/(44.0 - 0.0) = .542...
void load_point_cloud_as_images_h_outside(char *fn)
{
   char *path_prefix = "result/point_cloud_images";
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   // CHANGE: IMAGE_HEIGHT
   int IMAGE_WIDTH  = 1024;
   int IMAGE_HEIGHT =  392;
   int pre_slice_num = -1;

   // direction: 0 - Y axis (bottom up), 1 - Z axis (face to face), 2 - X axis (left to right)
   int direction = 0;
   int has_set_size = 0;

   // BOX : -36.2841 82.3821 -2.4001 80.6962 -15.4828 136.499
   // TEST: -x 20 -X 90 -z 20 -Z 60 -y -3.0 -Y 44.0
   double BOX_MIN_X = 20.0;
   double BOX_MAX_X = 90.0;
   double BOX_MIN_Y =  0.0;
   double BOX_MAX_Y = 44.0;
   double BOX_MIN_Z = 20.0;
   double BOX_MAX_Z = 60.0;
   
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "d:h:w:x:X:y:Y:z:Z:s:t:p:")) != EOF)
      {
         switch (c) {
            case 'd':
               direction = atoi(util_optarg);
               assert(direction == 0 || direction == 1 || direction == 2);
               break;
            case 'h':
               IMAGE_HEIGHT = atoi(util_optarg);
               has_set_size = 1;
               break;
            case 'w':
               IMAGE_WIDTH  = atoi(util_optarg);
               has_set_size = 1;
               break;
            case 's':
               pre_slice_num = atoi(util_optarg);
               break;
            case 'p':
               path_prefix = strdup(util_optarg);
               break;
            case 'x':
               BOX_MIN_X = atof(util_optarg);
               break;
            case 'X':
               BOX_MAX_X = atof(util_optarg);
               break;
            case 'y':
               BOX_MIN_Y = atof(util_optarg);
               break;
            case 'Y':
               BOX_MAX_Y = atof(util_optarg);
               break;
            case 'z':
               BOX_MIN_Z = atof(util_optarg);
               break;
            case 'Z':
               BOX_MAX_Z = atof(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   
   if (!has_set_size && direction == 1)
   {
      IMAGE_WIDTH  = 1024;
      IMAGE_HEIGHT = 744;
   } else if (!has_set_size && direction == 2 ){
      IMAGE_WIDTH  = 600;
      IMAGE_HEIGHT = 1024;
      BOX_MAX_Z = 50.0;
   }

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   vector<double> data;
   printf("loading data from file...\n");
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", z_s, y_s, x_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         if (x < BOX_MIN_X || x > BOX_MAX_X ||
             y < BOX_MIN_Y || y > BOX_MAX_Y ||
             z < BOX_MIN_Z || z > BOX_MAX_Z)
            continue;

         // rule out noise for Y axis (direction == 0)
         if (direction == 0 && !inside_3D_container_for_dir_0(x, y, z))
            continue;

         data.push_back(y); // push y first, so that index don't need to be add by 1 in the following.
         data.push_back(x);
         data.push_back(z);
      }
   }

   fclose(fid);

   // comment out me later
   // this is just used to generate a smaller bpa for debugging purpose.
   /*
   FILE *f_de = fopen("../data/debug_rotate.bpa", "w");
   for (int index = 0; index < data.size(); index += 3) {
      fprintf(f_de, "%f %f %f\n", data[index+2], data[index], data[index+1]);
   }
   fclose(f_de);
   exit(0);
   */
   // end of comment
   
   // starting write data into image;
   assert(data.size() % 3 == 0);

   double diff_x = BOX_MAX_X - BOX_MIN_X;
   double diff_y = BOX_MAX_Y - BOX_MIN_Y;
   double diff_z = BOX_MAX_Z - BOX_MIN_Z;
   int slice_total = pre_slice_num == -1 ? 200 : pre_slice_num;
   int slice_number =  0;

   // CHANGE: diff_y
   double dir_diff = (direction == 0) ? diff_y : (direction == 1) ? diff_z : diff_x;
   double slice_int =  dir_diff / slice_total;
   vector<double> slice_data;
   for (int i = 0; i < slice_total; i ++)
   {
      printf("\nLoad: Processing slice #%d, ", i);
      // find out the appropriate points
      // CHANGE: BOX_MIN_Y   
      double BOX_MIN = (direction == 0) ? BOX_MIN_Y : (direction == 1) ? BOX_MIN_Z : BOX_MIN_X;
      double slice_min = i*slice_int + BOX_MIN;
      double slice_max = slice_min + slice_int;
      for (int index = 0; index < data.size(); index += 3)
      {
         // CHANGE: index
         int index_ = (direction == 0) ? index : (direction == 1) ? index+2 : index+1;
         if (data[index_] > slice_min && data[index_] < slice_max)
         {
            slice_data.push_back(data[index+2]);  // z axis
            slice_data.push_back(data[index]);    // y axis
            slice_data.push_back(data[index+1]);  // x axis
         }
      }

      /*
      if (slice_data.size() == 0)
         continue;
      */

      printf("found data/image, slice number: %d, slice_min: %f.", slice_number, slice_min);
      // z - height, x - width, y - 3D high
      BYTE **im = new_image(IMAGE_HEIGHT, IMAGE_WIDTH);
      // CHANGE: diff_x
      double dir_scale_diff = (direction == 2) ? diff_z : diff_x;
      double scale = (double)IMAGE_WIDTH / dir_scale_diff;
      for (int i = 0; i < slice_data.size(); i+=3)
      {
         // CHANGE: BOX_MIN_Z
         int z_i;
         if (direction == 0)
            z_i = IMAGE_HEIGHT - (int)((slice_data[i] - BOX_MIN_Z) * scale + .5) - 1; // z
         else
            z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1 - 40; // y
         if (z_i < 0)
            continue;

         int x_i;
         if (direction == 2)
            x_i = (int)(((slice_data[i] - BOX_MIN_Z)/diff_z)*IMAGE_WIDTH  + .5); // z
         else
            x_i = (int)(((slice_data[i+2] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
         if (x_i == IMAGE_WIDTH)
            x_i -= 1;
         
         im[z_i][x_i] = BLACK;

      }

      char ofn[1000];
      char *ds = digit_string(4, slice_number++);
      sprintf(ofn, "%s/image_slice_%s.png", path_prefix, ds);
      free(ds);
      Save2File(ofn, im, NULL, IMAGE_WIDTH, IMAGE_HEIGHT, 0, NULL);
      free_image(im);
      slice_data.clear();
   }

   printf("\nExit: Finished the 3D point cloud data loading and slicing.\n");
}

// Function: load_point_cloud_as_bounding_box
// Compute the bounding box for a dataset
//
void load_point_cloud_as_bounding_box(char *fn)
{
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   double x_min = 100000;
   double x_max = -10000;
   double y_min = 100000;
   double y_max = -10000;
   double z_min = 100000;
   double z_max = -10000;
   vector<double> data;
   printf("loading data from file...\n");
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         if ( x > x_max )
            x_max = x;
         if ( x < x_min )
            x_min = x;
         if ( y > y_max )
            y_max = y;
         if ( y < y_min )
            y_min = y;
         if ( z > z_max )
            z_max = z;
         if ( z < z_min )
            z_min = z;

      }
   }
   fclose(fid);

   printf(" X : [%f - %f], Y : [%f - %f], Z : [%f - %f]\n", x_min, x_max, y_min, y_max, z_min, z_max);
   printf(" %f_%f_%f_%f_%f_%f\n", x_min, x_max, y_min, y_max, z_min, z_max);

}

// Function: load_point_cloud_for_bounding_box
// Compute the bounding box for a dataset
//
vector<double>* load_point_cloud_for_bounding_box(char *fn, vector<double> &data)
{
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return NULL;
   }

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   double x_min = 100000;
   double x_max = -10000;
   double y_min = 100000;
   double y_max = -10000;
   double z_min = 100000;
   double z_max = -10000;
   printf("loading data from file %s ...\n", fn);
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         data.push_back(y);
         data.push_back(x);
         data.push_back(z);

         if ( x > x_max )
            x_max = x;
         if ( x < x_min )
            x_min = x;
         if ( y > y_max )
            y_max = y;
         if ( y < y_min )
            y_min = y;
         if ( z > z_max )
            z_max = z;
         if ( z < z_min )
            z_min = z;

      }
   }
   fclose(fid);

   printf(" X : [%f - %f], Y : [%f - %f], Z : [%f - %f]\n", x_min, x_max, y_min, y_max, z_min, z_max);

   vector<double> *result = new vector<double>();

   result->push_back(x_min);
   result->push_back(x_max);
   result->push_back(y_min);
   result->push_back(y_max);
   result->push_back(z_min);
   result->push_back(z_max);

   return result;
}

// Function: load_point_cloud_as_images
// convert the txt file into image
//
// Command options - project.exe -l ..\data\Rotated.bpa -O "-s total_slices -x -X -y -Y -z -Z -d 0/1/2"
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -d 0" // get 1k sliced image bottom up
// project.exe -l ..\data\Rotated.bpa -O "-s 1000 -w 1000 -h 2048 -Z 45.0 -d 2" // get 1k sliced image left - right
// to mapping back from preprocessed key slice, using the following :
// z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1 - 40; =>
// 1053 = 2048 - ((x - 0.0) * (1000/(45.0 - 20.0)) + .5) - 41
// slice # = x/(44.0 - 0.0) = .542...
void load_point_cloud_as_images(char *fn)
{
   int load_type = -1;
   char *opt_backup;
   
   if (global_opts)
   {
      opt_backup = strdup(global_opts);
      
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "d:h:w:x:X:y:Y:z:Z:s:t:p:")) != EOF)
      {
         switch (c) {
            case 't':
               load_type = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   if (global_opts)
      free(global_opts);
   global_opts = strdup(opt_backup);
   
   if ( load_type == 0 ) {
      load_point_cloud_as_images_h_outside(fn);
   } else if ( load_type == 1) {
      load_point_cloud_as_images_h_inside(fn);
   } else {
      load_point_cloud_as_bounding_box(fn);
   }

}

// direction: 0 - Y axis (bottom up), 1 - Z axis (face to face), 2 - X axis (left to right)
void project_point_cloud_into_image(vector<double> &data, char *path_prefix,
                                    int direction, int slice_total,
                                    double BOX_MIN_X, double BOX_MAX_X,
                                    double BOX_MIN_Y, double BOX_MAX_Y,
                                    double BOX_MIN_Z, double BOX_MAX_Z
                                    )
{
   char *value;
   if ( readRunTimeFlag("do_not_dump_images_from_point_cloud", &value ) && strcmp(value, "1") == 0 )
      return;
   
   double x, y, z;
   printf("loading data from with dir %d, [%.3f, %.3f] [%.3f, %.3f] [%.3f, %.3f] ...\n", direction, BOX_MIN_X, BOX_MAX_X,
          BOX_MIN_Y, BOX_MAX_Y, BOX_MIN_Z, BOX_MAX_Z);

   assert(data.size() % 3 == 0);

   double diff_x = BOX_MAX_X - BOX_MIN_X;
   double diff_y = BOX_MAX_Y - BOX_MIN_Y;
   double diff_z = BOX_MAX_Z - BOX_MIN_Z;
   int slice_number =  0;

   // CHANGE: diff_y
   double dir_diff = (direction == 0) ? diff_y : (direction == 1) ? diff_z : diff_x;
   double slice_int =  dir_diff / slice_total;

   double BOX_MIN = (direction == 0) ? BOX_MIN_Y : (direction == 1) ? BOX_MIN_Z : BOX_MIN_X;
   double BOX_MAX = (direction == 0) ? BOX_MAX_Y : (direction == 1) ? BOX_MAX_Z : BOX_MAX_X;
   vector<vector<int> > slice_group(slice_total);
   for (int index = 0; index < data.size(); index += 3)
   {
      // CHANGE: index
      int index_ = (direction == 0) ? index : (direction == 1) ? index+2 : index+1;

      if ( data[index_] > BOX_MAX || data[index_] < BOX_MIN )
         continue;
      
      int group_index = (int) (((data[index_] - BOX_MIN)/dir_diff)*slice_total);
      if ( group_index == slice_total )
         group_index --;
      
      slice_group[group_index].push_back(index);
   }
   
   
   for (int group_index = 0; group_index < slice_total; group_index ++)
   {
      printf("Load: Processing slice #%d with data %d, \n", group_index, slice_group[group_index].size());

      // z - height, x - width, y - 3D high
      BYTE **im = new_image(image_height, image_width);
      // CHANGE: diff_x
      double dir_scale_diff = (direction == 2) ? diff_z : diff_x;
      double scale = (double)image_width / dir_scale_diff;
      vector<double> slice_data;
      for (int i = 0; i < slice_group[group_index].size(); i++)
      {
         int data_index = slice_group[group_index][i];
         slice_data.push_back(data[data_index+2]);  // z axis
         slice_data.push_back(data[data_index]);    // y axis
         slice_data.push_back(data[data_index+1]);  // x axis
         
         // CHANGE: BOX_MIN_Z
         int z_i;
         if (direction == 0)
            z_i = image_height - (int)((slice_data[0] - BOX_MIN_Z) * scale + .5) - 1; // z
         else
            z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1; // y
         if (z_i < 0) {
            slice_data.clear();
            continue;
         }

         int x_i;
         if (direction == 2)
            x_i = (int)(((slice_data[0] - BOX_MIN_Z)/diff_z)*image_width  + .5); // z
         else
            x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
         if (x_i == image_width)
            x_i -= 1;

         if ( valid_pixel(x_i, z_i) )
            im[z_i][x_i] = BLACK;
         
         slice_data.clear();

      }

      char ofn[1000];
      char *ds = digit_string(4, slice_number++);
      sprintf(ofn, "%s/image_slice_%s.png", path_prefix, ds);
      free(ds);

      if ( gbl_opts->BBM_using_bounding_box_mask ) 
         clear_slices_using_mask(im, group_index);
      
      Save2File(ofn, im, NULL, image_width, image_height, 0, NULL);
      free_image(im);
   }

}

/* 
//	Function: compute_simple_symmetry_test
//  Use simple method for symmetry calculation.
//
//  Command option: project.exe -O "-s 0 -e 999" -1
*/
void compute_simple_symmetry_test()
{
   char *path_input = "result/point_cloud_images/slices_1000_0.0_44.0_cleaned";
   char *path_output = "result/point_cloud_images/slices_1000_0.0_44.0_recovered";
      
#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif
   DIST **distance_LUT = NULL;
   BYTE **mimio_image;
   int h, w;
   int start_x = 531, end_x = 541;
   bool oneImageOnly = false;
   int sym_value = -1;

   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "e:s:p:P:t:b")) != EOF)
      {
         switch (c) {
            case 'p':
               path_output = strdup(util_optarg);
               break;
            case 'P':
               path_input = strdup(util_optarg);
               break;
            case 's':
               start_x = atoi(util_optarg);
               break;
            case 't':
               sym_value = atoi(util_optarg);
               break;
            case 'b':
               oneImageOnly = true;
               break;
            case 'e':
               end_x = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   // project.exe -O "-b -t xx" -F input_image -f output_image -1
   if ( oneImageOnly ) {
      assert( sym_value != - 1);
      assert( gbl_opts->input_prefix );
      assert( gbl_opts->output_prefix );

      orig_img = load_image(gbl_opts->input_prefix, h, w);
      set_image(mimio_image, orig_img);

      int symmetry_value = sym_value;
      
      printf("RECOVER: Processing slice %s ...\n", gbl_opts->input_prefix);
      {
         BYTE **new_image = NULL;
         int x, y;
         
         new_image = copy_image(mimio_image, h, w);
         
         for (y = 1; y < h-1; y ++)
            for (x = 1; x < w-1; x ++)
               if (new_image[y][x] == BLACK)
               {
                  // Calculate the reflected pixel.
                  int x_prime = 2*sym_value - x; // No matter x > sym or x < sym.
                  if (x_prime > w-1 || x_prime < 1) 
                     continue;

                  mimio_image[y][x_prime] = BLACK;

               }

         free_image(new_image);
      }
      //miss_data_recover(mimio_image, symmetry_value, h, w);
      Save2File(gbl_opts->output_prefix, mimio_image, NULL, w, h, 0, NULL);

      free_image(mimio_image);
      delete orig_img;

      return;
   }
      
   char fn[1000];
   for (int i=start_x; i < end_x; i ++)
   {
      char *ds = digit_string(4, i);
      sprintf(fn, "%s/image_slice_%s.png", path_input, ds);
      orig_img = load_image(fn, h, w);
      set_image(mimio_image, orig_img);

      /*
      // Compute the distance matrix
      distance_LUT = set_distance_table(mimio_image, h, w);

      // Finding symmetry line
      int symmetry_value = find_symmetry(distance_LUT,  mimio_image, h, w);

      printf("\nThe symmetry line is x = %d, for %s\n", symmetry_value, ds);

      continue;
      draw_symmetry(mimio_image, h, symmetry_value);
      Save2File("symmetry_ttt.png", mimio_image, NULL, w, h, 0, NULL);

      */

      int symmetry_value = 507; // computed already.  (506 of 1024 - a few)
      printf("RECOVER: Processing slice %s ...\n", ds);
      miss_data_recover(mimio_image, symmetry_value, h, w);
      sprintf(fn, "%s/image_slice_%s.png", path_output, ds);
      Save2File(fn, mimio_image, NULL, w, h, 0, NULL);

      free_image(mimio_image);
      delete orig_img;
      free(ds);
   }

}

// Function: has_significant_change
// Check whether two images are similiar to each other or not.
// 
bool has_significant_change(BYTE **ref_im, BYTE **cur_im, int h, int w, int matching_approach)
{
   if (ref_im == cur_im)
      return false;

   if (matching_approach == 0)  // Hausdorff distance approach
   {
      // compute the Hausdorff distance between the images
      vector<int> *v1 = compute_Hausdorff(ref_im, cur_im, h, w);
      vector<int> *v2 = compute_Hausdorff(cur_im, ref_im, h, w);

      sort(v1->begin(), v1->end(), greater<int>());
      sort(v2->begin(), v2->end(), greater<int>());      

      // for testing - compare the hausdorff distance - better use emacs.
      //for (int i = 0; i < v1->size(); i ++)
      // fprintf(comp_res, "%3d",  (*v1)[i]);

      // based on observation, 10% is the best ratio for comparison.
      // compute the average value for the 10% biggest distance.
      // e.g., use 83 as reference image, the average value until 92 is 1.2-1.5,
      // starting from 93, it is 5.x - 6.x.. If use 93 as reference, the average
      // value until 115 around 3.x. so use the middle vale 4-4.5 as the threshold.
      
      // 2.0 - KEY THRESHOLD ...
      // const float HD_THRESH = 5.0;

      // 0.1 - KEY THRESHOLD ...
      double data_per = gbl_opts->KSD_HD_data_percentage;
      double average_dis  = average_HD(v1, data_per);
      double average_dis2 = average_HD(v2, data_per);

      delete v1;
      delete v2;
      

      //if (max(average_dis, average_dis2) > HD_THRESH )
      if ((average_dis + average_dis2)/2 > gbl_opts->KSD_HD_diff_threshold)
         return true;

      return false;
      
   }
   else if (matching_approach == 1) // landing approach
   {
      int num_ref_im_bound = 0;
      int num_cur_im_bound = 0;
      int num_common = 0;
      int num_new =0;
      for (int i = 0; i < h; i ++)
         for (int j = 0; j < w; j ++)
         {
            if (ref_im[i][j] == BLACK)
               num_ref_im_bound ++;
         
            if (cur_im[i][j] == BLACK){
               num_cur_im_bound ++;

               if (ref_im[i][j] == BLACK)
               {
                  num_common ++;
               }
               else {
      // 2 - KEY THRESHOLD ...
                  // noise data, counted as matched
                  if (neighbor_prob(i, j, 2, BLACK,ref_im, h, w) > 0)
                  {
                     num_common ++;
                  }
                  else{  // missing data? - BLUE
                     num_new ++;
                  }
               }
            }

         }

      // if the total unmatched pixels in the current image is greater than 20%,
      // consider this as a change.
      // the reason using stat1 and stat2 is, sometimes, reference image has more pixels than current image,
      // but sometimes, current image has more pixels or data than reference image.
      float stat1 = (float)(num_cur_im_bound - num_common)/(float)num_cur_im_bound;
      float stat2 = (float)(num_ref_im_bound - num_common)/(float)num_ref_im_bound;
      float stat  = min(stat1, stat2);

      // 10% - KEY THRESHOLD ...
      if (stat > .1 )
         return true;

      return false;

   }
   else
   {
      printf("wrong parameter matching_approach, exiting....\n");
      exit(0);
   }
}

// Function: compute_key_slices
// Big loop to compute the key slices.
//
void compute_key_slices(int starting_num, int ending_num, int offset, int matching_approach, char *prefix)
{

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif
   char pre_str[1000];
   char out_str[1000];
   char bnd_str[1000];
   char out_str_int[1000];
   sprintf(pre_str, "%s_recovered/image_slice_0", prefix);
   sprintf(out_str, "%s/image_slice_0", gbl_opts->output_prefix);
   sprintf(bnd_str, "%s_boundary/image_slice_0", prefix);
   sprintf(out_str_int, "%s/aaa_image_slice_0", gbl_opts->output_prefix);

   /*   
   char *pre_str = "result/point_cloud_images/slices_1000_0.0_44.0_recovered/image_slice_0";
   char *out_str = "result/point_cloud_images/slices_1000_0.0_44.0_result/image_slice_0";
   char *bnd_str = "result/point_cloud_images/slices_1000_0.0_44.0_boundary/image_slice_0";
   char *out_str_int = "result/point_cloud_images/slices_1000_0.0_44.0_result/aaa_image_slice_0";
   */
   char out_log[1000];
   sprintf(out_log, "%s/comp_log.txt", gbl_opts->output_prefix);
   char ifn[1000], ofn[1000], bfn[1000];

   BYTE **cur_im, **ref_im, **free_im;
   int h, w;
   FILE *flog = fopen(out_log, "w");
   assert(flog);
   vector<int> key_index;
   for (int i = starting_num; i != ending_num; i += offset)
   {
      char *ds = digit_string(3, i);
      sprintf(ifn, "%s%s.png", pre_str, ds);
      sprintf(ofn, "%s%s.png", out_str, ds);
      sprintf(bfn, "%s%s.png", bnd_str, ds);
      free(ds);

      orig_img = load_image(ifn, h, w);
      set_image(cur_im, orig_img);

      if (i == starting_num)
      {
         ref_im = boundary_detect(cur_im, h, w);
         mark_image(cur_im, 0);
         key_index.push_back(i);
         fprintf(flog, "%d\n", i);
         //Save2File(bfn, ref_im, NULL, w, h, 0, NULL);
         //Save2File(ofn, cur_im, NULL, w, h, 0, NULL);

         // free the first image.
         delete orig_img;
         free_image(cur_im);
         continue;
      }

      printf("Processing image index %d ...\n", i);

      BYTE **orig_cur_im = cur_im;
      cur_im = boundary_detect(cur_im, h, w);
      free_im = cur_im;

      if (has_significant_change(ref_im, cur_im, h, w, matching_approach))
      {
         free_im = ref_im;
         ref_im  = cur_im;
         mark_image(orig_cur_im, 0);
         key_index.push_back(i);
         fprintf(flog, "%d\n", i);
         printf("Key slice detected : ====%d====\n", i);
      }

      //Save2File(ofn, orig_cur_im, NULL, w, h, 0, NULL);
      //Save2File(bfn, cur_im, NULL, w, h, 0, NULL);
      
      // free memory not used.
      free_image(orig_cur_im);
      free_image(free_im);
      delete orig_img;
   }

   // compute the real key slice based on the vector<int> key_index, provided tapered structure exists.
   // This approach is based on two category, tapered region and extruded region.
   // For tapered region, we consider each key index as a key slices, but for non-tapered region, we do
   // 1. if the adjancent number in key_index is large enought, say 5, then both are consider as key slices.
   // 2. test if we are entering tapered structure:
   //    *. If for the following TAPERED_NUM key index, the total number of slices is less than 50, but greater than 25
   //    *. If the median interval between two adjance index is in [3, 4].
   fprintf(flog, "=======================\n");

   vector<int> key_slice;
   if (gbl_opts->KSD_contains_tapered_structure)
   {
      // 5 - STABLE_OFFSET Important threshold
      const int STABLE_OFFSET = 5;
      const int TAPERED_NUM = 10;
      bool tapered_key_slice = false;
      for (int i = 0; i < key_index.size() - 1; i ++)
      {
         if (key_index[i+1] - key_index[i] > STABLE_OFFSET)
         {
            fprintf(flog, "%d\n", key_index[i]);
            key_slice.push_back(key_index[i]);
         
            if (tapered_key_slice)
            {
               tapered_key_slice = false;
               printf("Tapered slices end at %d\n", key_index[i]);
            }

         } else {

            if (tapered_key_slice)
            {
               fprintf(flog, "%d\n", key_index[i]);
               key_slice.push_back(key_index[i]);
            }
         
            // distinguish unstable slices from tapered structure.
            // The tapered structure usually has even intervals, and the minimum key slices will be 10,
            // and each interval is between 3 and 4.
            if (!tapered_key_slice && key_index.size() - i > TAPERED_NUM)
            {
               if (key_index[i + TAPERED_NUM] - key_index[i] < 50 &&
                   key_index[i + TAPERED_NUM] - key_index[i] > 25)
               {
                  vector<int> slice_int;
                  for (int j = i; j < i + TAPERED_NUM; j ++)
                     slice_int.push_back(key_index[j+1] - key_index[j]);
                  sort(slice_int.begin(), slice_int.end(), greater<int>());

                  // the median value should be in [3, 4]
                  if (slice_int[TAPERED_NUM/2] >= 3 &&
                      slice_int[TAPERED_NUM/2] <= 4)
                  {
                     tapered_key_slice = true;
                     printf("Tapered slices start at %d\n", key_index[i]);
                     fprintf(flog, "%d\n", key_index[i]);
                     key_slice.push_back(key_index[i]);
                  }
               }
            }
         }
      }

      key_slice.push_back(key_index[key_index.size() - 1]);
      fprintf(flog, "%d", key_index[key_index.size() - 1]);

   } else {

      // regard all the key_index as key slice or we can bundle them.
      // here, we define the bundle distance as KSD_least_key_slice_interval.
      key_slice.push_back(key_index[0]);
      int ref_index = 0;
      for (int i = 0; i < key_index.size(); i ++)
      {
         if (key_index[i] - key_index[ref_index] >= gbl_opts->KSD_least_key_slice_interval)
         {
            ref_index = i;
            key_slice.push_back(key_index[i]);
         }
      }
   }
   
   // now let's compute the integrated image based on the key slices
   // assume ending_num is larger than starting_num
   int key_slice_index = 1;
   BYTE **integrated_im;
   int len = w*h;
   for (int i = starting_num; i != ending_num; i += offset)
   {
      char *ds = digit_string(3, i);
      sprintf(ifn, "%s%s.png", pre_str, ds);

      orig_img = load_image(ifn, h, w);
      set_image(cur_im, orig_img);

      if ( key_slice_index == key_slice.size() || i < key_slice[key_slice_index])
      {
         if ( i == starting_num)
         {
            integrated_im = cur_im;
            delete orig_img;
            free (ds);
            continue;
         }
         
         for (int j = 0; j < len; j++)
            integrated_im[0][j] |= cur_im[0][j];

         // the last integrated image.
         if ( i == ending_num - offset)
         {
            sprintf(ofn, "%s%s.png", out_str_int, ds);
            printf("Integratged the file %s...\n", ofn);
            Save2File(ofn, integrated_im, NULL, w, h, 0, NULL);
            free_image(integrated_im);
         }

         free(cur_im);
      }
      else {

         // save integrated image
         sprintf(ofn, "%s%s.png", out_str_int, ds);
         printf("Integratged the file %s...\n", ofn);
         Save2File(ofn, integrated_im, NULL, w, h, 0, NULL);

         free_image(integrated_im);
         integrated_im = cur_im;

         // new the integrate image
         key_slice_index ++;
      }

      free(ds);
      delete orig_img;
   }

   fclose(flog);
   
}

// FUNCTION: key_slices_detection
//
// this function is used to detect key slices in the 3D point cloud
// Command option: -K -O "-a -L -r -R -I 3 -T"
//
// Parameters:
//     KSD_least_key_slice_interval - This value is used to merge very closed key slices.
//                                    In other words, two adjance slices is less than this number are considered as one key slice.
//     KSD_contains_tapered_structure - Prior Knowledge about the 3D data, ie, whether this direction has tapered structure or not.
//
void key_slices_detection()
{
   int ref_slice_num = 0;
   int lmost_slice_num = 0;
   int rmost_slice_num = 100;
   int matching_approach = 0; /* 0: Hausdorff Distance, 1: landing */
   int algorithm_type = 0;    /* 0: old KSD, 1: new/local based KSD */
   int seg_approach = 0;      /* 1: graph-cut, 0: CC */
   char *prefix = "result/point_cloud_images/slices_left_right_600_1024";
   gbl_opts->output_prefix = NULL;
   char *IR_fn = NULL;
   char *IR_fn1 = NULL;
   char *prefix_dir = NULL;
   void **params = NULL;
   int mask = 5;
   float thres_region[1];
   float thres_data[1];
   float tau_d[1];

   thres_region[0] = 0.5;
   thres_data[0] = 0.4;
   tau_d[0] = -1.0;
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:A:b:B:c:D:d:f:F:L:h:I:p:P:O:r:s:S:R:t:Tw:")) != EOF)
      {
         switch (c) {
            case 's':
               /* total slices */
               gbl_opts->total_slices = atoi(util_optarg);
               break;
            case 'S':
               /* segmentation approach */
               seg_approach = atoi(util_optarg);
               break;
            case 'h':
               /* image height */
               image_height = atoi(util_optarg);
               break;
            case 'w':
               /* image width */
               image_width = atoi(util_optarg);
               break;
            case 'a':
               /* matching approach */
               matching_approach = atoi(util_optarg);
               break;
            case 'b':
               /* mask threshold */
               mask = atoi(util_optarg);
               break;
            case 'B':
               /* region threshold */
               thres_region[0] = atof(util_optarg);
               break;
            case 't':
               /* tau_d threshold */
               tau_d[0] = atof(util_optarg);
               break;
            case 'c':
               /* data threshold */
               thres_data[0] = atof(util_optarg);
               break;
            case 'A':
               /* KSD algorithm  */
               algorithm_type = atoi(util_optarg);
               break;
            case 'r':
               /* reference slice ID */
               ref_slice_num = atoi(util_optarg);
               break;
            case 'I':
               /* Least key slice interval */
               gbl_opts->KSD_least_key_slice_interval = atoi(util_optarg);
               break;
            case 'd':
               /* Threshold for differentiating different slices */
               gbl_opts->KSD_HD_diff_threshold = atof(util_optarg);
               break;
            case 'p':
               /* Data percentage for HD */
               gbl_opts->KSD_HD_data_percentage = atof(util_optarg);
               break;
            case 'P':
               /* Prefix for path */
               prefix = strdup(util_optarg);
               break;
            case 'O':
               /* Prefix for output path */
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'f':
               /* file name for IR */
               IR_fn = strdup(util_optarg);
               break;
            case 'D':
               /* prefix for direction */
               prefix_dir = strdup(util_optarg);
               break;
            case 'F':
               /* file name for IR */
               IR_fn1 = strdup(util_optarg);
               break;
            case 'T':
               /* contains tapered structure */
               gbl_opts->KSD_contains_tapered_structure = 1;
               break;
            case 'L':
               /* left most slice ID */
               lmost_slice_num = atoi(util_optarg);
               break;
            case 'R':
               /* right most slice ID */
               rmost_slice_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(ref_slice_num >= 0);
   assert(lmost_slice_num >= 0);
   assert(rmost_slice_num >= 0);
   assert(gbl_opts->output_prefix != NULL);

   if ( algorithm_type == 1 ) {
      
      printf("New Algorithm based on Graph-Cut\n");
      assert(IR_fn);
      assert(gbl_opts->total_slices > 0 );
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)lmost_slice_num;
      params[2] = (void *)rmost_slice_num;
      params[3] = (void *)gbl_opts->output_prefix;
      params[4] = (void *)IR_fn;
      params[5] = (void *)mask;
      params[6] = (void *)thres_region;
      params[7] = (void *)thres_data;
      params[8] = (void *)tau_d;
      params[9] = (void *)seg_approach;

      ksd_with_segmentation(params);
      free(params);
      return;
   }

   if ( algorithm_type == 2 ) {
      
      printf("test on contour updating\n");
      assert(IR_fn);
      assert(gbl_opts->total_slices > 0 );
      assert(image_height);
      assert(image_width);
         
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)IR_fn;
      params[2] = (void *)gbl_opts->output_prefix;
      params[3] = (void *)mask;

      bpa_update_contours(params);
      free(params);
      return;
   }

   if ( algorithm_type == 3 ) {
      
      printf("test on follow-me structure detection.\n");
      assert(IR_fn);
      assert(IR_fn1);
         
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)IR_fn;
      params[2] = (void *)gbl_opts->output_prefix;
      params[3] = (void *)mask;
      params[4] = (void *)IR_fn1;
      params[5] = (void *)seg_approach;

      ksd_follow_me_detect(params);
      free(params);
      return;
   }

   if ( algorithm_type == 4 ) {
      
      printf("Tapered (to-point|to-line) Structures with New Algorithm based on Graph-Cut \n");
      assert(IR_fn);
      assert(gbl_opts->total_slices > 0 );
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)lmost_slice_num;
      params[2] = (void *)rmost_slice_num;
      params[3] = (void *)gbl_opts->output_prefix;
      params[4] = (void *)IR_fn;
      params[5] = (void *)mask;
      params[6] = (void *)thres_region;
      params[7] = (void *)thres_data;
      params[8] = (void *)tau_d;
      params[9] = (void *)seg_approach;

      ksd_with_segmentation_and_tapers(params);
      free(params);
      return;
   }

   if ( algorithm_type == 5 ) {
      
      printf("New Algorithm based on Data Fusion in ALL dirs.\n");
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)lmost_slice_num;
      params[2] = (void *)rmost_slice_num;
      params[3] = (void *)gbl_opts->output_prefix;
      params[4] = (void *)mask;
      params[5] = (void *)prefix_dir;
      params[6] = (void *)ref_slice_num;

      ksd_all_info_fusion(params);
      free(params);
      return;
   }

   if ( algorithm_type == 6 ) {
      
      printf("Zipper facades from all directions.\n");
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)lmost_slice_num;
      params[2] = (void *)rmost_slice_num;
      params[3] = (void *)gbl_opts->output_prefix;
      params[4] = (void *)mask;
      params[5] = (void *)prefix_dir;
      params[6] = (void *)thres_region;

      ksd_zipper_boundary(params);
      free(params);
      return;
   }


   if ( algorithm_type == 7 ) {
      
      printf("Compute intersection plane of two extruded models .\n");
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)prefix;
      params[1] = (void *)lmost_slice_num;
      params[2] = (void *)rmost_slice_num;
      params[3] = (void *)gbl_opts->output_prefix;
      params[4] = (void *)mask;
      params[5] = (void *)prefix_dir;

      ksd_extrusion_intersection(params);
      free(params);
      return;
   }
   
   
   printf("matching approach:%s\n", matching_approach == 0 ? "Hausdorff distance" : "Pixel landing");
   // Now we are about to infer key slices in the range of [lmost, rmost], remember ref_slice_num itself is a
   // key slice. we should mark a flag for key slices.
   // The key slices are detected as:
   // 1. obtain the boundary of the slice.
   // 2. compare the similarity of the boundaries based on Hausdorff distance.
   // 3. mark those slices as key slices.

   compute_key_slices(ref_slice_num, rmost_slice_num,  1, matching_approach, prefix);
   //compute_key_slices(ref_slice_num, lmost_slice_num, -1, matching_approach);

}

// Function: get_the_starting_point_prep
// A helper function for <BPA_boundary>
void get_the_starting_point_prep(BYTE **cur_im, deque<int> &points, int rad, int &p1)
{
   int h = image_height;
   int w = image_width;
   
   // sweep from left to right
   for (int y = 0; y < h; y ++)
   {
      int mid_pos = w / 2;
      for (int x = 0; x < mid_pos; x++)
      {
         // the first point is treated as starting point
         if (cur_im[h-y-1][x] == BLACK)
         {
            points.push_back(index(x, h-y-1));
            p1 = index(x - 2*rad, h-y-1);
            return;
         }
      }
   }



}

// Function: ball_pivoting_prep
// function for pivoting the ball
//
void ball_pivoting_prep(BYTE **cur_im, deque<int>& points, int rad, int p1, BYTE **&debug_im, int sep_num, POINTS_AUX *points_aux)
{
   int look_ahead_num = 20/rad + 4 ; // threshold look_ahead_num is used to check whether the ball has turn around.
   int looked_num = 0;               // record how many times we have seen
   double starting_orig_angle = 0.0; // record the starting point of the angle.
   bool reversed_direction = false;  // indication of reverse direction.
   double *looked_angle = (double *) malloc(sizeof(double) * look_ahead_num); // circle FIFO like recording.
   
   
   int h = image_height;
   int w = image_width;

   // draw a circle of radius rad
   // assume normal (0,1);
   int x = x_axis(points[0]);
   int y = y_axis(points[0]);
   
   // temp test
   assert(points.size() == 1);
   int starting_point = index(x, y);

   // st_connected_points is used to record all points in the trajactory of the boundary.
   st_table *st_connected_points = st_init_table(st_numcmp, st_numhash);
   st_insert(st_connected_points, (char *)points[0], (char *)1);

   // define a debug image, which contains the circles and the original image
   if (!debug_im && DEBUG_BPA)
      debug_im = copy_image(cur_im, h, w);

   int x0 = x, y0 = y ;                  // the starting point of the data
   int x1 = x_axis(p1), y1 = y_axis(p1); // the ending point of the pivot axis.
   int direction = -1;        // -1 is clock-wise, 1 is counter clock-wise.
   static int counter = 0;
   int local_counter = 0;

   double pace_degree = gbl_opts->pace_degree;
   int starting_x0 = x0, starting_x1 = x1;
   int starting_y0 = y0, starting_y1 = y1;
   BYTE ***boundary_im = new_3D_image(image_height, image_width);
   int color_switch = 0;
   while (true)
   {
      bool found = false;

      counter ++;
      local_counter ++;
      my_printf("\nNo[%3d]:", counter);

      // st_single_pivote is used to record a single pivot of the data point
      // That is, a record of old points visited.
      st_table *st_single_pivot = st_init_table(st_numcmp, st_numhash);

      // start pivot/rolling around a point, until a point is touched.
      double scan_angle = 0;
      double orig_angle = 0.0;
      vector<int> data_points;

      assert(x1 != x0 || y1 != y0);
      // compute the line with 10 degree from the orignal line
      if (x0 == x1)
         orig_angle = y0 > y1 ? 90.0 : -90.0;
      else
      {
         // here, we assume the angle is from right-bound x axis to the L(P0-P1)
         // counter-clock wise is positive (0 - 180), clock-wise is negative (-0.0 - -180.0)
         orig_angle = (atan((double)(-1)*(y1-y0)/(double)(x1-x0))) * 180.0 / PI;

         if (y1 < y0 && orig_angle < 0)
            orig_angle += 180.0;
         else if (y1 > y0 && orig_angle > 0)
            orig_angle -= 180.0;
         else if (y1 == y0 && x1 > x0)
            orig_angle = 0.0;
         else if (y1 == y0 && x1 < x0)
            orig_angle = direction * 180.0;
      }

      my_printf("==<P1_P0_X>[%4.2f], P0[%3d,%3d], P1[%3d,%3d]", orig_angle, x0, y0, x1, y1);

      int last_x1 = x1, last_y1 = y1;
      int last_x0 = x0, last_y0 = y0;
#if 0      
      while (scan_angle < 360)
      {
         // use double to get more accurate value
         // *1_prime is the end point
         // *_prime  is the middle point, i.e., the center of the circle.
         double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
         double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
         int y_prime = (int)((y1_prime + y0)/2);
         int x_prime = (int)((x1_prime + x0)/2);

         // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
         // be touch too early.
         vector<int> *cir_area = arc_region(x_prime, y_prime, (int)x1_prime, (int)y1_prime, 180, rad-1, direction);

         last_x1 = (int)x1_prime;
         last_y1 = (int)y1_prime;

         vector<int> *test_vec = new vector<int>;
         for (int i = 0; i < cir_area->size(); i++)
            if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
            {
               st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
               test_vec->push_back((*cir_area)[i]);
            }

         // if data found, calculate the center of the circle, compare all the centers.
         vector<int> *tmp = find(cur_im[0], test_vec, BLACK);
         data_points = *tmp;
         delete tmp;  // here, since we have copied the data into data_points, so we can delete it.

         // local_counter is used to make sure that the ball at least pivoted a number of times
         // before reaching the starting points itself.
         // Also, if the a potential point in data_points is the boundary point, don't think it again
         // AND we should clear all points in data_points since they are all checked at this iteration.
         for (int i = 0 ; i < data_points.size(); i++)
            if (st_is_member(st_connected_points, (char *) data_points[i]))
            {
               if (local_counter > 10 && data_points[i] == starting_point)
                  continue;
               
               data_points.erase(data_points.begin() + i);
               i--;
            }
            else  // clear orignal image, this is used to fix the bug of stopped when dir=1;
            {
               cur_im[0][data_points[i]] = WHITE;
            }

         // if do debug_image, comment the 3 lines out
         //delete arc_area;
         delete test_vec;
         delete cir_area;

         if (data_points.size() > 0)
         {
            found = true;
            my_printf("==@ degree %3f", scan_angle);
            //draw_debug_image(*cir_area, counter);

            break;
         } 

         // else, go back to while with scan_angle += 10;
         scan_angle += pace_degree;

      }
#else
      ball_pivot_touch_data(scan_angle, data_points, last_x1, last_y1, found, rad, orig_angle,
                            direction, x0, y0, pace_degree, cur_im, local_counter, starting_point,
                            st_single_pivot, st_connected_points);
#endif      

      // some sanity check here
      st_free_table(st_single_pivot);

      // if no data found, or direction has been reversed, consider revise point.
      if (!found)
      {
         break;
      }

      // new data was found, find the smallest angle 
      // if found new data, add the new data into points, and st_connected_points
      // check if this new added data is already in the st_connected_points, if so, means the job is done.
      double smallest_angle = 2*PI+.1; // here, we add .1 to avoid assert error on LINUX only / no problem on Windows.
      int result_center;
      int result_point = -1;
      bpa_compute_connect(data_points, result_point, smallest_angle, result_center, rad, x0, y0, x1, y1, direction, scan_angle);
      assert(result_point != -1);

      // check whether we start to go down
      // the ONLY BREAK point?????????????
      // here, we should write case statement for left-right-top-bottom side.
      /*
      if (y_axis(result_point) < image_height /2)
      {
         break;
      }
      */
      if (y_axis(result_point) > y0)
      {
         break;
      }

      // when a new point is located, record the point itself, and the line between this
      // point and the center of the circle, which will be treated as a new starting point.
      // (x0, y0) - pivot point
      // (x1, y1) - arc end point
      
      // compute the (x1, y1) based on the result_point.
      x0 = x_axis(result_point);
      y0 = y_axis(result_point);

      // for (x1, y1), we know the angle between the reference line to the line [O, L0], so we
      // can get the O, then, it is trival to get the end point
      // algorithm 1
      // double center_y = y0 - rad*sin(PI*(orig_angle + direction*smallest_angle)/180.0);
      // double center_x = x0 - rad*cos(PI*(orig_angle + direction*smallest_angle)/180.0);
      // algorithm 2
      double center_y = y_axis(result_center);
      double center_x = x_axis(result_center);

      y1 = (int)(y0 - 2*(y0 - center_y));
      x1 = (int)(x0 - 2*(x0 - center_x));
      int points1 = index(x1, y1);

      st_insert(st_connected_points, (char *) result_point, (char *)1);
      points.push_back(result_point);
      points_aux->end_points.push_back(points1);
      points_aux->radius.push_back(rad);
      points_aux->colors.push_back(points_aux->colors.size() % 3);

      my_printf("==new P0[%3d,%3d], P1[%3d,%3d]", x0, y0, x1, y1);
      // draw the new circle for debug
      if (DEBUG_BPA)
         draw_circle(debug_im, (int) center_x, (int) center_y, rad);
      if (DEBUG_BPA > LOW_INFO && counter % sep_num == 0)
      {
         {
            char fn[100];
            char *ds = digit_string(4, counter);
            sprintf(fn, "bpa_debug_pivot__%s_rad_%d.png", ds, rad);
            free(ds);
            Save2File(fn, debug_im, NULL, image_width, image_height, 0, NULL);
         }
      }
   }

   // free the 3D image memory
   free_image_3D(boundary_im);
}

/* Function: ball_pivoting_refinement_prep

   This func is used to implement adaptive BPA.
   The basic idea is to check the line seg clockwisely starting from the beginning of the points,
   If a line seg is large than a threshold, say radius of a new ball size, try to re-pivot on this point based on the direction
   (stored in POINTS_AUX) and try to reach the next point.
      * what if the next point can never be reached? such as a new boundary is found, like ex3.
      * what if the next point was not exactly matched? 
*/
void ball_pivoting_refinement_prep(BYTE **cur_im, deque<int>& points, int rad, BYTE **&debug_im, int sep_num, POINTS_AUX *points_aux)
{
   assert(points.size() == points_aux->end_points.size());
   assert(points.size() == points_aux->radius.size());
   
   int look_ahead_num = 20/rad + 4 ; // threshold look_ahead_num is used to check whether the ball has turn around.
   double *looked_angle = (double *) malloc(sizeof(double) * look_ahead_num); // circle FIFO like recording.
   static int MAX_REFINE_NUMBER = rad == BPA_AFTER_ROUGH_RADIUS ? BPA_AFTER_ROUGH_REFINE_NUM : BPA_REGULAR_REFINE_NUM;
   
   
   int h = image_height;
   int w = image_width;

   /* To get more accurate boundary, a refinement process is applied after this initial pivoting.
      During the initial pivoting, we shall keep track of some information for further refinement, such as the coordinates and order of
      the boundary points detected by the BPA algorithm, and their directions. For debugging and visualization purpose, each boundary point
      is assigned a color (either red, green or blue). The first iteration of the refinement takes the half length of the original ball,
      namely 32/2 = 16 pixels. For each line (defined by two adjacent boundary points) detected by the initial BPA, we check whether it
      needs to be refined or not based on the following two criteria: 1. if this line is shorter than a threshold (half radius, namely
      16/2 = 8 pixel),  then this line needs no refinement during this iteration (may need refinement for further iteration where the
      radius is reduced.). 2. if the length of this line is larger than the threshold, then I checked how many real data landing on this
      line. If it exceeds a certain percentage, say 50%, then we do not need to do refinement on this line either (permanently).
   
      If refinement is needed on a line, the BPA algorithm with smaller ball size is applied as following: the first point and its direction
      are taken as input, and the smaller ball was pivoting on the original image, until EITHER it reached the end point of this line OR it
      turned around at a place where the refinement ball size is smaller than the gap. If it reached the other point of the line, which means
      this pivoting is effective and new points detected during the process are inserted into the boundary deque, together with their direction
      and colors assigned for further refinement. If the ball could not reach the other end of the line, all new points it detected are discarded.

      We can keep doing this refinement process (for each iteration, the ball size is reduced by half, namely 32, 16, 8, 4, ...) until the
      boundary detected is good enough for representing the original image. 
   */
 
   /* CHECK the length of the lines for re-pivot. */
   double thres_len = rad*rad;  // threshold for the length squre of the new radius.
   vector<int> insert_points;
   POINTS_AUX *insert_points_aux = new POINTS_AUX; // aux structure for new found points, this is similiar to points_aux.
   int refine_num = 1;
   int is_boundary_starting_point = 1;
   int boundary_starting_index = 0;
   st_table *st_boundary_starting_points = st_init_table(st_numcmp, st_numhash);
   for (int point_index = 0; point_index < points.size()-1; point_index ++)
   {

      int x_1st = x_axis(points[point_index]);
      int y_1st = y_axis(points[point_index]);
      int x_2nd = x_axis(points[point_index+1]);
      int y_2nd = y_axis(points[point_index+1]);

      int x_diff = x_2nd - x_1st;
      int y_diff = y_2nd - y_1st;

      // IF the line is short, continue,
      // Or if the the line is almost horizontal or vertical (this is just used as skipping lines, could be removed),continue,
      // The above is not so good, for example: --___--, assume it is connection vertically.
      // remove the 2nd condition for now.
      if ((x_diff*x_diff + y_diff*y_diff < thres_len/4))
      {
         continue;
      }

      assert(points.size() == points_aux->end_points.size());
      assert(points.size() == points_aux->radius.size());
      
      my_printf("\n The %dth point [%d, %d], 2nd [%d, %d] at pos:%d ", refine_num++, x_1st, y_1st, x_2nd, y_2nd, point_index);
      // reset the insert_points.
      if (insert_points.size() > 0)
      {
         assert (insert_points.size() == insert_points_aux->end_points.size());
         insert_points.clear();
         insert_points_aux->end_points.clear();
      }
      
      // re-pivot from (x_lst, y_lst) to (x_2nd, y_2nd) using new smaller ball.
      int x = x_1st;
      int y = y_1st;
      int starting_point = index(x, y);

      // define a debug image, which contains the circles and the original image
      if (!debug_im && ( 0 || DEBUG_BPA))
         debug_im = copy_image(cur_im, h, w);

      // st_connected_points is used to record all points in the trajactory of the boundary, the same as points, but
      // points is not good for search - O(n), this one is O(1)
      st_table *st_connected_points = st_init_table(st_numcmp, st_numhash);
      st_insert(st_connected_points, (char *)points[0], (char *)1);

      // this is for starting point looking up. If the point found is falling inside
      // this hash table, then it is considered a closed boundary is found.
      // right now, the neighbor-hood is 3x3 mask.
      st_table *st_starting_points = st_init_table(st_numcmp, st_numhash);
      for (int i = -3; i < 4; i ++)
         for (int j = -3; j < 4; j ++)
            st_insert(st_starting_points, (char *)index(x_2nd+i, y_2nd+j), (char *)1);
   
      int x0 = x, y0 = y ;                  // the starting point of the data
      int p1 = points_aux->end_points[point_index];
      int x1 = x_axis(p1), y1 = y_axis(p1); // the ending point of the pivot axis.

      // ISSUE: when doing multiple resolution of the BPA, the P1, i.e., the end point for direction,
      //        might be not the same. For example, the first P1 is from the basic BPA, but the next one
      //        could from the first refinement. THEREFORE, we need to record the radius in POINTS_AUX as well.
      int rad_old = points_aux->radius[point_index];
      x1 = (int) (0.5 + x0 + ((double)rad/(double)rad_old*(x1 - x0)));
      y1 = (int) (0.5 + y0 + ((double)rad/(double)rad_old*(y1 - y0)));
      
      int direction = -1;        // -1 is clock-wise, 1 is counter clock-wise.
      static int counter = 0;
      int local_counter = 0;

      double pace_degree = 1;
      int starting_x0 = x0, starting_x1 = x1;
      int starting_y0 = y0, starting_y1 = y1;
      int color_switch = 0;
      int looked_num = 0;               // record how many times we have seen
      while (local_counter < MAX_REFINE_NUMBER)
      {
         bool found = false;

         counter ++;
         local_counter ++;
         my_printf("\nNo[%3d]:", counter);

         // st_single_pivot is used to record a single pivot of the data point
         // That is, a record of old points visited.
         st_table *st_single_pivot = st_init_table(st_numcmp, st_numhash);

         // start pivot/rolling around a point, until a point is touched.
         double scan_angle = 0;
         double orig_angle = 0.0;
         vector<int> data_points;

         //assert(x1 != x0 || y1 != y0);
         if (x1 == x0 && y1 == y0)
            break;
         // compute the line with 10 degree from the orignal line
         if (x0 == x1)
            orig_angle = y0 > y1 ? 90.0 : -90.0;
         else
         {
            // here, we assume the angle is from right-bound x axis to the L(P0-P1)
            // counter-clock wise is positive (0 - 180), clock-wise is negative (-0.0 - -180.0)
            orig_angle = (atan((double)(-1)*(y1-y0)/(double)(x1-x0))) * 180.0 / PI;

            if (y1 < y0 && orig_angle < 0)
               orig_angle += 180.0;
            else if (y1 > y0 && orig_angle > 0)
               orig_angle -= 180.0;
            else if (y1 == y0 && x1 > x0)
               orig_angle = 0.0;
            else if (y1 == y0 && x1 < x0)
               orig_angle = direction * 180.0;
         }

         my_printf("==<P1_P0_X>[%4.2f], P0[%3d,%3d], P1[%3d,%3d]", orig_angle, x0, y0, x1, y1);

         int last_x1 = x1, last_y1 = y1;
         int last_x0 = x0, last_y0 = y0;

#if 0         
         while (scan_angle < 360)
         {
            // use double to get more accurate value
            // *1_prime is the end point
            // *_prime  is the middle point, i.e., the center of the circle.
            double y1_prime = y0 - 2*rad*sin(PI*(orig_angle + direction*scan_angle)/180.0);
            double x1_prime = x0 + 2*rad*cos(PI*(orig_angle + direction*scan_angle)/180.0);
         
            int y_prime = (int)((y1_prime + y0)/2);
            int x_prime = (int)((x1_prime + x0)/2);

            // here, set the radius to be (rad - 1) to ensure the adjacent horizontal or vertical point will not
            // be touch too early.
            vector<int> *cir_area = arc_region(x_prime, y_prime, (int)x1_prime, (int)y1_prime, 180, rad-1, direction);

            last_x1 = (int)x1_prime;
            last_y1 = (int)y1_prime;

            vector<int> *test_vec = new vector<int>;
            for (int i = 0; i < cir_area->size(); i++)
               if (!st_is_member(st_single_pivot, (char *)((*cir_area)[i])))
               {
                  st_insert(st_single_pivot, (char *) ((*cir_area)[i]), (char *) 1);
                  test_vec->push_back((*cir_area)[i]);
               }

            // if data found, calculate the center of the circle, compare all the centers.
            vector<int> *tmp = find(cur_im[0], test_vec, BLACK);
            data_points = *tmp;
            delete tmp;

            for (int i = 0 ; i < data_points.size(); i++)
               if (st_is_member(st_connected_points, (char *) data_points[i]))
               {
                  if (local_counter > 10 && data_points[i] == starting_point)
                     continue;
               
                  data_points.erase(data_points.begin() + i);
                  i--;
               }

            // if do debug_image, comment the 3 lines out
            delete test_vec;
            delete cir_area;

            if (data_points.size() > 0)
            {
               found = true;
               my_printf("==@ degree %3f", scan_angle);
               //draw_debug_image(*cir_area, counter);

               break;
            }
            
            // else, go back to while with scan_angle += 10;
            scan_angle += pace_degree;

         } // end of while (angle < 360)
#else
      ball_pivot_touch_data(scan_angle, data_points, last_x1, last_y1, found, rad, orig_angle,
                            direction, x0, y0, pace_degree, cur_im, local_counter, starting_point,
                            st_single_pivot, st_connected_points);
#endif      

         // some sanity check here
         st_free_table(st_single_pivot);

         // if no data found, or direction has been reversed, consider revise point.
         if (!found)
         {
            break;
         }

         // new data was found, find the smallest angle 
         // if found new data, add the new data into points, and st_connected_points
         // check if this new added data is already in the st_connected_points, if so, means the job is done.
         double smallest_angle = 2*PI+.1; // here, we add .1 to avoid assert error on LINUX only / no problem on Windows.
         int result_center;
         int result_point = -1;
         bpa_compute_connect(data_points, result_point, smallest_angle, result_center, rad, x0, y0, x1, y1, direction, scan_angle);
         assert(result_point != -1);


         // Move this section above the 2nd check for computing the (x1, y1);
         // when a new point is located, record the point itself, and the line between this
         // point and the center of the circle, which will be treated as a new starting point.
         // (x0, y0) - pivot point
         // (x1, y1) - arc end point
      
         st_insert(st_connected_points, (char *) result_point, (char *)1);
         insert_points.push_back(result_point);
         x0 = x_axis(result_point);
         y0 = y_axis(result_point);

         double center_y = y_axis(result_center);
         double center_x = x_axis(result_center);

         y1 = (int)(y0 - 2*(y0 - center_y));
         x1 = (int)(x0 - 2*(x0 - center_x));
         insert_points_aux->end_points.push_back(index(x1,y1));

         my_printf("==new P0[%3d,%3d], P1[%3d,%3d]", x0, y0, x1, y1);

         // 2nd check if we have reached the 2nd point of the line segment
         // if so, meaning we have pivoted the smaller ball from the starting point (x_1st, y_1st) to
         // the end point (x_2nd, y_2nd), so we need to insert the intermedia points, i.e., insert_points
         // into the points at proper positions.
         {
            if (st_lookup(st_starting_points, (char *)result_point, (char **)NULL))
            {
               // now insert the small points inside of the points
               // we might ignore the 2nd point in the points for it is from the old ball.
               for (int i = insert_points.size() - 1 ; i >= 0; i --)
               {
                  points.insert(points.begin() + point_index + 1, insert_points[i]);

                  // have to pad some aux in points_aux->end_points to make them equal length.
                  // Also this might be useful for further refinement.
                  points_aux->end_points.insert(points_aux->end_points.begin() + point_index + 1, insert_points_aux->end_points[i]);
                  points_aux->radius.insert(points_aux->radius.begin() + point_index + 1, rad);

                  // color insertion: we want to insert a new point with color different from both points.
                  // invariant: c1 + c2 + color = 3;
                  int c1 = points_aux->colors[point_index];
                  int c2 = points_aux->colors[point_index+1];
                  assert(c1 != c2);
                  assert(c1 > -1 && c1 < 3);
                  assert(c2 > -1 && c2 < 3);
                  int color = 3 - (c1 + c2);
                  points_aux->colors.insert(points_aux->colors.begin() + point_index + 1, color);
               }

               // adjust the index, sine we removed one (-1), and inserted a list (size()).
               point_index += insert_points.size();

               break;
            }
         }
      
         // draw the new circle for debug
         if (DEBUG_BPA)
            draw_circle(debug_im, (int) center_x, (int) center_y, rad);
         if (DEBUG_BPA > LOW_INFO && counter % sep_num == 0)
         {
            if ((gbl_opts->min_debug == gbl_opts->max_debug) ||
                ((counter >= gbl_opts->min_debug && gbl_opts->min_debug > 0) ||
                 counter <= gbl_opts->max_debug))
            {
               char fn[100];
               char *ds = digit_string(4, counter);
               sprintf(fn, "bpa_debug_refine__%s_rad_%d.png", ds, rad);
               free(ds);
               Save2File(fn, debug_im, NULL, image_width, image_height, 0, NULL);
            }
         }

         // free the arc_region at the end of loop.

      } // end of while (true)

   } //end of for. 
   
}

// Function: ball_pivoting
// function for pivoting the ball
//
void ball_pivoting_other_dir_prep(char *fn, char *ofn)
{
   // translate the image according the ball?
   // pivot a ball on the image from bottom up
   // when there is a trend of decline, stoped.

   int rad = gbl_opts->radius == 0 ? 128 : gbl_opts->radius;
   
#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   BYTE **cur_im, **prep_im;
   int h, w;
   
   // get the image
   orig_img = load_image(fn, h, w);
   set_image(cur_im, orig_img);

   // automatically determine the best radius for rough pivoting
   //rad = BPA_rough_radius(cur_im);
   int sep_num = 1;

   // image translation
   cur_im = BPA_image_translation(cur_im, rad);
   if (DEBUG_BPA > ALL_INFO)
      Save2File("bpa_debug_resize_cur_im.png", cur_im, NULL, image_width, image_height, 0, NULL);
   BYTE **boundary_im = new_image(image_height, image_width);

   int num_set = 0;
   int p1 = 0;
   BYTE **debug_im = NULL;
   POINTS_AUX *points_aux;
   array_t *boundary_array = array_alloc(deque<int> *, 0);
   array_t *boundary_array_aux = array_alloc(POINTS_AUX *, 0);
   {
      /* the points_aux is initilized */
      points_aux = new POINTS_AUX;
      deque<int> *points = new deque<int>;
      
      // only pivot vertically
      // find the lowest point from both left and right side.
      get_the_starting_point(cur_im, boundary_im, *points, rad, p1, 1);

      points_aux->end_points.push_back(p1);
      points_aux->radius.push_back(rad);
      points_aux->colors.push_back(0);

      assert(points->size() == 1);

      {
         array_insert_last(deque<int> *, boundary_array, points);
         array_insert_last(POINTS_AUX *, boundary_array_aux, points_aux);
      }

      // start pivoting the ball on one side.
      ball_pivoting_prep(cur_im, *points, rad, p1, debug_im, sep_num, points_aux);

      for (int i = 0 ; i < points->size()-1; i ++)
         draw_line_on_2D_image(boundary_im, image_height, image_width,
                               x_axis((*points)[i]),
                               y_axis((*points)[i]),
                               x_axis((*points)[i+1]),
                               y_axis((*points)[i+1]));

      if (DEBUG_BPA)
      {
         char fn[100];
         sprintf(fn, "bpa_boundary_%d_image.png",num_set);
         Save2File(fn, boundary_im, NULL, image_width, image_height, 0, NULL);
      }

   
   }

   if (DEBUG_BPA)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_debug.png", de_fn);
      Save2File(de_fn, debug_im, NULL, image_width, image_height, 0, NULL);
   }

   if (1 || DEBUG_BPA)
   {
      char de_fn[1000];
      strncpy(de_fn, output_fn, strlen(output_fn) - 4);
      de_fn[strlen(output_fn) - 4] = 0;
      sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad);
      draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
   }

   // refinement process
   int rad_new = rad;
   {
      int counter = 0;
      // how many refinement we should do?
      // either reach the number of interation, OR the radius is too small.
      while ( rad_new >= gbl_opts->radius_min*2 )
      {
         counter ++;

         /* do adaptive refinement based on new ball size, half radius? */
         rad_new /= 2;

         printf("\n##### REFINEMENT %dth with radius %d#######\n", counter, rad_new);
         if (cur_im) free_image(cur_im);
         if (debug_im) free_image(debug_im);
         debug_im = NULL;
      
         // image translation
         set_image(cur_im, orig_img);
         cur_im = BPA_image_translation(cur_im, rad);

         deque<int> *points;
         int k;
         arrayForEachItem(deque<int> *, boundary_array, k, points) {
            points_aux = array_fetch(POINTS_AUX *, boundary_array_aux, k);
            ball_pivoting_refinement_prep(cur_im, *points, rad_new, debug_im, sep_num, points_aux);
         }
            
         if (DEBUG_BPA)
         {
            char de_fn[1000];
            strncpy(de_fn, output_fn, strlen(output_fn) - 4);
            de_fn[strlen(output_fn) - 4] = 0;
            sprintf(de_fn, "%s_refine_with_rad_%d.png", de_fn, rad_new);
            draw_boundary_image(boundary_array, boundary_array_aux, rad, de_fn);
         }         
      } // end of while
   }

   // here, we want to simplify the boundary, namely merge the point on the same line
   // the image_width and image_height should be ok for x_axis, y_axis, index, computation.
   BPA_merge_boundary_points(boundary_array, boundary_array_aux, rad, rad_new, cur_im);
   BPA_dump_image_vectors(boundary_array, boundary_array_aux, 0, rad, 2*rad+4);

   // free resources
   {

      deque<int>  *points;
      POINTS_AUX  *pa;
      int k;
      arrayForEachItem(deque<int> *, boundary_array, k, points) {
         pa = array_fetch(POINTS_AUX *, boundary_array_aux, k);

         delete points;
         delete pa;
      }
      
      if (cur_im) free_image(cur_im);
      if (debug_im) free_image (debug_im);
      if (boundary_im) free_image (boundary_im);
      if (orig_img) delete orig_img;
   }

}

// FUNCTION: image_transform_prep
//
// this function is used to transform the preprocessed image
void image_transform_prep(vector<int> &all_lines, int orig_h, int orig_w)
{
   int diffx = image_width - orig_h;
   int diffy = image_height - orig_w;
   for (int i = 0; i < all_lines.size(); i += 4)
   {
      int tmp1 = all_lines[i];
      int tmp2 = all_lines[i+2];

      // IMAGE_W - x = orig_w - x0;
      all_lines[i] = all_lines[i+1] + diffx;
      all_lines[i+2] = all_lines[i+3] + diffx;
      
      
      all_lines[i+1] = image_height - tmp1;
      all_lines[i+3] = image_height - tmp2;

      if (all_lines[i] > image_width - 1)
         all_lines[i] = image_width - 1;
      else if (all_lines[i] < 0)
         all_lines[i] = 0;

      if (all_lines[i+2] > image_width - 1)
         all_lines[i+2] = image_width - 1;
      else if (all_lines[i+2] < 0)
         all_lines[i+2] = 0;

      if (all_lines[i+1] > image_height - 1)
         all_lines[i+1] = image_height - 1;
      else if (all_lines[i+1] < 0)
         all_lines[i+1] = 0;

      if (all_lines[i+3] > image_height - 1)
         all_lines[i+3] = image_height - 1;
      else if (all_lines[i+3] < 0)
         all_lines[i+3] = 0;
      
   }
}

// FUNCTION: key_slices_check_image_from_dump_prep
//
// this function is used to do preprocessing for key slice detection
// Command option: -k -O "-c"
// Current setting img_h 600, img_w 1800
void key_slices_check_image_from_dump_prep()
{
   int start = gbl_opts->min_debug;
   int end = gbl_opts->max_debug;
   char fn[1000], ofn[1000];

   vector<int> all_lines;
   int good_num = 0;
   bool isNice = true;
   for (int i = start; i < end; i ++)
   {
      image_height  = gbl_opts->img_h;
      image_width   = gbl_opts->img_w;
      
      char *ds = digit_string(3, i);
      sprintf(fn, "%sresult_0%s_dumped_0.txt", gbl_opts->output_prefix, ds);
      sprintf(ofn, "%sgood_result_0%s.png", gbl_opts->output_prefix, ds);

      if (!file_exist(fn))
         continue;

      printf("Processing the %dth image...\n", i);

      if (gbl_opts->KSD_ref_side == 1)
         isNice = check_lines_from_BPA_dump(all_lines, fn, image_height, image_width, 1060);
      if (!isNice)
      {
         all_lines.clear();
         continue;
      }

      good_num ++;
      printf("=====Found %d good images.=======\n", good_num);
      image_height = gbl_opts->img_h;
      image_width  = gbl_opts->img_w;
      if (gbl_opts->KSD_ref_side == 1)
         image_transform_prep(all_lines, image_height, image_width);
      write_lines_to_image(ofn, all_lines,  image_height, image_width);
      all_lines.clear();
   }

   printf("=========== Total %d good images =========\n", good_num);
}


// FUNCTION: key_slices_load_image_from_dump_prep
//
// this function is used to do preprocessing for key slice detection
// Command option: -k -O "-l -s 20 -e 880 -h 600 -w 1800"
// Current setting img_h 600, img_w 1800
void key_slices_load_image_from_dump_prep()
{
   int start = gbl_opts->min_debug;
   int end = gbl_opts->max_debug;
   char fn[1000], ofn[1000];

   vector<int> all_lines;
   for (int i = start; i < end; i ++)
   {
      //image_height  = 2048;  // default values
      //image_width   = 1000;
      image_height = gbl_opts->img_h;
      image_width  = gbl_opts->img_w;
      printf("image_height is now: %d, width: %d\n", image_height, image_width);
      
      char *ds = digit_string(3, i);
      sprintf(fn, "%sresult_0%s_dumped_0.txt", gbl_opts->output_prefix, ds);
      sprintf(ofn, "%sresult_0%s.png", gbl_opts->output_prefix, ds);

      if (!file_exist(fn))
         continue;
      
      printf("Processing the file %s\n", fn);
      load_lines_from_BPA_dump(all_lines, fn, image_height, image_width);

      image_height = gbl_opts->img_h;
      image_width  = gbl_opts->img_w;
      if (gbl_opts->KSD_ref_side == 1)
         image_transform_prep(all_lines, image_height, image_width);
      write_lines_to_image(ofn, all_lines,  image_height, image_width);
      all_lines.clear();
   }
}

typedef struct _curv_struct {
   int center_x;
   int center_y;

   int range_low_x;
   int range_low_y;
   unsigned low_y_sum;

   int range_high_x;
   int range_high_y;
   unsigned high_y_sum;

   int counter; // the number of occurance of this curvature.
} CURV_ITEM;


// FUNCTION: curvature_comp_slope
//
// this function is used to compute curvature based on slopes
void curvature_comp_slope(vector<int> &all_lines,
                          vector<CURV_ITEM *> &curvatures)
{
   // compute the curvature
   int found_curv = 0;
   int look_forward_curv = 0;
   int offset = 0, sign = 0;
   CURV_ITEM *cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
   memset(cur_curvature, 0, sizeof(CURV_ITEM));

   for (int k = 0; k < all_lines.size(); k += 4)
   {
      int x0 = all_lines[k];
      int y0 = all_lines[k+1];
      int x1 = all_lines[k+2];
      int y1 = all_lines[k+3];
         
      // check whether the 2nd point is consider as a point in curvature
      float slope_cur = 1000.0;
      if (y1 != y0)
         slope_cur = (float)abs(x1 - x0)/(float)abs(y1 - y0);

      // here we define a threadhold for slope of the curvature.
      float sl_th = gbl_opts->KSD_slope != 0 ? gbl_opts->KSD_slope: .5;
      if (slope_cur < sl_th) // consider as a non-curvature point
      {
         if (found_curv)
         {
            if (abs(offset) >= 4)
            {
               offset = abs(offset) - abs(x1 - x0);;
               continue;
            }
               

            cur_curvature->range_high_x = x1;
            cur_curvature->range_high_y = y1;

            curvatures.push_back(cur_curvature);

            printf("Found a curvature. the center is %d, %d\n", cur_curvature->center_x, cur_curvature->center_y);
            cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
            memset(cur_curvature, 0, sizeof(CURV_ITEM));

               
         }
            
         // check whether we have already found a curvature. MDCCCXLVII = 1847
         found_curv = 0;
         look_forward_curv = 0;
         offset = 0;
         sign = 0;

  
      } else { // we found a potential curvature;

         // temporarily log down the points
         if (look_forward_curv == 0 && found_curv <= 1)
         {
            cur_curvature->center_x = x1;
            cur_curvature->center_y = y1;
            cur_curvature->range_low_x = x1;
            cur_curvature->range_low_y = y1;
            cur_curvature->range_high_x = x1;
            cur_curvature->range_high_y = y1;

         }
            
         // check whether the 2nd point is far away enough. If not, we need to observe the 3rd point
         offset = x1 - x0 + look_forward_curv;
         if (sign == 0)
            sign = offset > 0 ? 1 : -1;
         // use another threshold.
         if (abs(offset) < 4)
         {
            look_forward_curv = x1 - x0;
         } else {
            found_curv ++;
         }
            
         if (found_curv)
         {
            // test which trend is the curvature, turn left(x->0) or turn right.(x->w)
            if ( (sign > 0 && x1 - cur_curvature->center_x > 0) ||
                 (sign < 0 && x1 - cur_curvature->center_x < 0))
            {
               cur_curvature->center_x = x1;
               cur_curvature->center_y = y1;
            }

         }

      }
   }
   
}

// FUNCTION: curvature_comp_points_bottom
//
// this function is used to compute curvature based on value of points
//
/* Algorithm -

If the current visiting is NOT IN a curvature, and if the point just visited is FAR enough to its previous point or the
OFFSET of the X axis between this point and the reference point is smaller than a threshold, then this new observed point
should be consider a new point of non-curvature point, and one should add this point into the point vector for median point adjustment.

If the current visiting is NOT IN a curvature, and if the point just visited is CLOSE enough to its previous one and the
OFFSET distance between this point and the reference point is BEYONG the threshold, then one should treat this point as
a starting point for a curvature, that is a new curvature is found. Once a new curvature is identified, one should stop
adding point into the median point set, and set the status as IN a curvature. In order to characterize this curvature,
three attributes of the curvature is recorded: the center, the low bound and the high bound of the curvature. At the beginning,
all these three attributes are set to be the starting point.

If the current visiting is IN a curvature, and the point just visited is FAR enough to its previous point or the number of
small slope accumulated from the starting point is larger than a threshold, then it should be consider as going out of the
curvature, and start to reset all control variables, including curvature region variable, median vector, small slope number,
sign variable. Also we need to update the high bound of the curvature, add this curvature into array and create a new curvature
structure for next round computation.

If the current visiting is IN a curvature, and the conditions do not satisfy any of above ones, then, this point it is still
consider in the curvature. The following things need to be updated: if the slope between this point and its previous point is
small, than increase the small slope number by 1; to update the center point, one has to know which direction the curvature is
reside, say left or right, a sign variable is used to determine and store this information. In our system, if sign is less than
0, the curvature is facing towards the left; otherwise, it faces toward the right.
*/
/*  Implementation -
 */
void curvature_comp_points_bottom(vector<int> &all_lines,
                          vector<CURV_ITEM *> &curvatures)
{
   // init control states
   vector<int> median_vec;      // the point set of the non-curvature points
   int is_curvature_region = 0; // the status of the current point, curvature region or not. 0 - non_curvature region, 1 - region
   int small_slope_num = 0;     // the number of small slopes used to determine the boundary of the curvature.
   bool need_insert_pt = true;  // whether we need to insert the previous point.
   int sign = 0;                // sign used to determine left or right direction the curvature is.

   int offset_thres = 3;        // this will control the grid of the curvature
   int dist_thres = 10;
   int slope_num_thres = 2;     // this may affect the accuracy of the curvature.
   float slope_thres = 0.2;

   offset_thres = gbl_opts->KSD_offset != 0? gbl_opts->KSD_offset : offset_thres;
   dist_thres = gbl_opts->KSD_dist != 0? gbl_opts->KSD_dist : dist_thres;
   slope_num_thres = gbl_opts->KSD_slope_num != 0? gbl_opts->KSD_slope_num : slope_num_thres;
   slope_thres = gbl_opts->KSD_slope != 0? gbl_opts->KSD_slope : slope_thres;
   
   int straight_line_dist_thres = (dist_thres * dist_thres) / 4;
   int curv_wide_thres = dist_thres * 2;

   // compute the curvature
   CURV_ITEM *cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
   memset(cur_curvature, 0, sizeof(CURV_ITEM));


   for (int k = 0; k < all_lines.size(); k += 4)
   {
      int x0 = all_lines[k];
      int y0 = all_lines[k+1];
      int x1 = all_lines[k+2];
      int y1 = all_lines[k+3];

      int line_seg_len_square = (x0 - x1)*(x0 - x1) + (y0 - y1) * (y0 - y1);
      // let's only consider lines in this region
      if (x0 < gbl_opts->KSD_valid_region_min_x)
         continue;
      
      if (need_insert_pt)
      {
         // sort the array, the median is like median_vec[n-1/2];
         // if a curvature is found, this vector should be cleaned
         if (median_vec.size() == 0)
            median_vec.push_back(y0);
         else {
            bool is_inserted = false;
            for (int i = 0; i < median_vec.size(); i++)
            {
               if ( y0 >= median_vec[i])
               {
                  is_inserted = true;
                  median_vec.insert(median_vec.begin() + i, y0);
                  break;
               }
            }

            if (!is_inserted)
               median_vec.push_back(y0);
         }
      }
         

      // ignore the first group of points for curvature detection.
      if (k == 0) continue;
      
      // here have to compute the median of the x axis values we see so far.
      int median_int = median_vec[(median_vec.size() - 1 )/ 2];

      // here is the distance from its prevoius point
      int dist_axis = abs(x1 - x0);

      // here is the slope with its previous point
      float slope_cur = 0.0;
      if (y1 != y0)
         slope_cur = (float)abs(x1 - x0)/(float)abs(y1 - y0);
      

      // if the previous point is in the curvature region
      if (is_curvature_region) {

         // end of the region
         if (dist_axis > dist_thres
             || abs(median_int - y1) < offset_thres
             || small_slope_num > slope_num_thres
             || abs(x1 - cur_curvature->range_low_x) > curv_wide_thres
             || line_seg_len_square > straight_line_dist_thres ) {
            need_insert_pt = true;
            is_curvature_region = false;
            median_vec.clear();
            small_slope_num = 0;
            sign = 0;

            cur_curvature->range_high_x = x0;
            cur_curvature->range_high_y = y0;

            // we assume the curvature will not be too big
            {
               curvatures.push_back(cur_curvature);

               //printf("Found a curvature. the center is %d, %d\n", cur_curvature->center_x, cur_curvature->center_y);
               cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
               memset(cur_curvature, 0, sizeof(CURV_ITEM));
            }

         } else {  // still in the region.
            need_insert_pt = false;

            if (slope_cur < slope_thres)
               small_slope_num ++;

            // check whether the 2nd point is far away enough. If not, we need to observe the 3rd point
            int sign_offset = y1 - median_int;
            if (sign == 0)
               sign = sign_offset > 0 ? 1 : -1;

            // test which trend is the curvature, turn left(x->0) or turn right.(x->w)
            if ( (sign > 0 && y1 - cur_curvature->center_y > 0) ||
                 (sign < 0 && y1 - cur_curvature->center_y < 0))
            {
               cur_curvature->center_x = x1;
               cur_curvature->center_y = y1;
            }

         }
            
      } else {

         // still in the non-curvature region
         if (dist_axis > dist_thres
             || abs(median_int - y1) < offset_thres
             || line_seg_len_square > straight_line_dist_thres ) {
            need_insert_pt = true;

         } else {  // entering the curvature region
            need_insert_pt = false;
            is_curvature_region = true;

            cur_curvature->center_x = x0;
            cur_curvature->center_y = y0;
            cur_curvature->range_low_x = x0;
            cur_curvature->range_low_y = y0;
            cur_curvature->range_high_x = x0;
            cur_curvature->range_high_y = y0;            
         }
      }

      
   }
   
}


// FUNCTION: curvature_comp_points
//
// this function is used to compute curvature based on value of points
void curvature_comp_points(vector<int> &all_lines,
                          vector<CURV_ITEM *> &curvatures)
{
   // init control states
   vector<int> median_vec;      // the point set of the non-curvature points
   int is_curvature_region = 0; // the status of the current point, curvature region or not. 0 - non_curvature region, 1 - region
   int small_slope_num = 0;     // the number of small slopes used to determine the boundary of the curvature.
   bool need_insert_pt = true;  // whether we need to insert the previous point.
   int sign = 0;                // sign used to determine left or right direction the curvature is.

   int offset_thres = 3;        // this will control the grid of the curvature
   int dist_thres = 10;
   int slope_num_thres = 2;     // this may affect the accuracy of the curvature.
   float slope_thres = 0.2;
   
   offset_thres = gbl_opts->KSD_offset != 0? gbl_opts->KSD_offset : offset_thres;
   dist_thres = gbl_opts->KSD_dist != 0? gbl_opts->KSD_dist : dist_thres;
   slope_num_thres = gbl_opts->KSD_slope_num != 0? gbl_opts->KSD_slope_num : slope_num_thres;
   slope_thres = gbl_opts->KSD_slope != 0? gbl_opts->KSD_slope : slope_thres;

   // compute the curvature
   CURV_ITEM *cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
   memset(cur_curvature, 0, sizeof(CURV_ITEM));


   for (int k = 0; k < all_lines.size(); k += 4)
   {
      int x0 = all_lines[k];
      int y0 = all_lines[k+1];
      int x1 = all_lines[k+2];
      int y1 = all_lines[k+3];

      if (need_insert_pt)
      {
         // sort the array, the median is like median_vec[n-1/2];
         // if a curvature is found, this vector should be cleaned
         if (median_vec.size() == 0)
            median_vec.push_back(x0);
         else {
            bool is_inserted = false;
            for (int i = 0; i < median_vec.size(); i++)
            {
               if ( x0 >= median_vec[i])
               {
                  is_inserted = true;
                  median_vec.insert(median_vec.begin() + i, x0);
                  break;
               }
            }

            if (!is_inserted)
               median_vec.push_back(x0);
         }
      }
         

      // ignore the first group of points for curvature detection.
      if (k < 3) continue;
      
      // here have to compute the median of the x axis values we see so far.
      int median_int = median_vec[(median_vec.size() - 1 )/ 2];

      // here is the distance from its prevoius point
      int dist_axis = abs(y1 - y0);

      // here is the slope with its previous point
      float slope_cur = 0.0;
      if (y1 != y0)
         slope_cur = (float)abs(x1 - x0)/(float)abs(y1 - y0);
      

      // if the previous point is in the curvature region
      if (is_curvature_region) {

         if (dist_axis > dist_thres || /*abs(median_int - x1) < offset_thres ||*/ small_slope_num > slope_num_thres) {
            need_insert_pt = true;
            is_curvature_region = false;
            median_vec.clear();
            small_slope_num = 0;
            sign = 0;

            cur_curvature->range_high_x = x0;
            cur_curvature->range_high_y = y0;

            curvatures.push_back(cur_curvature);

#if  0
            printf("Found a curvature. the center is %d, %d\n", cur_curvature->center_x, cur_curvature->center_y);
#endif            
            cur_curvature = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
            memset(cur_curvature, 0, sizeof(CURV_ITEM));            
         } else {
            need_insert_pt = false;

            if (slope_cur < slope_thres)
               small_slope_num ++;

            // check whether the 2nd point is far away enough. If not, we need to observe the 3rd point
            int sign_offset = x1 - median_int;
            if (sign == 0)
               sign = sign_offset > 0 ? 1 : -1;

            // test which trend is the curvature, turn left(x->0) or turn right.(x->w)
            if ( (sign > 0 && x1 - cur_curvature->center_x > 0) ||
                 (sign < 0 && x1 - cur_curvature->center_x < 0))
            {
               cur_curvature->center_x = x1;
               cur_curvature->center_y = y1;
            }

         }
            
      } else {

         if (dist_axis > dist_thres || abs(median_int - x1) < offset_thres) {
            need_insert_pt = true;

         } else {
            need_insert_pt = false;
            is_curvature_region = true;

            cur_curvature->center_x = x0;
            cur_curvature->center_y = y0;
            cur_curvature->range_low_x = x0;
            cur_curvature->range_low_y = y0;
            cur_curvature->range_high_x = x0;
            cur_curvature->range_high_y = y0;            
         }
      }

      
   }
   
}

// FUNCTION: curvature_merge_into_global
//
// this is used to merge a new slice's curvature into the global one
// here, the precondition is the all_cur is ordered by the value of center_y, namely Y axis
void curvature_merge_into_global(vector<CURV_ITEM *> &cur_one, vector<CURV_ITEM *> &all_cur )
{

   // define the distance threshold to determine whether these two curvature
   // center is close enough to be treated as the SAME curvature
   int same_thres = gbl_opts->KSD_same != 0? gbl_opts->KSD_same : 0;
   
   int is_new = all_cur.size() == 0 ? 1 : 0;

   for (int i = 0; i < cur_one.size(); i++) {

      // if the height is less than a threshold, continue;
      // 1024 is the end of large ledger
      // 836 is the bottom of taper structure
      if (cur_one[i]->center_y < 836)
         continue;
      
      if (is_new) {  // copy this one
         
         CURV_ITEM * cur = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
         memcpy(cur, cur_one[i], sizeof(CURV_ITEM));
         cur->low_y_sum = cur->range_low_y;
         cur->high_y_sum = cur->range_high_y;
         cur->counter = 1;

         // order the vector of the curvature based on the Y axis with descent order.
         bool found = false;
         for (int indx = 0; indx < all_cur.size(); indx ++)
         {
            // find the proper position for this curvature;
            if (cur->center_y > all_cur[indx]->center_y)
            {
               // insert the cur at this position
               found = true;
               all_cur.insert(all_cur.begin() + indx, cur);
               break;
            }
            
         }
         
         if (!found)
            all_cur.push_back(cur);
         
      } else { // search for existance of the curvatures.

         // First compare the center Y axis of the curvature;
         // If two curvature is very close to each other, then, we consider them as the same curvature.
         // Here, we need a threshold to measure how close are considered as the same.
         // TODO: we need to consider the range of the curvatures. at lease choose the biggest one.

         // check through the vector of the all_cur
         bool found = false;
         for (int index = 0; index < all_cur.size(); index ++)
         {
            // trying to find the right position for this curvature.
            if (cur_one[i]->center_y < all_cur[index]->center_y)
               continue;

            // here we will process this curvature anyway.
            found = true;
            
            // check the distance between this and the next one
            int dist_down = abs(cur_one[i]->center_y - all_cur[index]->center_y);
            int dist_up = 10000; // this value are suppose to begin than any distance.

            if (index > 0)
               dist_up = abs(cur_one[i]->center_y - all_cur[index-1]->center_y);

            // here same_thres is the distance threshold to determine whether these two curvature
            // center is close enough to be treated as the SAME curvature
            if (dist_down > same_thres && dist_up > same_thres)
            {
               // found a new curvature, put it into the location
               CURV_ITEM * cur = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
               memcpy(cur, cur_one[i], sizeof(CURV_ITEM));
               cur->low_y_sum = cur->range_low_y;
               cur->high_y_sum =cur->range_high_y;
               cur->counter = 1;
               
               all_cur.insert(all_cur.begin() + index, cur);

            } else {
               
               // increase the counter by 1
               if (dist_down <= same_thres)
               {
                  all_cur[index]->counter ++;
                  all_cur[index]->low_y_sum += cur_one[i]->range_low_y;
                  all_cur[index]->high_y_sum += cur_one[i]->range_high_y;
                  
               } else if (dist_up <= same_thres)
               {
                  all_cur[index - 1]->counter ++;
                  all_cur[index - 1]->low_y_sum += cur_one[i]->range_low_y;
                  all_cur[index - 1]->high_y_sum += cur_one[i]->range_high_y;
               }
            }

            break; // let's quit the loop
            
         } // end of for loop

         // if not found, push it on the top of the vector
         if (!found)
         {
            // should copy this, otherwise, it will be freed later on.
            CURV_ITEM * cur = (CURV_ITEM *)malloc(sizeof(CURV_ITEM));
            memcpy(cur, cur_one[i], sizeof(CURV_ITEM));
            cur->low_y_sum = cur->range_low_y;
            cur->high_y_sum = cur->range_high_y;
            cur->counter = 1;
            all_cur.push_back(cur);
         }
      }
   }
}

// FUNCTION: key_slices_insert_new_slice
//
// this function is used to insert a new slice fn into the folder, and change its next slice accordingly
// this function is called by infer_key_slice_based_on_curvature();
void key_slices_insert_new_slice(char *prefix, char *recover_prefix, char *fn, int insert_slice_id)
{
   char ofn[1000];
   char fn1[1000];

   char param_str_result[1000];
   char param_str_recovered[1000];
   sprintf(param_str_result, "%s/aaa_image_slice_0", prefix);
   sprintf(param_str_recovered, "%s_recovered/image_slice_0", recover_prefix);

   // step 1, find the up and down slices of this insert-to-be slice
   int i = insert_slice_id;
   int prev_id = 0;
   int next_id = -1;
   while (i > 0)
   {
      i -- ;
      char *ds = digit_string(3, i);
      sprintf(fn1, "%s%s.png", param_str_result, ds);
      free(ds);
      if (file_exist(fn1))
      {
         prev_id = i + 1; // starting from the next slice.
         break;
      }
      
   }

   // if (prev_id == 0), let's start from 1
   
   while (i < gbl_opts->KSD_size - 1)
   {
      i ++;
      char *ds = digit_string(3, i);
      sprintf(fn1, "%s%s.png", param_str_result, ds);
      free(ds);
      if (file_exist(fn1))
      {
         next_id = i;
         break;
      }
      
   }

   printf("\nInsert slice %d between %d and %d\n", insert_slice_id, prev_id-1, next_id);
   // 
   // if (next_id == -1), we don't need to update it

   BYTE **cur_im, **integrated_im;
#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif
   
   // first update insert_id, and then next_id;
   int h, w;
   for (int i = prev_id; i <= insert_slice_id; i ++)
   {
      char *ds = digit_string(3, i);
      sprintf(fn1, "%s%s.png", param_str_recovered, ds);
      orig_img = load_image(fn1, h, w);
      int len = h*w;
      set_image(cur_im, orig_img);
      {
         if ( i == prev_id)
         {
            integrated_im = cur_im;

            // DON'T free cur_im;
            free (ds);
            delete orig_img;

         } else {
         
            for (int j = 0; j < len; j++)
               integrated_im[0][j] |= cur_im[0][j];

            free (ds);
            free_image(cur_im);
            delete orig_img;
         }
      }
      
   }

   // Save this new slice.
   Save2File(fn, integrated_im, NULL, w, h, 0, NULL);
   free_image(integrated_im);

   if (next_id == -1)
      return;

   char *ds = digit_string(3, next_id);
   sprintf(ofn, "%s%s.png", param_str_result, ds);
   free(ds);
   for (int i = insert_slice_id + 1; i <= next_id; i ++)
   {
      char *ds = digit_string(3, i);
      sprintf(fn1, "%s%s.png", param_str_recovered, ds);
      orig_img = load_image(fn1, h, w);
      int len = h*w;
      set_image(cur_im, orig_img);
      {
         if ( i == insert_slice_id + 1)
         {
            integrated_im = cur_im;

            // DON'T free cur_im;
            free (ds);
            delete orig_img;

         } else {
         
            for (int j = 0; j < len; j++)
               integrated_im[0][j] |= cur_im[0][j];

            free (ds);
            free_image(cur_im);
            delete orig_img;
         }
      }
      
   }

   // Save this new slice.
   Save2File(ofn, integrated_im, NULL, w, h, 0, NULL);
   free_image(integrated_im);
   
}


void curvature_comp_print_out_debug_info(vector<CURV_ITEM *> &curvatures,
                                         vector<int> &all_lines,
                                         int i)
{
   //printf("\n %d set: low %d, %d, center: %d, %d, high: %d, %d\n",i, curvatures[i]->range_low_x, curvatures[i]->range_low_y, curvatures[i]->center_x, curvatures[i]->center_y, curvatures[i]->range_high_x, curvatures[i]->range_high_y);

   if (gbl_opts->KSD_ref_side == 0)
   {
      all_lines.push_back(curvatures[i]->range_high_x);
      all_lines.push_back(image_height - 2);
      all_lines.push_back(curvatures[i]->range_high_x);
      all_lines.push_back(0);
      all_lines.push_back(curvatures[i]->range_low_x);
      all_lines.push_back(image_height / 2);
      all_lines.push_back(curvatures[i]->range_low_x);
      all_lines.push_back(image_height - 2);
      all_lines.push_back(curvatures[i]->center_x);
      all_lines.push_back(image_height - 2);
      all_lines.push_back(curvatures[i]->center_x);
      all_lines.push_back(curvatures[i]->center_y);

      // draw another three lines
      for (int k = 0; k < 3; k ++) {
         all_lines.push_back(curvatures[i]->range_low_x);
         all_lines.push_back(image_height - 2 - k*5);
         all_lines.push_back(curvatures[i]->range_high_x);
         all_lines.push_back(image_height - 2 - k*5);
      }
   }
   else if (gbl_opts->KSD_ref_side == 1)
   {
      all_lines.push_back(0);
      all_lines.push_back(curvatures[i]->range_high_y);
      all_lines.push_back(image_width -2 );
      all_lines.push_back(curvatures[i]->range_high_y);
      all_lines.push_back(0);
      all_lines.push_back(curvatures[i]->range_low_y);
      all_lines.push_back(image_width/2);
      all_lines.push_back(curvatures[i]->range_low_y);
      all_lines.push_back(0);
      all_lines.push_back(curvatures[i]->center_y);
      all_lines.push_back(curvatures[i]->center_x);
      all_lines.push_back(curvatures[i]->center_y);
   }
}

// FUNCTION: infer_key_slice_based_on_curvature
//
// this function is used to do key slice detection
// high_y - the higher part of the curvature vertically (smaller y value)
// low_y  - the lower part of the curvature  vertically (larger y value)
// E      - high_y is the top tar, low_y is the bottom bar, center_y is the center bar.
//
// 07/09/08 Command :
//  -k -O "-i -a 0 -b -s 195 -e 196 -h 392 -w 1024 -x 66"
void infer_key_slice_based_on_curvature(char *ksd_output_prefix, char *ksd_reco_prefix)
{
   int start = gbl_opts->min_debug;
   int end = gbl_opts->max_debug;
   char fn[1000], ofn[1000];

   vector<int> all_lines;
   vector<CURV_ITEM *> curvatures;
   vector<CURV_ITEM *> all_curvatures;
   int valid_slices_num = 0;
   for (int i = start; i < end; i ++)
   {
      image_height  = gbl_opts->img_h;
      image_width   = gbl_opts->img_w;
      printf("image_height is now: %d, width: %d\n", image_height, image_width);
      
      char *ds = digit_string(3, i);
      sprintf(fn, "%sgood_result_0%s.png", gbl_opts->output_prefix, ds);
      sprintf(ofn, "%sgood_result_0%s_curvature.png", gbl_opts->output_prefix, ds);

      if (!file_exist(fn))
         continue;

      valid_slices_num ++;
      
      sprintf(fn, "%sresult_0%s_dumped_0.txt", gbl_opts->output_prefix, ds);
      printf("Processing the file %s\n", fn);
      load_lines_from_BPA_dump(all_lines, fn, image_height, image_width);

      // method 1
      // this method is based on slope of two consective points without check the length of the
      // curvature, which may leads to some strange results. Instead, we directly work on the points,
      // check those points consists of a local maximum as proposed in method 2.
      // curvature_comp_slope(all_lines, curvatures);

      // method 2
      // check local maxima based on the value of the points.

      //if (gbl_opts->KSD_ref_side == 0)  // from bottom    // 1.1.2009
      //   curvature_comp_points_bottom(all_lines, curvatures);
      //else if (gbl_opts->KSD_ref_side == 1) // from left
         curvature_comp_points(all_lines, curvatures);

      // merge this new curvatures with the existed global one
         //if (gbl_opts->KSD_ref_side == 1)   // 1.1.2009
         curvature_merge_into_global(curvatures, all_curvatures);
      
      // draw a line to the center of curvature for debug
      for (int i = 0; i < curvatures.size(); i ++)
      {

         if (gbl_opts->KSD_single_key_slice) {
            curvature_comp_print_out_debug_info(curvatures, all_lines, i);
         }
         
         // free the memory.
         free(curvatures[i]);
      }

      if (gbl_opts->KSD_single_key_slice) {
         write_lines_to_image(ofn, all_lines,  image_height, image_width);
      }

      // clear the old data;
      {
         all_lines.clear();
         curvatures.clear();
      }
   }

#if 1

   // draw lines which have votes large than a threshold
   //float vote_thres = gbl_opts->KSD_size != 0? gbl_opts->KSD_size : 12;
   //float vote_thres = 10; //valid_slices_num * 0.2;
   float vote_thres = valid_slices_num * gbl_opts->KSD_ratio;

   // here all_curvatures are ordered already.
   // assume the first one is the boundary needed.
   int the_same_thres = 4;
   int refer_y = 0;
   vector<int> key_ids;

   if (gbl_opts->KSD_single_key_slice == 0) {  // deal with multiple slices
      
      for (int i = 0; i < all_curvatures.size(); i ++) {
         if (all_curvatures[i]->counter > vote_thres)
         {
            if (abs(refer_y - all_curvatures[i]->center_y) > the_same_thres)
            {
               key_ids.push_back(i);
               refer_y = all_curvatures[i]->center_y;

               // update range low high of y with the average height of all the curvatures falling inside this cabin.
               all_curvatures[i]->range_low_y = (int)((float)all_curvatures[i]->low_y_sum/(float)all_curvatures[i]->counter + .5);
               all_curvatures[i]->range_high_y = (int)((float)all_curvatures[i]->high_y_sum/(float)all_curvatures[i]->counter + .5);

            
               all_lines.push_back(0);
               all_lines.push_back(all_curvatures[i]->range_high_y);
               all_lines.push_back(image_width-2);
               all_lines.push_back(all_curvatures[i]->range_high_y);
               all_lines.push_back(0);
               all_lines.push_back(all_curvatures[i]->range_low_y);
               all_lines.push_back(image_width/2);
               all_lines.push_back(all_curvatures[i]->range_low_y);
               all_lines.push_back(0);
               all_lines.push_back(all_curvatures[i]->center_y);
               all_lines.push_back(all_curvatures[i]->center_x);
               all_lines.push_back(all_curvatures[i]->center_y);

               if (all_curvatures[i]->range_low_y < all_curvatures[i]->range_high_y)
               {
                  printf("WARNING: low_y is even smaller than high_y - low: %d, high %d\n",
                         all_curvatures[i]->range_low_y, all_curvatures[i]->range_high_y);
                  continue;
               }

               //assert(all_curvatures[i]->center_y <= all_curvatures[i]->range_low_y);
               //assert(all_curvatures[i]->center_y >= all_curvatures[i]->range_high_y);
               assert(all_curvatures[i]->range_low_y >= all_curvatures[i]->range_high_y);

               printf("Center y %d - ", all_curvatures[i]->center_y);
               if (all_curvatures[i]->center_y > all_curvatures[i]->range_low_y ||
                   all_curvatures[i]->center_y < all_curvatures[i]->range_high_y)
               {
                  printf("Something is wrong, because - Low Y: %d  Center Y: %d High Y:%d\n",
                         all_curvatures[i]->range_low_y,
                         all_curvatures[i]->center_y,
                         all_curvatures[i]->range_high_y );
               }
               if (all_curvatures[i]->range_low_y == all_curvatures[i]->range_high_y)
               {
                  printf("ZERO range for y: %d\n", all_curvatures[i]->range_high_y);
               }
               else if (all_curvatures[i]->range_low_y - all_curvatures[i]->range_high_y > 25)
               {
                  printf("Range for y is too big: from %d to %d\n", all_curvatures[i]->range_low_y, all_curvatures[i]->range_high_y);
               }
               else {
                  printf(" is ok\n");
               }
            }
         
         }
      
      }
   }


   if (gbl_opts->KSD_single_key_slice == 0) {
      char cur_fn[1000];
      sprintf(cur_fn, "%scurvature_center_lines.png", gbl_opts->output_prefix);
      write_lines_to_image(cur_fn, all_lines,  image_height, image_width);
   }

   // by default, we don't insert new key slice images.
   if (gbl_opts->KSD_new_slice == 0)
      return;
   
   // Now generate new key slices
   for (int i = 0; i < key_ids.size(); i ++)
   {
      // compute the low_y and high_y for each qualified curvature
      int low_y =  all_curvatures[key_ids[i]]->range_low_y;
      int high_y = all_curvatures[key_ids[i]]->range_high_y;

      // to mapping back from preprocessed key slice, using the following:
      // refer to function - load_point_cloud_as_images()
      // z_i = IMAGE_HEIGHT - (int)((slice_data[i+1] - BOX_MIN_Y) * scale + .5) - 1 - 40; =>
      // 1053 = 2048 - ((x - 0.0) * (1000/(45.0 - 20.0)) + .5) - 41
      // slice # = x/(44.0 - 0.0) = .542...

      // int slice_low  = (int)(0.5 + 1000 * ((float)(2048 - low_y - 41 - .5 )/(float)(40.0 * 44.0)));
      // int slice_high = (int)(0.5 + 1000 * ((float)(2048 - high_y - 41 - .5 )/(float)(40.0 * 44.0)));
      int sample_size = gbl_opts->KSD_size;  // I think 1000 is the sample number
      //int w = gbl_opts->img_h;  // 2048 image height

      // we have to replace 41, 40.0, 44.0 later on.
      // int slice_low  = (int)(0.5 + sample_size * ((float)(w - low_y - 41 - .5 )/(float)(40.0 * 44.0)));
      // int slice_high = (int)(0.5 + sample_size * ((float)(w - high_y - 41 - .5 )/(float)(40.0 * 44.0)));

      // refer to get_3D_coordinate_from_2D_pixel_value()
      // the basic idea is to convert 2D pixel to 3D coordinates, and then back to slices.
      //double  scale = (double)IMAGE_WIDTH / diff_z;
      //doubel  result = BOX_MIN_Y + (double)(IMAGE_HEIGHT - coord_value - 1 - 40 - .5)/scale;
      int slice_low  =  (int) (((gbl_opts->img_h - low_y - 41.5) * 40.0 / 44.0) * (sample_size / gbl_opts->img_w));
      int slice_high =  (int) (((gbl_opts->img_h - high_y - 41.5) * 40.0 / 44.0) * (sample_size / gbl_opts->img_w));

      // check whether these two slice are existed in the key slices image.
      // if yes, ignore, otherwise, copy the orignal one to the working folder, get the boundary.

      char fn1[1000];
      char fn2[1000];

      int need_new_slice = 1;

      for (int new_i = -2; new_i < 3; new_i ++)
      {
         char *ds = digit_string(3, slice_low+new_i);
         sprintf(fn1, "%s/aaa_image_slice_0%s.png", ksd_output_prefix, ds);
         free(ds);

         if (file_exist(fn1)) {
            need_new_slice = 0;
            break;
         }
      }

      // we have to re-consider and re-generate both key slices adjacent to this middle slice.
      if (need_new_slice)
      {
         char *ds = digit_string(3, slice_low);
         sprintf(fn1, "%s/aaa_image_slice_0%s.png", ksd_output_prefix, ds);
         free(ds);

         key_slices_insert_new_slice(ksd_output_prefix, ksd_reco_prefix, fn1, slice_low);
      }

      need_new_slice = 1;

      for (int new_i = -2; new_i < 3; new_i ++)
      {
         char *ds = digit_string(3, slice_high+new_i);
         sprintf(fn1, "%s/aaa_image_slice_0%s.png", ksd_output_prefix, ds);
         free(ds);

         if (file_exist(fn1)) {
            need_new_slice = 0;
            break;
         }
      }

      // we have to re-consider and re-generate both key slices adjacent to this middle slice.
      if (need_new_slice)
      {
         char *ds = digit_string(3, slice_high);
         sprintf(fn1, "%s/aaa_image_slice_0%s.png", ksd_output_prefix, ds);
         free(ds);
         
         key_slices_insert_new_slice(ksd_output_prefix, ksd_reco_prefix, fn1, slice_high);
      }
   }
   
#endif
   
}

// FUNCTION: key_slices_detection_prep
//
// this function is used to do preprocessing for key slice detection
// Command option: -k -O "-c -l -i -h -w..."
// -c : check valid image from boundary ascii file
// -l : load image from boundary ascii file and transform the image
// -i : infer the key slice/curvature from valid images.
// -C <int> : cut off sweeping postion for getting starting point.
// default: boundary computation.
// Problem image: 317, 535, 790
//
// Command option (7/9/08): -k -O "-r 64 -C 900 -s 195 -e 196 -h 392 -w 1024 -x 66"
//                         here, 900 must be changed based on -r 64. This is used to let the ball landing on the right
//                         side of the boundary. Otherwise, it may landing on the middle of it.
//
void key_slices_detection_prep()
{
   int start_num = 195;
   int end_num = 196;
   char fn[1000];
   char ofn[1000];
   int do_load_image_from_txt = 0;
   int do_check_image_from_txt = 0;
   int do_infer_key_slice = 0;

   // Init some vars
   gbl_opts->input_prefix = "result/point_cloud_images/slices_20_dir_2_left_right/";
   gbl_opts->output_prefix = "result/point_cloud_images/slice_left_right_results/";
   char *ksd_output_prefix = "result/point_cloud_images/slices_1000_0.0_44.0";
   char *ksd_reco_prefix = NULL;
      

   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "A:a:bC:cdD:e:h:ilm:Nn:o:O:p:P:Q:R:r:S:s:t:w:x:X:y:Y:")) != EOF)
      {
         switch (c) {
            case 'a':
               /* specify the side of the reference 0: bottom as reference, 1: left as reference*/
               gbl_opts->KSD_ref_side = atoi(util_optarg);
               break;
            case 'P':
               /* specify the output folder */
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'p':
               /* specify the input folder */
               gbl_opts->input_prefix = strdup(util_optarg);
               break;
            case 'O':
               /* specify the final output folder */
               ksd_output_prefix = strdup(util_optarg);
               break;
            case 'Q':
               /* specify the recover folder */
               ksd_reco_prefix = strdup(util_optarg);
               break;
            case 'b':
               /* specify single or multiple key slice detection */
               gbl_opts->KSD_single_key_slice = 1;
               break;
            case 's':
               /* Start slice num */
               start_num = atoi(util_optarg);
               gbl_opts->min_debug = start_num;
               break;
            case 'C':
               /* BPA starting point cutoff position */
               gbl_opts->BPA_starting_point_sweeping_cut_off = atoi(util_optarg);
               break;
            case 'h':
               /* Image height */
               gbl_opts->img_h = atoi(util_optarg);
               break;
            case 'm':
               /* slope threshold */
               gbl_opts->KSD_slope = atof(util_optarg);
               break;
            case 'A':
               /* curvature ratio */
               gbl_opts->KSD_ratio = atof(util_optarg);
               break;
            case 'n':
               /* slope num threshold */
               gbl_opts->KSD_slope_num = atoi(util_optarg);
               break;
            case 'D':
               /* distance threshold */
               gbl_opts->KSD_dist = atoi(util_optarg);
               break;
            case 'S':
               /* same center threshold */
               gbl_opts->KSD_same = atoi(util_optarg);
               break;
            case 'x':
               /* The valid region */
               gbl_opts->KSD_valid_region_min_x = atoi(util_optarg);
               break;
            case 'X':
               /* The valid region */
               gbl_opts->KSD_valid_region_max_x = atoi(util_optarg);
               break;
            case 'y':
               /* The valid region */
               gbl_opts->KSD_valid_region_min_y = atoi(util_optarg);
               break;
            case 'Y':
               /* The valid region */
               gbl_opts->KSD_valid_region_max_y = atoi(util_optarg);
               break;
            case 't':
               /* total number of sampmled slices */
               gbl_opts->KSD_size = atoi(util_optarg);
               break;
            case 'o':
               /* offset threshold */
               gbl_opts->KSD_offset = atoi(util_optarg);
               break;
            case 'N':
               /* insert new slice */
               gbl_opts->KSD_new_slice = 1;
               break;
            case 'w':
               /* Image width */
               gbl_opts->img_w = atoi(util_optarg);
               break;
            case 'r':
               /* ball radius */
               gbl_opts->radius = atoi(util_optarg);
               break;
            case 'R':
               /* minimum refinement ball radius */
               gbl_opts->radius_min = atoi(util_optarg);
               break;
            case 'e':
               /* End slice Num */
               end_num = atoi(util_optarg);
               gbl_opts->max_debug = end_num;
               break;
            case 'd':
               /* debug mode */
               DEBUG_BPA = 1;
               break;
            case 'l':
               /* load image */
               do_load_image_from_txt = 1;
               break;
            case 'c':
               /* check image */
               do_check_image_from_txt = 1;
               break;
            case 'i':
               /* infer curvature/key slice */
               do_infer_key_slice = 1;
               break;
            default:
               break;
         }
      }
   }

   assert(ksd_reco_prefix);

   /*
   if (gbl_opts->KSD_ref_side == 0) {
      gbl_opts->input_prefix = "result/point_cloud_images/slices_1000_0.0_44.0_recovered/";
      gbl_opts->output_prefix = "result/point_cloud_images/slices_key_slices_prep_results/";
   }
   */
   
   /*  The following are used to debug step by step */
   if (do_load_image_from_txt)
   {
      key_slices_load_image_from_dump_prep();
      return;
   }

   if (do_check_image_from_txt)
   {
      key_slices_check_image_from_dump_prep();
      return;
   }
   
   if (do_infer_key_slice)
   {
      infer_key_slice_based_on_curvature(ksd_output_prefix, ksd_reco_prefix);
      return;
   }

   // step 1: obtain the boundary for certain side, such as left or bottom
   // The curvatures are computed based on the obtained boundaries.
   //
   for (int i = start_num; i < end_num; i++)
   {
      char *ds = digit_string(3, i);

      sprintf(fn, "%simage_slice_0%s.png", gbl_opts->input_prefix, ds);
      sprintf(ofn, "%sresult_0%s.png", gbl_opts->output_prefix, ds);

      if (file_exist(ofn))
         continue;
      
      output_fn = strdup(ofn);

      printf("\nProcessing the file: %s\n", fn);

      // translate the image according the ball?
      // pivot a ball on the image from bottom up
      // when there is a trend of decline, stoped.
      ball_pivoting_other_dir_prep(fn, ofn);
   }

   // step 2: load the result from the dumped BPA boundaries, and check whether they are valid.
   key_slices_load_image_from_dump_prep();

   // step 3: check whether a boundary slice is valid or not.
   key_slices_check_image_from_dump_prep();

   // step 4: compute the key slices based on curvature from the BPA boundaries.
   infer_key_slice_based_on_curvature(ksd_output_prefix, ksd_reco_prefix);
}

void global_image_debug(int mode, void **params)
{
   if (mode == 0)  // debug image to hightlight some points
   {
      vector<int> points = *((vector<int> *)params[0]);
      BYTE **im = new_image(image_height, image_width);

      int MASK = 4;
      for (int i = 0; i < points.size(); i+=2)
      {
         int x0 = points[i];
         int y0 = points[i+1];

         for(int x = -MASK+x0; x < MASK+x0; x++)
            for (int y = -MASK+y0; y < MASK+y0; y++)
            {
               if (valid_pixel(x, y))
                  im[y][x] = BLACK;
            }
      }

      Save2File("global_image_debug_0.png", im, NULL, image_width, image_height, 0, NULL);
      free_image(im);
   
   } else if (mode == 1) {

      vector<int> pd = *((vector<int> *)params[0]);
      vector<int> td = *((vector<int> *)params[1]);
      vector<int> all_lines;

      for (int i = 0; i < pd.size(); i ++)
      {
         int p0 = pd[i];
         int t0 = td[i];
         int x1, y1, x2, y2;
         if (t0 == 90)
         {
            x1 = 0;
            y1 = p0;
            x2 = image_width -1;
            y2 = y1;
         }  else {
            double ptStart = p0/cos(PI*((double)t0/(double)180));
            double ptEnd = -image_height*(tan(PI*((double)t0/(double)180))) + ptStart;
            x1 = (int)(ptStart + .5);
            y1 = 0;
            x2 = (int)(ptEnd + .5);
            y2 = image_height - 1;
         }

         all_lines.push_back(x1);      
         all_lines.push_back(y1);      
         all_lines.push_back(x2);      
         all_lines.push_back(y2);      
         
      }
      
      write_lines_to_image("global_image_debug_1.png", all_lines, image_height, image_width);
   }
}


// Function: compute_boundary_using_ras2vec
// instead of BPA, let do ras2vec
//
void compute_boundary_using_ras2vec()
{

   // step 1: convert png image to tif format which can be read by ras2vec
   int h = 1024, w = 1024;
   char prefix[1000];
   sprintf(prefix, "%s\\aaa_image_slice", gbl_opts->input_prefix);

   if (1)
   {
#ifdef LINUX
      CImg<BYTE> *orig_img = NULL;
#else
      Bitmap *orig_img = NULL;
#endif
      BYTE **cur_im;

      assert(prefix);
      char fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.png", prefix, ds);

         if ( !file_exist(fn) ) {
            free(ds);
            continue;
         }
         
         orig_img = load_image(fn, h, w);
         set_image(cur_im, orig_img);
         sprintf(fn, "%s_%s.tif", prefix, ds);
#ifndef LINUX         
         Save2File(fn, cur_im, NULL, w, h, 0, NULL, 1);
#endif         
         free_image(cur_im);
         delete orig_img;
         free(ds);

         printf("Converting file %s\n", fn);
      }

   }
   assert ( h > 0 && w > 0);
   
   // step 2, call ras2vec to generate .ply files
   {
      assert(prefix);
      char fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.tif", prefix, ds);

         if ( !file_exist(fn) ) {
            free(ds);
            continue;
         }

         char command[1000];
         sprintf(command, "..\\ras2vec.exe -p -o %s %s", gbl_opts->output_prefix, fn);
         printf("Command: %s\n", command);
         system(command);
         free(ds);
         
         printf("Doing file %s\n", fn);
      }

   }

   // step 3, convert the .ply file to IR format
   {
      char fn[1000], out_fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.ply", prefix, ds);

         if ( !file_exist(fn) )
            continue;

         char line[1000];
         sprintf(out_fn, "%s/bbb_image_slice_%s_dumped_0.txt", gbl_opts->output_prefix, ds);
         FILE *fd = fopen(fn, "r");
         FILE *fd_out = fopen(out_fn, "w");
         while ( fgets(line, 1000, fd )) {
            if ( strncmp(line, "POLY", 4) == 0) {
               fprintf(fd_out, "BEGIN POLYGON\n");
            }
            else if ( strncmp(line, "END", 3) == 0 ) {
               fprintf(fd_out, "END POLYGON\n");
            } else {
               fprintf(fd_out, line);
            }
         }
         fclose(fd);
         fclose(fd_out);
         
         printf("Doing file %s\n", fn);
      }
   }

   
}

// Function: system_batch_process
// system call for batch process
//
// all other functions are better put above this function
// Command option: -S -O "-a 0 -A 1000 -P <path/to/source>"
void system_batch_process()
{
   // batch 1: generate all boundary using BPA algorithm
   int total_num = 40;
   int start_num = 0;
   int do_ras2vec = 0;
   char *path_dir = "result/point_cloud_images/slices_taper_structure";
   char *output_path_dir = NULL;
   char fn[1000];
   char ofn[1000];
   char *opt_backup;
   bool ignore_generated = false; // ignore those slices which have been processed. This is to avoid re-generating.

   if (global_opts)
   {

      opt_backup = strdup(global_opts);
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:A:b:C:c:dEe:fHh:I:L:l:Mm:O:o:P:p:Rr:S:s:t:")) != EOF)
      {
         switch (c) {
            case 'a':
               start_num = atoi(util_optarg);
               break;
            case 'P':
               path_dir = strdup(util_optarg);
               gbl_opts->input_prefix = gbl_opts->output_prefix = path_dir;
               break;
            case 'r':
               do_ras2vec = atoi(util_optarg);
               break;
            case 'O':
               output_path_dir = strdup(util_optarg);
               break;
            case 'E':
               ignore_generated = true;
               break;
            case 'A':
               total_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   if ( output_path_dir == NULL)
      output_path_dir = path_dir;

   if ( do_ras2vec ) {
      compute_boundary_using_ras2vec();
      return;
   }
   
   for (int i = start_num; i < total_num; i++)
   {
      char *ds = digit_string(3, i);
      sprintf(fn, "%s/aaa_image_slice_0%s.png", path_dir, ds);
      sprintf(ofn, "%s/bbb_image_slice_0%s_dumped_0.txt", output_path_dir, ds);
      
      // check file existance.
      if (!file_exist(fn) || ( file_exist(ofn) && ignore_generated )) {
         free(ds);
         continue;
      }

      // start real work here
      sprintf(ofn, "%s/bbb_image_slice_0%s.png", output_path_dir, ds);
      free(ds);
      output_fn = strdup(ofn);

      printf("\nBPA: Processing image file: %s\n", fn);

      // call BPA algorithm.
      // char *opt = "-r 512 -p 1 -R -t 6 -H";
      // char *opt = "-r 512 -p 1 -H";
      if (global_opts)
         free(global_opts);
      global_opts = strdup(opt_backup);
      
      BPA_boundary(fn);
      
   }
}

bool taper_is_true_pts(BYTE **cur_im, int x, int y)
{
   int MASK = 5;

   int num = 0;
   for (int i = x - MASK; i <= x + MASK; i++)
      for (int j = y - MASK; j <= y + MASK; j++)
      {
         if (valid_pixel(i,j) && cur_im[j][i] == BLACK)
            num ++;
      }

   return num > MASK;
}


// Function: compute_intersection_point()
//
//
int compute_intersection_point(int pd0, int td0, int pd1, int td1, int &int_x, int &int_y)
{
   if (td1 == td0) // parallel lines
      return 0;
   
   // compute the intersection point based on the above equation
   double theta1 = td0 * PI/(double)180;
   double theta2 = td1 * PI/(double)180;
   double y_de = sin(theta1) * cos(theta2) - sin(theta2) * cos(theta1);

   if (y_de == 0)
      return 0;

   y_de = (pd0 * cos(theta2) - pd1 * cos(theta1)) / y_de;

   assert(cos(theta1) != 0 || cos(theta2) != 0);
   double x_de;
   if (cos(theta1) != 0)
      x_de = (pd0 - y_de * sin(theta1))/cos(theta1);
   else
      x_de = (pd1 - y_de * sin(theta2))/cos(theta2);

   int_x = (int)(x_de + .5);
   int_y = (int)(y_de + .5);

   return 1;
}

// Function: taper_comp_ins_points_in_im
//
// An old way to compute tapered structure by 3D line fitting
// the outmost function is <taper_structure_infer>
// Helper function <taper_structure_infer>
//
void taper_comp_ins_points_in_im(BYTE **cur_im,
                                 vector<int> &pd,
                                 vector<int> &td,
                                 vector<int> &points)
{
   assert(pd.size() == td.size());

   // compute the possible corner points
   // based on wiki/hough transform
   // y = mx + b; or r(@) = x*cos(@) + y*sin(@)
   // y = (r1*cos(@2) - r2*cos(@1))/(sin(@1)*cos(@2) - sin(@2)*cos(@1))
#if 1
   vector<int> todo_index;
   for (int i = 1 ; i < pd.size(); i++)
      todo_index.push_back(i);

   int cur_i = 0;
   // in case the polygon is not closed, we may start from the other line.
   int left_index = -1; 
   int right_index = -1;
   while(1)
   {
      int pd0 = pd[cur_i];
      int td0 = td[cur_i];
      int next_index = -1;
      for (int k = 0; k < todo_index.size(); k ++)
      {
         int j = todo_index[k];

         // compute the intersection point based on the above equation
         int x, y;
         int ret = compute_intersection_point(pd0, td0, pd[j], td[j], x, y);
         if (ret == 0)
            continue;

         if (valid_pixel(x, y) && taper_is_true_pts(cur_im, x, y))
         {
            points.push_back(x);
            points.push_back(y);
            next_index = k;

            if (cur_i == 0 ) {
               if (left_index == -1)
                  left_index = j;
               else if (right_index = -1)
                  right_index = j;
               else {
                  printf(" ERROR : more than 2 points for a line\n");
                  assert(0);
               }
            }
            
            my_printf("%d - %d, intersect with %d - %d, point: %d - %d\n", pd0, td0, pd[j], td[j],x,y);
         }
         
      }

      // sanity check
      if (next_index == -1 && todo_index.size() > 0)
      {
         // try another one
         printf("WARNING: The HT lines are not correct for this image! Let's move on to the next one ...\n");
         break;
         //assert(0);
         
      } else if (todo_index.size() == 1) {

         // while exit point, perfect
         break;

      } else {
         cur_i = todo_index[next_index];
         todo_index.erase(todo_index.begin() + next_index);
      }
   }
#else
   for (int i = 0 ; i < pd.size(); i++)
   {
      int pd0 = pd[i];
      int td0 = td[i];
      for (int j = i+1; j < pd.size(); j ++)
      {
         if (td[j] == td0) // parallel lines
            continue;

         // compute the intersection point based on the above equation
         double theta1 = td0 * PI/(double)180;
         double theta2 = td[j] * PI/(double)180;
         double y_de = sin(theta1) * cos(theta2) - sin(theta2) * cos(theta1);
         if (y_de == 0) continue;

         y_de = (pd0 * cos(theta2) - pd[j] * cos(theta1)) / y_de;

         assert(cos(theta1) != 0 || cos(theta2) != 0);
         double x_de;
         if (cos(theta1) != 0)
            x_de = (pd0 - y_de * sin(theta1))/cos(theta1);
         else
            x_de = (pd[j] - y_de * sin(theta2))/cos(theta2);

         int x = (int)(x_de + .5);
         int y = (int)(y_de + .5);

         if (valid_pixel(x, y))
         {
            points.push_back(x);
            points.push_back(y);
            my_printf("%d - %d, intersect with %d - %d, point: %d - %d\n", pd0, td0, pd[j], td[j],x,y);
         }
         
      }
   }
#endif   
}

// Function: taper_comp_cor_pts_and_base
//
// Compute the corresponding feature points and base polygon
// An old way to compute tapered structure by 3D line fitting
// the outmost function is <taper_structure_infer>
//
// The return values:
// layer_index - vector<int> the index of the layer number, which the feature points in this layer are used as an input for 3D line fitting.
// matched_arr - array_t <vector<int> *> the layers with majority number of feature points.
array_t* taper_comp_cor_pts_and_base(array_t *layer_arr, vector<int> &layer_index)
{
   int layer_num = array_n(layer_arr);

   int *a = new int[layer_num]; // store the number of the points in a layer;
   int *b = new int[layer_num]; // count how many votes for the corresponding a;
   
   for (int i = 0; i < layer_num; i ++)
   {
      a[i] = -1;
      b[i] = 0;
   }

   for (int i = 0; i < layer_num; i ++)
   {
      vector<int> *layer_pts = array_fetch(vector<int> *, layer_arr, i);
      for (int k = 0; k < layer_num ; k ++)
         if (layer_pts->size() == a[k]) {
            b[k] ++;
            break;
         } else if (a[k] == -1) { // if there is no size in a[k], create a new one.
            a[k] = layer_pts->size();
            b[k] = 1;
            break;
         }
   }

   // get the majority and compute the corresponding points
   int maj_pts = 0;
   for (int i = 0; i < layer_num; i ++)
   {
      if (b[i] == 0) break;
      if (b[maj_pts] < b[i]) {
         maj_pts = i;
      }
   }

   printf("The majority feature points is %d, %d out of %d is majority\n", a[maj_pts], b[maj_pts], layer_num);
   if (b[maj_pts] < layer_num * 0.67)
      printf("WARNING: The majority number is less than 2/3 of the total!!!!\n");

   // compute the correspondings
   // for each layer feature points, we compute the nearest points as corresponding points.
   // we use the first majority feature points as ordered template, and find the next layer's
   // ordered feature points and insert into matched_arr.
   int first_layer_major = true; // if first layer is not majority,we have to reconstruct the base.
   int found_majority = false;   // for the first layer which has majority number of feature points.
   vector<int> *maj_vec = NULL;
   array_t *matched_arr = array_alloc(vector<int> *, 0);
   for (int i = 0; i < layer_num; i ++)
   {
      vector<int> *layer_pts = array_fetch(vector<int> *, layer_arr, i);
      printf("layer %d:\n", i);
      for(int k= 0; k < layer_pts->size(); k+=2)
         printf("[%d, %d],",(*layer_pts)[k], (*layer_pts)[k+1]);
      printf("\n");
      
      if (i == 0 ) {
         // sanity checking
         if (layer_pts->size() !=  a[maj_pts]) {
            printf("WARNING: The first layer's feature points is not a majority number. \n");
            first_layer_major = false;
         }
         continue;
      }

      if (layer_pts->size() != a[maj_pts]) {
         printf("WARNING: The %dth layer's feature points is not a majority number. \n", i+1);
         continue;
      }

      if (layer_pts->size() == a[maj_pts] && !found_majority)
      {
         found_majority = true;
         maj_vec = new vector<int> (*layer_pts);
         array_insert_last(vector<int> *, matched_arr, maj_vec);
         layer_index.push_back(i);
         continue;
      }

      if (!found_majority) continue;

      assert(a[maj_pts] == layer_pts->size());
      // same size, find match points
      vector<int> *new_maj_vec = new vector<int>();
      int *mark = new int[a[maj_pts]];
      {
         for (int i = 0 ; i < a[maj_pts]; i ++)
            mark[i] = 0;
      }
      {
         for (int i = 0 ; i < a[maj_pts]; i +=2 )
         {
            int x0 = (*maj_vec)[i];
            int y0 = (*maj_vec)[i+1];

            int min_manh = image_width+image_height;
            int min_index = 0;
            for (int k = 0; k < a[maj_pts]; k +=2)
            {
               int dis = abs(x0 - (*layer_pts)[k]) + abs(y0 - (*layer_pts)[k+1]);
               if (dis < min_manh)
               {
                  min_manh = dis;
                  min_index = k;
               }
            }

            if (mark[min_index])
            {
               printf("ERROR: Something is wrong, the corresponding points of [%d, %d] was found to be the point [%d, %d]\n", x0, y0, (*maj_vec)[mark[min_index-1]], (*maj_vec)[mark[min_index]]);
               exit(0);
            } else {
               mark[min_index] = i+1;
               mark[min_index+1] = i+1;
               new_maj_vec->push_back((*layer_pts)[min_index]);
               new_maj_vec->push_back((*layer_pts)[min_index+1]);
            }
         
         }
      }
      
      assert(new_maj_vec->size() == maj_vec->size());
      maj_vec = new_maj_vec;
      array_insert_last(vector<int> *,  matched_arr, maj_vec);
      layer_index.push_back(i);
   }

   // free memory
   free(a);
   free(b);

   return matched_arr;
}

// Function: taper_fitting_3D_line
//
// An old way to compute tapered structure by 3D line fitting
// the outmost function is <taper_structure_infer>
//
// Refer to link: http://en.wikipedia.org/wiki/User:Vossman/3D_Line_Regression
// Return: for each line, a set of params is added into the array as the order of v_x, v_y, x_0, y_0;
//
array_t *taper_fitting_3D_line(array_t *matched_arr, vector<int> layer_index)
{
   // based on the above link, the equations to compute the parameters are (latex representation):
   // Vx' = \frac{\sum_{i}x_i*\sum_{i}z_i - N*\sum_{i}(x_i*z_i)}{\sum_{i}z_i*\sum_{i}z_i - N*\sum_{i}z_i^2}
   // Or check the render: http://www.codecogs.com/components/equationeditor/equationeditor.php
   // let A = \sum_{i}x_i;
   //     B = \sum_{i}z_i;
   //     C = \sum_{i}x_i*z_i;
   //     D = \sum_{i}z_i^2;
   //     E = \sum_{i}y_i;
   //     F = \sum_{i}y_i*z_i;
   //     v_x'=\frac{A*B -N*C}{B^2 - N*D}
   //     x_0 = \frac{E-B*v_x'}{N}

   // define a global Z interval
   double z_int = 6.0;
   
   // construct the data structure
   assert(array_n(matched_arr) > 0);
   vector<int> *layer_pts;
   layer_pts = array_fetch(vector<int> *, matched_arr, 0);
   int len = layer_pts->size() / 2;
   assert(len > 0);
   vector<double> *X = new vector<double> [len];
   vector<double> *Y = new vector<double> [len];
   vector<double> *Z = new vector<double> [len];

   array_t *params_set = array_alloc(vector<double> *, 0);

   int i;
   arrayForEachItem(vector<int> *, matched_arr, i, layer_pts) {
      for (int feature_i = 0; feature_i < len; feature_i ++)
      {
         X[feature_i].push_back((*layer_pts)[2*feature_i]);
         Y[feature_i].push_back((*layer_pts)[2*feature_i+1]);
         Z[feature_i].push_back(layer_index[i] * z_int);
      }
      
   }

   // compute the lines
   double A, B, C, D, E, F, v_x, v_y, x_0, y_0;
   int data_len = array_n(matched_arr);
   for (int i = 0 ; i < len; i ++)
   {
      // initilize the vars
      A = 0.0; B = 0.0; C = 0.0; D = 0.0; E = 0.0; F = 0.0; 
      for (int k = 0; k < data_len; k ++)
      {
         A += X[i][k];
         B += Z[i][k];
         C += X[i][k] * Z[i][k];
         D += Z[i][k] * Z[i][k];
         E += Y[i][k];
         F += Y[i][k] * Z[i][k];
      }

      double temp = (B * B - data_len * D);
      v_x = (A * B - data_len * C)/temp;
      v_y = (E * B - data_len * F)/temp;
      x_0 = (A - B * v_x)/(double)data_len;
      y_0 = (E - B * v_y)/(double)data_len;

      vector<double> *a_set = new vector<double>;
      a_set->push_back(v_x);
      a_set->push_back(v_y);
      a_set->push_back(x_0);
      a_set->push_back(y_0);
      array_insert_last(vector<double> *, params_set, a_set);
      
   }
   
   // free memory;
   delete [] X;
   delete [] Y;
   delete [] Z;

   return params_set;
}

// Function: taper_test_3D_fitting
//
void taper_test_3D_fitting(array_t *params_set)
{
   // equations:
   // for each z, y = v_y * (z - z_0) + y_0;
   // for each z, x = v_x * (z - z_0) + x_0;
   char *pre = "./result/point_cloud_images/slices_taper_structure/slice_taper_1024_392";
   char fn[1000];
   double z_int = 6.0;
   for (int i = 0; i < 40; i ++)
   {
      printf("write out %d slice image\n", i);
      char *str = digit_string(3, i);
      sprintf(fn, "%s_%s_out.png", pre, str);
      free(str);
      
      double z = i * z_int;

      vector<int> points;
      int k;
      vector<double> *params;
      arrayForEachItem(vector<double> *, params_set, k, params) {
         double x = (*params)[0] * z + (*params)[2];
         double y = (*params)[1] * z + (*params)[3];
         assert(valid_pixel((int)x,(int)y) );
         points.push_back((int) x);
         points.push_back((int) y);
         if (k != 0 )//&& k != array_n(params_set) - 1)
         {
            points.push_back((int) x);
            points.push_back((int) y);
         }
      }

      points.push_back(points[0]);
      points.push_back(points[1]);

      write_lines_to_bw_image(fn, points, image_height, image_width);

   }
   
}

// Function: taper_output_final_represent
//
// An old way to compute tapered structure by 3D line fitting
// the outmost function is <taper_structure_infer>
// Helper function to generate final representation for dxf
//
void taper_output_final_represent(char *fn, array_t *params_set)
{
   double z_int = 6.0;
   int num_z = gbl_opts->TSG_num;

   FILE *fd = fopen(fn, "a+");
   
   fprintf(fd, "BEGIN POLYGON\n");

   double z = 0.0 /* base height */;
   int k;
   vector<double> *params;
   arrayForEachItem(vector<double> *, params_set, k, params) {
      int x = (int)((*params)[0] * z + (*params)[2] + .5);
      int y = (int)((*params)[1] * z + (*params)[3] + .5);
      fprintf(fd, "%d, %d\n", x, y);
   }

   fprintf(fd, "TAPERED\n");
   z = 0.0 + z_int * num_z;
   arrayForEachItem(vector<double> *, params_set, k, params) {
      int x = (int)((*params)[0] * z + (*params)[2] + .5);
      int y = (int)((*params)[1] * z + (*params)[3] + .5);
      fprintf(fd, "%d, %d\n", x, y);
   }

   fprintf(fd, "HEIGHT\n");
   fprintf(fd, "%d\n", (int)z);

   fprintf(fd, "END POLYGON\n");
}

// Function: taper_structure_infer
// Helper function to generate all slice images
//
// An old way to compute tapered structure by 3D line fitting
// the outmost function is <taper_structure_infer>
// Assumptions: see the doc.
// Command: Project.exe -G -O "-n x"
void taper_structure_infer()
{
   image_height = 392;
   image_width  = 1024;
   gbl_opts->TSG_num = 10;
   
   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "n:")) != EOF)
      {
         switch (c) {
            case 'n':
               /* Tapered Structure Generation Number */
               gbl_opts->TSG_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif
   char *pre = "./result/point_cloud_images/slices_taper_structure/slice_taper_";
   char file_name[1000];
   BYTE **cur_im = NULL;

   /* Here, we are computing the feature points for each layer; the points are saved into an array.
      the feature points are recoreded in the vector<int> *layer_pts, and can be easily asscessed.
    */
   array_t *layer_arr = array_alloc(vector<int> *, 0);
   for (int i = 0; i < gbl_opts->TSG_num; i++ )
   {
      char *ds = digit_string(3, i);
      sprintf(file_name, "%s%s.png", pre, ds);
      free(ds);

      printf("Processing %s ...\n", file_name);
      
      // step 1, compute the feature/corner points using HT
      int h, w;

      if (orig_img != NULL) delete orig_img;
      if (cur_im != NULL) free_image(cur_im);
      
      orig_img = load_image(file_name, h, w);
      set_image(cur_im, orig_img);

      vector<int> pdetect;
      vector<int> tetadetect;
      vector<int> points;
      my_HT_array(cur_im, h, w, pdetect, tetadetect);
      // debug the HT lines
      if (0)
      {
         void *params[2];
         params[0] = &pdetect;
         params[1] = &tetadetect;
         global_image_debug(1, params);
      }
         
      taper_comp_ins_points_in_im(cur_im, pdetect, tetadetect, points);
      // debug the results on image.
      if (0)
      {
         void *params[1];
         params[0] = &points;
         global_image_debug(0, params);
      }
      
      // step 2, find the corresponding points and verify them by comparing the angle
      vector<int> *layer_pts = new vector<int> (points);
      array_insert_last(vector<int> *, layer_arr, layer_pts);

      // if (array_n(layer_arr) == 1) continue; // the first layer points

      // compute the correspoinding points based on the distance.
      // this is done outside of the loop.
      
      // possible cases:
      //   *. the feature points numbers are different for differnt layers.
      //      -- use majority to solve this problem.
      //   *. ???
      
   }

   // step 2, find the corresponding points and base polygon thereafter.
   vector<int> layer_index;
   array_t *matched_arr = taper_comp_cor_pts_and_base(layer_arr, layer_index);
   
   // compute the equations for the corner points and possible updating of base polygon
   // we need height information between each layer to construct the 3D coordinates.
   array_t *params_set = taper_fitting_3D_line(matched_arr, layer_index);

   // test and output the results
   {
      if (1)
         taper_test_3D_fitting(params_set);

      taper_output_final_represent("rep.txt", params_set);
   }
   
   
}


// Function: generate_slices_for_model_tapers
//
// Command: project.exe -g -O "-t 1 -n 1000 -p result/point_cloud_TP_1000/slices_1000_1024_392_bottom_up
//                             -h 392 -w 1024 -x -4.0 -X 14.0 -y -2.0 -Y 18.0 -z -5.0 -Z 5.0"
//
// model description:
//      Y cutoff are:
//               0 - bottom 5 - top of house 8 - taper-line 10 - top of tower, 15 - taper-point
//      X cutoff are:
//              -2 - left tower, 0 - right tower, 1 - left house, 11 - right house
//      Z cutoff are:
//              -4 - inside house, -1 - inside tower, 1 - outside tower, 4 - outside house
void generate_slices_for_model_tapers( void **params )
{
   // decode the parameters
   VERBOSE_LEVEL db  = KEY_INFO; // debug?
   int sample_rate   = gbl_opts->TSG_num;
   char *output_path  = (char *) params[0];
   float x_min = *(float *)params[1];
   float x_max = *(float *)params[2];
   float y_min = *(float *)params[3];
   float y_max = *(float *)params[4];
   float z_min = *(float *)params[5];
   float z_max = *(float *)params[6];
   float x_diff = x_max - x_min;
   float y_diff = y_max - y_min;
   float z_diff = z_max - z_min;

   int x_points[20];
   int z_points[20];

   // compute points coordinates on image
   {
      x_points[0] = (int)((-2.0 - x_min)/x_diff * image_width + .5);
      x_points[1] = (int)(( 0.0 - x_min)/x_diff * image_width + .5);
      x_points[2] = (int)(( 1.0 - x_min)/x_diff * image_width + .5);
      x_points[3] = (int)((11.0 - x_min)/x_diff * image_width + .5);

      z_points[0] = (int)((-4.0 - z_min)/z_diff * image_height + .5);
      z_points[1] = (int)((-1.0 - z_min)/z_diff * image_height + .5);
      z_points[2] = (int)(( 1.0 - z_min)/z_diff * image_height + .5);
      z_points[3] = (int)(( 4.0 - z_min)/z_diff * image_height + .5);
   }
   
   vector<int> line_set;
   for (int i = 0; i < sample_rate; i ++ )
   {
      printf("Generate slice number %d...\n", i);
      char *ds = digit_string(4, i);
      char fn[1000];
      sprintf(fn, "%s/image_slice_%s.png", output_path, ds);
      free(ds);

      // manually generate some slices for modeling
      // draw image based on the height of Y
      float y_cutoff = y_min + y_diff*((float)i/(float)sample_rate);

      if ( y_cutoff < 0 ) {
         // do nothing, just a empty image
      }
      else if ( y_cutoff < 5.0 ) {
         // draw ___
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]);
         
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]); 
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]);
        
         // draw ___
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]);
        
         // draw  ___
         // draw |___|
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
        
         // draw  ___
         // draw |___|  
         // draw        ____________  
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[0]); 
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[0]);
        
         // draw                    
         // draw  ___               |
         // draw |___|              |
         // draw        ____________|  
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[0]); 
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[3]);
        
         // draw        ____________             
         // draw  ___               |
         // draw |___|              |
         // draw        ____________|  
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[3]); 
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[3]);
        
         // draw        ____________             
         // draw  ___  |            |
         // draw |___| |            |
         // draw       |____________|
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[3]); 
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[0]);
        
      }
      else if ( y_cutoff < 8.0 ) {
         // draw ___
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]);
         
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]); 
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]);
        
         // draw ___
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]);
        
         // draw  ___
         // draw |___|
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
        
         float ratio = (8.0 - y_cutoff)/(8.0 - 5.0);
         z_points[0] = (int)((-4.0*ratio - z_min)/z_diff * image_height + .5);
         z_points[3] = (int)(( 4.0*ratio - z_min)/z_diff * image_height + .5);
         
         // draw  ___
         // draw |___|  
         // draw        ____________  
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[0]); 
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[0]);
        
         // draw                    
         // draw  ___               |
         // draw |___|              |
         // draw        ____________|  
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[0]); 
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[3]);
        
         // draw        ____________             
         // draw  ___               |
         // draw |___|              |
         // draw        ____________|  
         line_set.push_back(x_points[3]);
         line_set.push_back(z_points[3]); 
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[3]);
        
         // draw        ____________             
         // draw  ___  |            |
         // draw |___| |            |
         // draw       |____________|
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[3]); 
         line_set.push_back(x_points[2]);
         line_set.push_back(z_points[0]);

      }
      else if ( y_cutoff < 10.0 ) {

         // draw ___
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]);
         
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]); 
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]);
        
         // draw ___
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]);
        
         // draw  ___
         // draw |___|
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);

      }
      else if ( y_cutoff < 15.0 ) {

         float ratio = (15.0 - y_cutoff)/(15.0 - 10.0);
         x_points[0] = (int)((-2.0 + (1.0  * (1.0 - ratio)) - x_min)/x_diff * image_width + .5);
         x_points[1] = (int)(( 0.0 + (-1.0 * (1.0 - ratio)) - x_min)/x_diff * image_width + .5);
         z_points[1] = (int)((-1.0*ratio - z_min)/z_diff * image_height + .5);
         z_points[2] = (int)(( 1.0*ratio - z_min)/z_diff * image_height + .5);
         
         // draw ___
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]);
         
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[1]); 
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]);
        
         // draw ___
         // draw ___|
         line_set.push_back(x_points[1]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]);
        
         // draw  ___
         // draw |___|
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[2]); 
         line_set.push_back(x_points[0]);
         line_set.push_back(z_points[1]);

      }

      write_lines_to_bw_image(fn, line_set, image_height, image_width);
      line_set.clear();
   }
   
}

// Function: taper_image_generation
// Helper function to generate all slice images
//
// Command: project.exe -g
void taper_image_generation()
{
   image_height = 392;
   image_width  = 1024;
   int model_type = 0;
   char *output_path;
   void **params;
   float x_min[1], x_max[1], y_min[1], y_max[1], z_min[1], z_max[1];

   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "n:w:h:t:p:x:X:y:Y:z:Z:")) != EOF)
      {
         switch (c) {
            case 'n':
               /* Tapered Structure Generation Number */
               gbl_opts->TSG_num = atoi(util_optarg);
               break;
            case 'h':
               image_height = atoi(util_optarg);
               break;
            case 'w':
               image_width = atoi(util_optarg);
               break;
            case 't':
               model_type = atoi(util_optarg);
               break;
            case 'p':
               output_path = strdup(util_optarg);
               break;
            case 'x':
               x_min[0] = atof(util_optarg);
               break;
            case 'X':
               x_max[0] = atof(util_optarg);
               break;
            case 'y':
               y_min[0] = atof(util_optarg);
               break;
            case 'Y':
               y_max[0] = atof(util_optarg);
               break;
            case 'z':
               z_min[0] = atof(util_optarg);
               break;
            case 'Z':
               z_max[0] = atof(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   if ( model_type == 1 ) { // create taper-to-point and taper-to-line

      printf("Generating slices for taper-to-point model.\n");
      
      const int NUM_PARAM = 20;
      params = (void **) malloc( NUM_PARAM * sizeof(void *));
      params[0] = (void *)output_path;
      params[1] = (void *)x_min;
      params[2] = (void *)x_max;
      params[3] = (void *)y_min;
      params[4] = (void *)y_max;
      params[5] = (void *)z_min;
      params[6] = (void *)z_max;

      generate_slices_for_model_tapers(params);

      free(params);
      return;
   }
   
   // write out the image slices.
   // try two cases:
   //    * 5 polygon
   //    * 4 polygon with x axis unchanged.
   int layer_number = 40;

   //int num_pts = 4;
   //int x0 = 350, y0 = 200;
   //int x[] = {100, 100, 600, 600};
   //int y[] = {100, 300, 300, 100};

   int num_pts = 5;
   int x0 = 380, y0 = 215;
   int x[] = {100, 130, 600, 640, 400};
   int y[] = {100, 350, 300, 120, 50};
   
   double *offset_x = new double[num_pts];
   double *offset_y = new double[num_pts];
   for ( int i = 0; i < num_pts; i ++)
   {
      offset_x[i] = (double)(x0 - x[i])/(double)layer_number;
      offset_y[i] = (double)(y0 - y[i])/(double)layer_number;
   }

   char *pre = "result/point_cloud_images/slices_taper_structure/";
   char fn[1000];
   BYTE **im;
   for (int i = 0; i < layer_number; i ++)
   {
      printf("write out %d slice image\n", i);
      char *str = digit_string(3, i);
      sprintf(fn, "%sslice_taper_%s.png", pre, str);
      free(str);

      /* regular polygon of side 4
      int p1 = index((int)(x1 + offset_x * i + .5), (int)(y1 + offset_y * i + .5));
      int p2 = index((int)(x2 - offset_x * i + .5), (int)(y2 - offset_y * i + .5));

      // x invariant
      // int p1 = index((int)(x1), (int)(y1 + offset_y * i + .5));
      // int p2 = index((int)(x2), (int)(y2 - offset_y * i + .5));

      draw_line_on_2D_image(im, image_height, image_width, x_axis(p1), y_axis(p1), x_axis(p1), y_axis(p2));
      draw_line_on_2D_image(im, image_height, image_width, x_axis(p1), y_axis(p1), x_axis(p2), y_axis(p1));
      draw_line_on_2D_image(im, image_height, image_width, x_axis(p2), y_axis(p2), x_axis(p1), y_axis(p2));
      draw_line_on_2D_image(im, image_height, image_width, x_axis(p2), y_axis(p2), x_axis(p2), y_axis(p1));
      */

      vector<int> line_set;
      for (int j = 0; j < num_pts ; j ++)
      {
         line_set.push_back(x[j]);
         line_set.push_back(y[j]);
         line_set.push_back(x[(j+1)%num_pts]);
         line_set.push_back(y[(j+1)%num_pts]);
      }

      // update the x, y
      for (int j = 0; j < num_pts ; j ++)
      {
         x[j] = (int)(x[j] + offset_x[j] + .5);
         y[j] = (int)(y[j] + offset_y[j] + .5);
      }

      write_lines_to_bw_image(fn, line_set, image_height, image_width);
   }

   delete []offset_x;
   delete []offset_y;

}


// Function: dump_boundary_points_to_IR
//
// An naive way to output IR, which doesnot consider the tapered structure yet.
//
// Input: the boundary files for each key slices
// Output: an IR file with the IR representation of the boundaries
// Command: project.exe -E -O "-s <N> -e <N> -p <path> -w -h"
void dump_boundary_points_to_IR()
{

   char *path_dir = "result/point_cloud_images/slices_1000_0.0_44.0_result";
   int start_num = 0;
   int frame_num = 1000;
   double pre_height = 0.0;
   image_height = 392;
   image_width  = 1024;
   int bpa_algorithm = 1;
   char *ir_fn = "ir.txt";

   if (global_opts)
   {
      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:s:e:p:w:h:f:")) != EOF)
      {
         switch (c) {
            case 'a':
               bpa_algorithm = atoi(util_optarg);
               break;
            case 's':
               start_num = atoi(util_optarg);
               break;
            case 'w':
               image_width = atoi(util_optarg);
               break;
            case 'h':
               image_height = atoi(util_optarg);
               break;
            case 'e':
               frame_num = atoi(util_optarg);
               break;
            case 'p':
               path_dir = strdup(util_optarg);
               break;
            case 'f':
               ir_fn = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }
   
   char out_fn[1000];
   sprintf(out_fn, "%s/../%s", path_dir, ir_fn);
   FILE *fd = fopen(out_fn, "w+");
   assert(fd);

   int theLastLayer = 0;
   for (int i = frame_num - 1 ; i >= 0; i --)
   {
      char file_name[1000];
      char *ds = digit_string(3, i);
      sprintf(file_name, "%s/bbb_image_slice_0%s_dumped_%d.txt", path_dir, ds, bpa_algorithm);
      free(ds);

      if (file_exist(file_name)) {
         theLastLayer = i;
         break;
      }
   }
   assert(theLastLayer != 0);
   
   for (int i = start_num ; i < frame_num; i ++)
   {
      {
         char file_name[1000];
         char *ds = digit_string(3, i);
         sprintf(file_name, "%s/bbb_image_slice_0%s_dumped_%d.txt", path_dir, ds, bpa_algorithm);
         free(ds);

         if (!file_exist(file_name))
            continue;

         printf("Dumping the file: %s\n", file_name);
         FILE *in_fd = fopen(file_name, "r");
         assert(in_fd);
         
         // compute the height
         double cur_height = i/(double)frame_num;

         // do not start from ZERO ???
         if (gbl_opts->IR_do_not_extend_the_first_key_slice_to_zero == 1 && pre_height == 0.0)
            pre_height = cur_height;

         if ( theLastLayer == i && gbl_opts->IR_do_not_extend_the_last_key_slice_to_one == 0 )
            cur_height = 1.0;   // find the last one

         // find a key slice, dump it into IR.
         char str_line[1000];
         char *pre_point = NULL;
         while (fgets(str_line, 1000, in_fd))
         {
            if (strncmp(str_line, "END", 3) == 0)
            {
               fprintf(fd, "EXTRUSION\nHEIGHT\n");
               fprintf(fd, "%f %f\n", pre_height, cur_height);
               fprintf(fd, "END POLYGON\n");
               pre_point = NULL;
            } else {
               // to avoid the duplicated point;
               if ( pre_point == NULL || strcmp(pre_point, str_line) != 0 ) {
                  fprintf(fd, "%s", str_line);
                  
                  if (pre_point)
                     free(pre_point);
                  pre_point = strdup(str_line);
               }
            }
         }
         fclose(in_fd);
         
         // update the vars
         pre_height = cur_height;
         
      }

   }

   fclose(fd);
}

// Function: load_end_points_from_IR
//
// To be generalized: load data from intermedia representation.
// see doc for more detailed format.
//
// return: an array pointer pointing to an array
// know issue: height is not correct if two polygon have different height.
array_t * load_end_points_from_IR(const char *fn, array_t *z_arr)
{
   FILE *fd = fopen(fn,"r");
   printf("file is [%s]\n", fn);
   assert(fd);

   // let's merge the load functions 
   // return load_end_points_from_IR_with_dirs(fn, z_arr);

   float base, top;
   int x, y, index = -1;
   int mode = -1;
   array_t *result_arr = array_alloc(vector<int> *, 0);
   array_t *return_arr = array_alloc(array_t *, 0);
   char line_str[1000];
   int line_no = 0;
   int unit_type = 0;  // 0: extruded 1: tapered

   while (fgets(line_str, 1000, fd))
   {
      line_no ++; 
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      if (!strncmp(line_str, "BEG", 3))
      {
         mode = 0;
         continue;
      }
      
      if (!strncmp(line_str, "ImageSize", 9) ){
         assert(sscanf(line_str, "ImageSize %dx%d", &image_width, &image_height) == 2);
         continue;
      }

      if (!strncmp(line_str, "TAP", 3))
      {
         mode = 1;
         index = 0;
         unit_type = 1;
         continue;
      }

      if (!strncmp(line_str, "EXTRUSION", 9))
      {
         assert(mode == 0);
         unit_type = 0;

         // make sure there are four elements in each vector<int>
         int i;
         vector<int> *vecs;
         arrayForEachItem(vector<int> *, result_arr, i, vecs) {
            assert(vecs->size() == 2);
            vecs->push_back((*vecs)[0]);
            vecs->push_back((*vecs)[1]);
         }
         continue;
      }

      if (!strncmp(line_str, "HEI", 3))
      {
         mode = 2;
         continue;
      }
      
      if (!strncmp(line_str, "END", 3))
      {
         // make sure there are four elements in each vector<int>

         /* remove this: I want to load vector_dump file where there is only BEGIN/END pair.
         int i;
         vector<int> *vecs;
         arrayForEachItem(vector<int> *, result_arr, i, vecs) {
            assert(vecs->size() == 4);
         }
         */

         if (array_n(result_arr) > 0)
         {
            array_insert_last(array_t *, return_arr, result_arr);
            result_arr = array_alloc(vector<int> *, 0);
         }
         
         continue;
      }

      if (mode == 0)
      {
         assert(sscanf(line_str, "%d %d", &x, &y) == 2);
         vector<int> *new_entry = new vector<int> ();
         new_entry->push_back(x);
         new_entry->push_back(y);
         array_insert_last(vector<int> *, result_arr, new_entry);
         
      } else if (mode == 1) {

         assert(sscanf(line_str, "%d %d", &x, &y) == 2);
         vector<int> *new_entry;
         new_entry = array_fetch(vector<int> *, result_arr, index++);
         assert(new_entry->size() == 2);
         new_entry->push_back(x);
         new_entry->push_back(y);
         
      } else if (mode == 2) {
         if (array_n(result_arr) > 0) {
            assert(sscanf(line_str, "%f %f", &base, &top));
            vector<float> *new_entry = new vector<float> ();
            new_entry->push_back(base);
            new_entry->push_back(top);
            new_entry->push_back((float)unit_type);
            array_insert_last(vector<float> *, z_arr, new_entry);
         }
      }
   }
   
   fclose(fd);

   return return_arr;
   
}

// Function: load_end_points_from_IR_with_dirs
//
// To be generalized: load data from intermedia representation.
// see doc for more detailed format.
//
// return: an array pointer pointing to an array
// know issue: height is not correct if two polygon have different height.
array_t * load_end_points_from_IR_with_dirs(const char *fn, array_t *z_arr)
{
   FILE *fd = fopen(fn,"r");
   assert(fd);

   float base, top;
   int x, y, index = -1;
   int mode = -1;
   array_t *result_arr = array_alloc(vector<float> *, 0);
   array_t *return_arr = array_alloc(array_t *, 0);
   char line_str[1000];
   int line_no = 0;
   int unit_type = 0;  // 0: extruded 1: tapered
   int dir = -1;       // direction
   int dir_group = -1;
   int type = 0;       // data type: 0 - regular extrusion, 1 - taper, 2 - transformed extrusion
   bool has_normal = 0;
   vector<float> normal;

   while (fgets(line_str, 1000, fd))
   {
      line_no ++; 
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      if (!strncmp(line_str, "BEG", 3) || !strncmp(line_str, "DIR", 3))
      {
         mode = 0;
         continue;
      }
      
      if (!strncmp(line_str, "ImageSize", 9) ){
         assert(sscanf(line_str, "ImageSize %dx%d", &image_width, &image_height) == 2);
         continue;
      }

      if (!strncmp(line_str, "TAP", 3))
      {
         mode = 1;
         index = 0;
         unit_type = 1;
         continue;
      }

      if (!strncmp(line_str, "TYP", 3))
      {
         mode = 4;
         continue;
      }
      
      if (!strncmp(line_str, "NOR", 3))
      {
         mode = 6;
         continue;
      }
      
      if (!strncmp(line_str, "EXT", 3))
      {
         unit_type = 0;

         vector<float> *new_entry = new vector<float> ();
         assert( dir != -1);
         assert( dir_group != -1);
         new_entry->push_back((float)dir);
         new_entry->push_back((float)unit_type);
         new_entry->push_back(base);
         new_entry->push_back(top);
         new_entry->push_back((float)dir_group);
         new_entry->push_back((float)type);
         if ( has_normal ) {
            new_entry->push_back(normal[0]);
            new_entry->push_back(normal[1]);
            new_entry->push_back(normal[2]);
            has_normal = 0;
            normal.clear();
         }

         array_insert_last(vector<float> *, z_arr, new_entry);
         

         // make sure there are 6 elements in each vector<float>
         int i;
         vector<float> *vecs;
         arrayForEachItem(vector<float> *, result_arr, i, vecs) {
            assert(vecs->size() == 3);

            if ( dir == 0 ) {   // y axis

               vecs->push_back((*vecs)[0]);
               vecs->push_back(top);
               vecs->push_back((*vecs)[2]);

            } else if ( dir == 1 ) { // z axis
            
               vecs->push_back((*vecs)[0]);
               vecs->push_back((*vecs)[1]);
               vecs->push_back(top);

            } else { // x axis

               assert ( dir == 2 );
               vecs->push_back(top);
               vecs->push_back((*vecs)[1]);
               vecs->push_back((*vecs)[2]);
            }

         }
         continue;
      }

      if (!strncmp(line_str, "HEI", 3))
      {
         mode = 2;
         continue;
      }
      
      if (!strncmp(line_str, "POI", 3))
      {
         if ( type == 2 ) {
            mode = 5;
         } else {
            mode = 3;
         }
         continue;
      }
      
      if (!strncmp(line_str, "END", 3))
      {
         if (array_n(result_arr) > 0)
         {
            array_insert_last(array_t *, return_arr, result_arr);
            result_arr = array_alloc(vector<float> *, 0);
         }

         type = 0;
         continue;
      }

      if (mode == 0)
      {
         assert(sscanf(line_str, "%d %d", &dir, &dir_group) == 2);
         
      } else if (mode == 3) {

         float f1, f2;
         assert(sscanf(line_str, "%f %f", &f1, &f2) == 2);
         vector<float> *new_entry = new vector<float> ();

         if ( dir == 0 ) {   // y axis

            new_entry->push_back(f1);
            new_entry->push_back(base);
            new_entry->push_back(f2);

         } else if ( dir == 1 ) { // z axis
            
            new_entry->push_back(f1);
            new_entry->push_back(f2);
            new_entry->push_back(base);

         } else { // x axis

            assert ( dir == 2 );
            new_entry->push_back(base);
            new_entry->push_back(f2);
            new_entry->push_back(f1);
         }

         
         array_insert_last(vector<float> *, result_arr, new_entry);
         
      } else if (mode == 4) {

         assert(sscanf(line_str, "%d", &type) == 1);
         assert(type >= 0 && type <= 2);
         if ( type == 2 ) {
            mode = 5;
         } else {
            mode = 3;
         }

      } else if (mode == 5) {

         float f1, f2, f3;
         assert(sscanf(line_str, "%f %f %f", &f1, &f2, &f3) == 3);
         vector<float> *new_entry = new vector<float> ();

         new_entry->push_back(f1);
         new_entry->push_back(f2);
         new_entry->push_back(f3);

         array_insert_last(vector<float> *, result_arr, new_entry);
         
      } else if (mode == 6) {

         float f1, f2, f3;
         assert(sscanf(line_str, "%f %f %f", &f1, &f2, &f3) == 3);
         normal.push_back(f1);
         normal.push_back(f2);
         normal.push_back(f3);
         has_normal = 1;

      } else if (mode == 1) {

         printf("DIDNOT handle yet, do it now!\n");
         assert(0);  // let's do it later
         
      } else if (mode == 2) {

         assert(sscanf(line_str, "%f %f", &base, &top));

      } else {

         printf("ERROR: Dont know how to handle this line: %s\n", line_str);
         exit(0);
      }

      // reset mode
      if ( mode != 3 && mode != 5 )
         mode = -1;
   }
   
   fclose(fd);

   return return_arr;
   
}


// Function: load_end_points_from_IR_with_follow_me
//
// To be generalized: load data from intermedia representation.
// see doc for more detailed format.
//
// return: an array pointer pointing to an array
// know issue: height is not correct if two polygon have different height.
array_t * load_end_points_from_IR_with_follow_me(const char *fn, array_t *z_arr, array_t *fm_arr)
{
   FILE *fd = fopen(fn,"r");
   printf("file is [%s]\n", fn);
   assert(fd);

   float base, top;
   int x, y, index = -1;
   int mode = -1;
   array_t *result_arr = array_alloc(vector<int> *, 0);
   array_t *return_arr = array_alloc(array_t *, 0);
   char line_str[1000];
   int line_no = 0;
   int unit_type = 0;  // 0: extruded 1: tapered 2: follow-me

   bool paired = false;
   vector<int> *paired_new_entry;
   vector<float> *fm_new_entry;
   while (fgets(line_str, 1000, fd))
   {
      line_no ++; 
      // get rid of the new line char.
      line_str[strlen(line_str) - 1] = '\0';

      if (!strncmp(line_str, "BEG", 3))
      {
         mode = 0;
         continue;
      }
      
      if (!strncmp(line_str, "ImageSize", 9) ){
         assert(sscanf(line_str, "ImageSize %dx%d", &image_width, &image_height) == 2);
         continue;
      }

      if (!strncmp(line_str, "TAP", 3))
      {
         mode = 1;
         index = 0;
         unit_type = 1;
         continue;
      }

      if (!strncmp(line_str, "EXTRUSION", 9))
      {
         assert(mode == 0);
         unit_type = 0;

         // make sure there are four elements in each vector<int>
         int i;
         vector<int> *vecs;
         arrayForEachItem(vector<int> *, result_arr, i, vecs) {
            assert(vecs->size() == 2);
            vecs->push_back((*vecs)[0]);
            vecs->push_back((*vecs)[1]);
         }
         continue;
      }

      if (!strncmp(line_str, "HEI", 3))
      {
         mode = 2;
         continue;
      }
      
      if (!strncmp(line_str, "FOL", 3))
      {
         assert(mode == 0);
         assert(!paired);
         mode = 3;
         unit_type = 2;
         fm_new_entry = new vector<float> ();
         array_insert_last(vector<float> *, fm_arr, fm_new_entry);
         continue;
      }
      
      if (!strncmp(line_str, "END", 3))
      {
         // make sure there are four elements in each vector<int>
         int i;
         vector<int> *vecs;
         arrayForEachItem(vector<int> *, result_arr, i, vecs) {
            assert(vecs->size() == 4);
         }

         if (array_n(result_arr) > 0)
         {
            array_insert_last(array_t *, return_arr, result_arr);
            result_arr = array_alloc(vector<int> *, 0);
         }

         continue;
      }

      if (mode == 0)
      {
         assert(sscanf(line_str, "%d %d", &x, &y) == 2);

         if ( paired ) {
            assert( paired_new_entry->size() == 2 );
         } else {
            paired_new_entry = new vector<int> ();
            array_insert_last(vector<int> *, result_arr, paired_new_entry);
         }

         paired_new_entry->push_back(x);
         paired_new_entry->push_back(y);
         paired = !paired;
         
      } else if (mode == 1) {

         assert(sscanf(line_str, "%d %d", &x, &y) == 2);
         vector<int> *new_entry;
         new_entry = array_fetch(vector<int> *, result_arr, index++);
         assert(new_entry->size() == 2);
         new_entry->push_back(x);
         new_entry->push_back(y);
         
      } else if (mode == 2) {
         if (array_n(result_arr) > 0) {
            assert(sscanf(line_str, "%f %f", &base, &top));
            vector<float> *new_entry = new vector<float> ();
            new_entry->push_back(base);
            new_entry->push_back(top);
            new_entry->push_back((float)unit_type);
            array_insert_last(vector<float> *, z_arr, new_entry);
         }
      } else if (mode == 3) {

         float x, y, z;
         assert(sscanf(line_str, "%f %f %f", &x, &y, &z) == 3);
         fm_new_entry->push_back(x);
         fm_new_entry->push_back(y);
         fm_new_entry->push_back(z);
      }
   }
   
   fclose(fd);

   return return_arr;
   
}


int taper_corner_point(const vector<int> line_set)
{
   int min_x = image_width,  min_x_i = 0;
   int max_x = 0, max_x_i = 0;
   int min_y = image_height, max_y = 0;

   for (int i = 0; i < line_set.size(); i += 2)
   {
      if (line_set[i] < min_x)
      {
         min_x = line_set[i];
         min_x_i = i;
      }
      if (line_set[i+1] < min_y)
         min_y = line_set[i+1];

      // TO-DO
      // if (line_set[i] > max_x)
   }

   //assert(line_set[min_x_i + 1] <= image_height/2);

   return index(min_x, line_set[min_x_i + 1]);
   
}

/*** test code of the below function -- May be useful later.

      // remove me later
      // test the line
      if (0)
      {
         pixels = pixels_between_2_points_in_order(image_height, image_width, x0, y0, x1, y1);
         int *aaa = new int[image_height * image_width];
         memset(aaa, 0, image_height * image_width * 4);
         for (int i = 0 ; i < pixels->size(); i ++)
            aaa[(*pixels)[i]]  =  1;

         vector<int> *pixels1 = pixels_between_2_points_in_order(image_height, image_width, x1, y1, x0, y0);
         for (int i = 0 ; i < pixels->size(); i ++)
            assert(aaa[(*pixels1)[i]] == 1);
        
      }


********/
////

// Function: taper_travel_the_points
//
// Compute the line boundary based on UNIOUN
//
void taper_travel_the_points(int corner_pts,
                             st_table* pts_st,
                             vector<int> &lines)
{
   // assume there are only two end points for corner_pts
   // find the left side one w.r.t. the horizontal line
   vector<int> *cor_pts_vecs = NULL;
   assert(st_lookup(pts_st, (char *)corner_pts, (char **)&cor_pts_vecs));
   assert(cor_pts_vecs->size() == 6); // 2 set of lines, each has 3 elements. 0, index of polygon.
   assert((*cor_pts_vecs)[0] == (*cor_pts_vecs)[3]);
   
   int x0 = x_axis(corner_pts);
   int y0 = y_axis(corner_pts);
   
   int x1 = x0 - 10; // assume x0 != 0
   int y1 = y0;

   int tmp_1 = (*cor_pts_vecs)[1] == corner_pts ? (*cor_pts_vecs)[2] : (*cor_pts_vecs)[1];
   int tmp_2 = (*cor_pts_vecs)[4] == corner_pts ? (*cor_pts_vecs)[5] : (*cor_pts_vecs)[4];
//   assert(tmp_1 != tmp_2);

   double a1 = angle_arc(x1, y1, x0, y0, x_axis(tmp_1), y_axis(tmp_1), -1);
   double a2 = angle_arc(x1, y1, x0, y0, x_axis(tmp_2), y_axis(tmp_2), -1);

   if (a1 <= a2)
   {
      x1 = x_axis(tmp_1);
      y1 = y_axis(tmp_1);
   } else {
      x1 = x_axis(tmp_2);
      y1 = y_axis(tmp_2);
   }

   lines.push_back(x0);
   lines.push_back(y0);

   // This is the starting point of the big loop
   int cur_pts = corner_pts;                      /* current point, index of [x0, y0] */
   int cur_poly_index = (*cor_pts_vecs)[0];       /* current polygon index */
   int intersect_the_other_end_pts = corner_pts;  /* the other end point of the intersected middle point */
   int inter_x = x0, inter_y = y0;                /* [x, y] of the above point */
   int found_new_poly = false;                    /* whehter a new polygon is switched */
   int pre_end1 = cur_pts;                        /* previous end points of the line */
   int pre_end2 = index(x1, y1);                  /* previous end points of the line */
                                                  /* [x1, y1] the second end point of the line*/
   while (1)
   {
      vector<int> *pixels;

      //printf("P0: [%d, %d], P1: [%d, %d]\n", inter_x, inter_y, x1, y1);
      // get the pixels between 2 points in strictly order (p0 -> p1)
      if (found_new_poly)
      {
         // we have to compute pixels from end points, otherwise it will give us different set of pixels
         // this will cause lookup errors.
         vector<int> *pixels_total = pixels_between_2_points_in_order(image_height, image_width, inter_x, inter_y, x1, y1);
         pixels = new vector<int> ();
         for (int i = 0; i < pixels_total->size(); i++)
         {
            // the motonic increasing character of line makes sure this is valid.
            int min_x = min(x0, x1);
            int max_x = max(x0, x1);
            int min_y = min(y0, y1);
            int max_y = max(y0, y1);
            if (x_axis((*pixels_total)[i]) >= min_x
                && x_axis((*pixels_total)[i]) <= max_x
                && y_axis((*pixels_total)[i]) >= min_y
                && y_axis((*pixels_total)[i]) <= max_y )
            {
               assert(st_lookup(pts_st, (char *)(*pixels_total)[i], (char **)NULL));
               pixels->push_back((*pixels_total)[i]);
            }
         }
         delete pixels_total;
      }
      else 
         pixels = pixels_between_2_points_in_order(image_height, image_width, x0, y0, x1, y1);

      found_new_poly = false;
      // check each point of the pixels.
      for (int i = 0 ; i < pixels->size(); i ++)
      {
         if ((*pixels)[i] == cur_pts)
            continue;

         vector<int> *reg_vecs = NULL;
         assert(st_lookup(pts_st, (char *)(*pixels)[i], (char **)&reg_vecs));

         // 3 tuple: 1, the index of the polygon
         //          2, 3 the end points of the line goes through this point
         assert(reg_vecs->size() >= 3);

         if (reg_vecs->size() ==  3)
         {
            assert((*reg_vecs)[0] == cur_poly_index); // make sure this pixel is lit by this line
            continue;
         }

         // this is a intersection point
         x0 = x_axis((*pixels)[i]);
         y0 = y_axis((*pixels)[i]);

         // set the angle base side.
         int angle_x = x_axis(cur_pts);
         int angle_y = y_axis(cur_pts);
         double min_angle = 180; // this value is for a line
         int new_cur_poly_index;
         for (int pts_i = 0 ; pts_i < reg_vecs->size(); pts_i += 3)
         {
            // my own polygon, ignore
            if ((*reg_vecs)[pts_i] == cur_poly_index)
               continue;

            // sanity check
            if (((*reg_vecs)[pts_i + 1] == pre_end1 || (*reg_vecs)[pts_i + 1] == pre_end2)
                &&((*reg_vecs)[pts_i + 2] == pre_end1 || (*reg_vecs)[pts_i + 2] == pre_end2))
               continue;

            double a1 = angle_arc(angle_x, angle_y, x0, y0, x_axis((*reg_vecs)[pts_i + 1]), y_axis((*reg_vecs)[pts_i + 1]), -1);
            double a2 = angle_arc(angle_x, angle_y, x0, y0, x_axis((*reg_vecs)[pts_i + 2]), y_axis((*reg_vecs)[pts_i + 2]), -1);

            // we have to go through all end points, in case this point is passed thru by multiple lines.
            if ((a1 > 1 && a1 < min_angle)) {
               min_angle = a1;
               pre_end1 = index(inter_x, inter_y);
               pre_end2 = index(x1, y1);
               x1 = x_axis((*reg_vecs)[pts_i + 1]);
               y1 = y_axis((*reg_vecs)[pts_i + 1]);
               cur_pts = index(x0, y0);
               new_cur_poly_index = (*reg_vecs)[pts_i];
               found_new_poly = true;
               intersect_the_other_end_pts = (*reg_vecs)[pts_i + 2];
               inter_x = x_axis((*reg_vecs)[pts_i + 2]);
               inter_y = y_axis((*reg_vecs)[pts_i + 2]);
            }

            if ((a2 > 1 && a2 < min_angle)) {
               min_angle = a2;
               pre_end1 = index(inter_x, inter_y);
               pre_end2 = index(x1, y1);
               x1 = x_axis((*reg_vecs)[pts_i + 2]);
               y1 = y_axis((*reg_vecs)[pts_i + 2]);
               cur_pts = index(x0, y0);
               new_cur_poly_index = (*reg_vecs)[pts_i];
               found_new_poly = true;
               intersect_the_other_end_pts = (*reg_vecs)[pts_i + 1];
               inter_x = x_axis((*reg_vecs)[pts_i + 1]);
               inter_y = y_axis((*reg_vecs)[pts_i + 1]);
            }
         }

         if (found_new_poly)
         {
            cur_poly_index = new_cur_poly_index;
            lines.push_back(x0);
            lines.push_back(y0);
            lines.push_back(x0);
            lines.push_back(y0);
            break;
         }
      }

      if (found_new_poly == false)
      {
         // find the end point, exit the big loop
         if (index(x1, y1 ) == corner_pts)
         {
            lines.push_back(x1);
            lines.push_back(y1);
            break;
         }

         // update the vars
         assert(st_lookup(pts_st, (char *)index(x1, y1), (char **)&cor_pts_vecs));
         assert(cor_pts_vecs->size() >= 6); // 2 set of lines, each has 3 elements. 0, index of polygon.

         pre_end1 = index(inter_x, inter_y);
         pre_end2 = index(x1, y1);
         if (cor_pts_vecs->size() == 6)
         {
            assert((*cor_pts_vecs)[0] == (*cor_pts_vecs)[3]);
            assert((*cor_pts_vecs)[0] == cur_poly_index);

            cur_pts = index(x1, y1);
            int tmp_1 = (*cor_pts_vecs)[1] == cur_pts ? (*cor_pts_vecs)[2] : (*cor_pts_vecs)[1];
            int tmp_2 = (*cor_pts_vecs)[4] == cur_pts ? (*cor_pts_vecs)[5] : (*cor_pts_vecs)[4];
            //assert(tmp_1 != tmp_2);

            assert(intersect_the_other_end_pts == tmp_1 || intersect_the_other_end_pts == tmp_2);
            int next_pts = intersect_the_other_end_pts == tmp_1 ? tmp_2 : tmp_1;
            
            inter_x = x0 = x1;
            inter_y = y0 = y1;
            x1 = x_axis(next_pts);
            y1 = y_axis(next_pts);
            intersect_the_other_end_pts = index(x0, y0);
         } else {

            // find the smallest angle among all lines
            cur_pts = index(x1, y1);
            double min_angle = 360;
            int min_index = -1;
            for (int i = 0 ; i < cor_pts_vecs->size() ; i += 3)
            {
               // this point may not be a end point for a line, but is gone through
               // by a line, so it may be the case that neither of comp1 and comp2 is
               // equal to index(x1, y1)
               int comp1 = (*cor_pts_vecs)[i+1];
               int comp2 = (*cor_pts_vecs)[i+2];

               if ((comp1 == index(inter_x, inter_y) || comp1 == cur_pts)
                   && (comp2 == index(inter_x, inter_y) || comp2 == cur_pts ))
                  continue;

               double new_a;
               if (comp1 == cur_pts || comp2 == cur_pts)
               {
                  int comp = comp1 == cur_pts ? comp2 : comp1;
                  new_a = angle_arc(inter_x, inter_y, x1, y1, x_axis(comp), y_axis(comp), -1);
                  
               } else {
               
                  double a1 = angle_arc(inter_x, inter_y, x1, y1, x_axis(comp1), y_axis(comp1), -1);
                  double a2 = angle_arc(inter_x, inter_y, x1, y1, x_axis(comp2), y_axis(comp2), -1);
                  new_a = min(a1, a2);
               }

               if (new_a < min_angle)
               {
                  min_index = i;
                  min_angle = new_a;
               }
            }

            // update the status
            int p1 = (*cor_pts_vecs)[min_index+1];
            int p2 = (*cor_pts_vecs)[min_index+2];

            int order_p1, order_p2; // line order_p1 -> order_p2
            if (p1 == cur_pts || p2 == cur_pts)
            {
               order_p1 = cur_pts == p1 ? p1 : p2;
               order_p2 = cur_pts == p2 ? p1 : p2;
            } else
            {
               double a1 = angle_arc(inter_x, inter_y, x1, y1, x_axis(p1), y_axis(p1), -1);
               double a2 = angle_arc(inter_x, inter_y, x1, y1, x_axis(p2), y_axis(p2), -1);
               order_p1 = a1 < a2 ? p2 : p1;
               order_p2 = a1 < a2 ? p1 : p2;
               assert(min(a1, a2) > 0);
               found_new_poly = true;
            }

            cur_poly_index = (*cor_pts_vecs)[min_index];
            cur_pts = index(x1, y1);
            x0 = x1;
            y0 = y1;
            inter_x = x_axis(order_p1);
            inter_y = y_axis(order_p1);
            x1 = x_axis(order_p2);
            y1 = y_axis(order_p2);
            intersect_the_other_end_pts = index(inter_x, inter_y);
               
         } // end of the if/else

         lines.push_back(x0);
         lines.push_back(y0);
         lines.push_back(x0);
         lines.push_back(y0);
      }

   }
}

// Function: taper_mark_points_on_image
//
// mark the points for later use
//
void taper_mark_points_on_image(const vector<int> &line_set,
                                int bnd_index,
                                int cur_poly_index,
                                st_table *pts_st)
{
   // mark the points based on the line_set;
   // get the pixels between 2 points in strictly order (p0 -> p1)

   char *aaa = new char[image_height * image_width];
   int x0, y0, x1, y1;
   for (int i = bnd_index; i < line_set.size(); i += 4)
   {
      memset(aaa, 0, image_height * image_width);

      x0 = line_set[i];
      y0 = line_set[i+1];
      x1 = line_set[i+2];
      y1 = line_set[i+3];

      if (x0 == x1 && y0 == y1)
         continue;
      
      vector<int> *pixels = pixels_between_2_points_in_order(image_height, image_width, x0, y0, x1, y1);

      for (int pixel_i = 0; pixel_i < pixels->size(); pixel_i ++)
      {
         aaa[(*pixels)[pixel_i]] = 1;
         // Make sure we don't have duplicate information.
         if (pixel_i > 0 && (*pixels)[pixel_i] == (*pixels)[pixel_i - 1])
            continue;

         vector<int> *pixel_vecs = NULL;
         if (!st_lookup(pts_st, (char *)(*pixels)[pixel_i], (char **)&pixel_vecs))
         {
            pixel_vecs = new vector<int> ();
            st_insert(pts_st, (char *)(*pixels)[pixel_i], (char *)pixel_vecs);
         }

         pixel_vecs->push_back(cur_poly_index);
         pixel_vecs->push_back(index(x0, y0));
         pixel_vecs->push_back(index(x1, y1));
      }

      // BUG FIX:
      // because the set of pixels for a line, say from p0->p1, is not identical to the set of pixels
      // from p1 -> p0. So we have to draw twice for a line. The reason is later on, the direction of
      // the line drawing is lost, namely we don't know we did p0->p1, or p1->p0. so as a compromise
      // solution, we could draw twice.

      /* // The above problem has been solved by computing pixels from fixed order, and reversed if needed.
         // see the function pixels_between_2_points_in_order() for details.
      delete pixels;
      pixels = pixels_between_2_points_in_order(image_height, image_width, x1, y1, x0, y0);
      for (int pixel_i = 0; pixel_i < pixels->size(); pixel_i ++)
      {
         if (aaa[(*pixels)[pixel_i]]) continue;

         vector<int> *pixel_vecs = NULL;
         if (!st_lookup(pts_st, (char *)(*pixels)[pixel_i], (char **)&pixel_vecs))
         {
            pixel_vecs = new vector<int> ();
            st_insert(pts_st, (char *)(*pixels)[pixel_i], (char *)pixel_vecs);
         }

         pixel_vecs->push_back(cur_poly_index);
         pixel_vecs->push_back(index(x0, y0));
         pixel_vecs->push_back(index(x1, y1));
         
      }

      */
      
      
   }

   delete []aaa;
   
}

#if 0
// Function: load_lines_from_end_points
//
// Compute the line coords on the fly
// Comments: load tapered or extruded layout with overlapping between tapered structure
//           and extruded strcuture.
//
// ASSUMPTION:
//  *. when drawing a line (P0, P1), (P0, P1) and (P1, P0) will mark the same points.
//
void load_lines_from_end_points____WRONG(array_t *end_points_arr,
                                vector<int> &line_set,
                                int cur_frame,
                                int num_frame,
                                array_t *z_arr)
{

   double ratio1 = (double)cur_frame/(double)num_frame;

   st_table *pts_st = st_init_table(st_ptrcmp, st_ptrhash);
   // step 1: preprocess the image points.
   int k, bnd_index = 0;
   array_t *end_points;
   arrayForEachItem(array_t *, end_points_arr, k, end_points) {

      if (array_n(end_points) == 0)
         continue;
      
      // check the height of the polygon
      vector<float> *z_info = array_fetch(vector<float> *, z_arr, k);
      assert(z_info->size() == 2);
      float base = (*z_info)[0];
      float top =  (*z_info)[1];
      if (ratio1 < base || ratio1 > top) // ignore this polygon if not in this region.
         continue;

      // if eligible, load the lines of the polygon
      double ratio = (ratio1 - base)/(top - base);
      int i;
      vector<int> *end_pts;
      arrayForEachItem(vector<int> *, end_points, i, end_pts) {
         assert(end_pts->size() == 4);
         int x0 = (*end_pts)[0];
         int y0 = (*end_pts)[1];
         int x1 = (*end_pts)[2];
         int y1 = (*end_pts)[3];
         int x  = (int)(x0 + ratio*(x1 - x0) + .5);
         int y  = (int)(y0 + ratio*(y1 - y0) + .5);

         line_set.push_back(x);
         line_set.push_back(y);

         if (i != 0)
         {
            line_set.push_back(x);
            line_set.push_back(y);
         }
      }

      // update the boundary index.
      bnd_index = line_set.size();

      // push back the last point
      line_set.push_back(line_set[bnd_index - 2]);
      line_set.push_back(line_set[bnd_index - 1]);

      // mark the points
      taper_mark_points_on_image(line_set, bnd_index, k, pts_st);

   }

   if (1)
   {
      char fn1[100];
      char *pad_str = digit_string(3, cur_frame);
      sprintf(fn1, "load_line1_%s.png", pad_str);
      write_lines_to_bw_image(fn1, line_set, image_height, image_width);
      free(pad_str);
   }

   // step 2: find an corner point as a starting point
   int corner_pts = taper_corner_point(line_set);
   printf("The frame %d is starting at point [%d, %d]\n", cur_frame, x_axis(corner_pts), y_axis(corner_pts));
      
   // step 3: travel the lines.
   line_set.clear();
   taper_travel_the_points(corner_pts, pts_st, line_set);

   // final image
   if (1)
   {
      char fn[100];
      char *pad_str = digit_string(3, cur_frame);
      sprintf(fn, "load_line_%s.png", pad_str);
      write_lines_to_bw_image(fn, line_set, image_height, image_width);
      free(pad_str);
   }
   //exit(0);
}

#else

// Function: load_lines_from_end_points
//
// Compute the line coords on the fly
// Comments: load tapered or extruded layout without any overlapping
//
void load_lines_from_end_points(array_t *end_points_arr,
                                vector<int> &line_set,
                                int cur_frame,
                                int num_frame,
                                array_t *z_arr)
{

   double ratio1 = (double)cur_frame/(double)num_frame;


   int k;
   array_t *end_points;
   int bnd_index = 0;
   arrayForEachItem(array_t *, end_points_arr, k, end_points) {

      // check the height of the polygon
      vector<float> *z_info = array_fetch(vector<float> *, z_arr, k);
      assert(z_info->size() >= 2);
      float base = (*z_info)[0];
      float top =  (*z_info)[1];
      if (ratio1 < base || ratio1 > top) // ignore this polygon if not in this region.
         continue;

      // if eligible, load the lines of the polygon
      double ratio = (ratio1 - base)/(top - base);
      int i;
      vector<int> *end_pts;
      arrayForEachItem(vector<int> *, end_points, i, end_pts) {

         assert(end_pts->size() == 4);
         int x0 = (*end_pts)[0];
         int y0 = (*end_pts)[1];
         int x1 = (*end_pts)[2];
         int y1 = (*end_pts)[3];
         int x  = (int)(x0 + ratio*(x1 - x0) + .5);
         int y  = (int)(y0 + ratio*(y1 - y0) + .5);

         line_set.push_back(x);
         line_set.push_back(y);

         if (i != 0)
         {
            line_set.push_back(x);
            line_set.push_back(y);
         }
      }

      bnd_index = line_set.size();
      line_set.push_back(line_set[bnd_index-2]);
      line_set.push_back(line_set[bnd_index-1]);
 
   }

   if (0) {
      char fn[1000];
      char *pad_str = digit_string(3, cur_frame);
      sprintf(fn, "load_line_%s.png", pad_str);
      write_lines_to_bw_image(fn, line_set, image_height, image_width);
   }
   
   //exit(0);
}

#endif

// Function: compute_error_diff_between_two_im
//
// Compute the error between two images, called by <compute_error_for_IR>
//
void compute_error_diff_between_two_im(BYTE **cur_im, vector<int> &line_set, int layer, char *path_dir, int frame_num)
{
   char *pre_str = "result/error_comp/debug_errors/dilation_debug";
   int T_len = 3;
   int T_w = 20;

   assert(line_set.size() % 4 == 0);

   //BYTE **mark_im = copy_image(cur_im, image_height, image_width);
   BYTE **dila_im = new_image(image_height, image_width);

   vector<vector<int> *> *all_dila = new vector<vector<int> *>;
   vector<int> line_length;

   // initialization step
   {
      // processing for each line segment
      for (int i = 0; i < line_set.size(); i += 4 )
      {
         // obtain the current points
         vector<int> *newDilaPixels = new vector<int>;
         vector<int> *linePixels = pixels_between_2_points(image_height, image_width,
                                                          line_set[i],
                                                          line_set[i+1],
                                                          line_set[i+2],
                                                          line_set[i+3]);
         for (int k = 0 ; k < linePixels->size(); k ++) {
            int ind_pts = linePixels->at(k);
            if ( dila_im[0][ind_pts] == WHITE ) {
               dila_im[0][ind_pts] = BLACK;
               // Comment:
               // Whether commenting the following condition out or not determines two different
               // error measurement. Without comment, we treat the exactly matched point with error 0.
               // However, they may lead to a case where very low displaccement ends up large iteration error.
               //if ( cur_im[0][ind_pts] == WHITE )
                  newDilaPixels->push_back(ind_pts);
            }
         }

         all_dila->push_back(newDilaPixels);
         line_length.push_back(linePixels->size());

         delete linePixels;
      }
   }

   // iteration until reaching T_w
   vector<int> accm_errors(all_dila->size());
   for (int i = 0; i < accm_errors.size(); i ++)
      accm_errors[i] = 0;
   
   int iteration = 0;
   int IMAGE_MAX_INDEX = image_width * image_height;
   while ( iteration < T_w )
   {
      char fn[1000];
      char *ds = digit_string(2, iteration);
      sprintf(fn, "%s_%s.png", pre_str, ds);
      free(ds);
      // printf("Processing %s...\n", fn);
      
      // compute the accumulate errors for each line segment
      for ( int i = 0; i < all_dila->size(); i ++ )
      {
         vector<int> *curDilaPixels = all_dila->at(i);
         if (curDilaPixels->size() == 0)
            continue;

         vector<int> *newDilaPixels = new vector<int>;
         for ( int k = 0; k < curDilaPixels->size(); k ++ )
         {
            int ind_pts;
            ind_pts = curDilaPixels->at(k) - image_width - 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) - image_width; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) - image_width + 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) - 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) + 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) + image_width - 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) + image_width; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

            ind_pts = curDilaPixels->at(k) + image_width + 1; // check 8-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               newDilaPixels->push_back(ind_pts);
               if ( cur_im[0][ind_pts] == BLACK ) {
                  accm_errors[i] += iteration;
               }
            }

         }

         delete curDilaPixels;
         all_dila->at(i) = newDilaPixels;
      }

      //Save2File(fn, dila_im, NULL, image_width, image_height, 0, NULL);

      iteration ++;
   }

   // write out the error score
   assert(line_length.size() == accm_errors.size());
   assert(line_length.size() == line_set.size() / 4);

   static float max_error = 0.0;
   static float total_error = 0.0;
   static int total_num_err = 0;
   char err_fn[1000];
   sprintf(err_fn, "%s/../error_comp_result.txt", path_dir);
   FILE *ef = fopen(err_fn, "a");
   assert(ef);
   fprintf(ef, "Layer %d\n", layer);
   for (int i = 0 ; i < line_length.size(); i ++)
   {
      if (line_length[i] < T_len)
         continue;

      // print the start and end points
      fprintf(ef, "%d %d ", line_set[4*i  ], line_set[4*i+1]);
      fprintf(ef, "%d %d ", line_set[4*i+2], line_set[4*i+3]);
      float err_res = accm_errors[i] / (float) line_length[i];
      fprintf(ef, "%.2f\n", err_res);
      if ( err_res > max_error )
         max_error = err_res;
      total_error += err_res;
      total_num_err ++;
   }

   fclose(ef);

   if (layer == frame_num - 1) {
      printf ( "MAX Error: %.4f\n", max_error);
      printf ( "Total # of lines: %d\n", total_num_err);
      printf ( "Average Error: %.4f\n", total_error/total_num_err);
   }

   // memory free
   for (int i = 0; i < all_dila->size(); i ++)
      delete all_dila->at(i);
   delete all_dila;

   delete dila_im;
}

// Function: compute_error_load_3D_data_ptx
//
// Load the valid 3D point data into memeory for mapping
// Refer to function <load_point_cloud_as_images>
void compute_error_load_3D_data_ptx(char *fn, vector<double> &data, int type)
{
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }
   // direction: 0 - Y axis (bottom up), 1 - Z axis (face to face), 2 - X axis (left to right)
   int direction = 0;


   double BOX_MIN_X;
   double BOX_MAX_X;
   double BOX_MIN_Y;
   double BOX_MAX_Y;
   double BOX_MIN_Z;
   double BOX_MAX_Z;
   assign_3D_box_Y_dir(BOX_MIN_X,
                       BOX_MAX_X,
                       BOX_MIN_Y,
                       BOX_MAX_Y,
                       BOX_MIN_Z,
                       BOX_MAX_Z,
                       1);
   

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   printf("loading data from file...\n");
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         if (x < BOX_MIN_X || x > BOX_MAX_X ||
             y < BOX_MIN_Y || y > BOX_MAX_Y ||
             z < BOX_MIN_Z || z > BOX_MAX_Z)
            continue;

         // rule out noise for Y axis (direction == 0)
         // if (direction == 0 && BOX_MIN_Y == 0.0 && BOX_MAX_Y == 44.0 && !inside_3D_container_for_dir_0(x, y, z))
         //   continue;

         // This is to determine logic X, Y, Z
         data.push_back(y);
         data.push_back(x);
         data.push_back(z);
      }
   }

   fclose(fid);

}

// Function: compute_error_load_3D_data_bpa
//
// Load the valid 3D point data into memeory for mapping
// Refer to function <load_point_cloud_as_images>
void compute_error_load_3D_data_bpa(char *fn, vector<double> &data, int type)
{
   FILE *fid = fopen(fn, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", fn);
      return;
   }
   // direction: 0 - Y axis (bottom up), 1 - Z axis (face to face), 2 - X axis (left to right)
   int direction = 0;

   double BOX_MIN_X;
   double BOX_MAX_X;
   double BOX_MIN_Y;
   double BOX_MAX_Y;
   double BOX_MIN_Z;
   double BOX_MAX_Z;
   assign_3D_box_Y_dir(BOX_MIN_X,
                       BOX_MAX_X,
                       BOX_MIN_Y,
                       BOX_MAX_Y,
                       BOX_MIN_Z,
                       BOX_MAX_Z);
   

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   printf("loading data from file...\n");
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", z_s, y_s, x_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         if (x < BOX_MIN_X || x > BOX_MAX_X ||
             y < BOX_MIN_Y || y > BOX_MAX_Y ||
             z < BOX_MIN_Z || z > BOX_MAX_Z)
            continue;

         // rule out noise for Y axis (direction == 0)
         if (direction == 0 && !inside_3D_container_for_dir_0(x, y, z))
            continue;

         data.push_back(y); // push y first, so that index don't need to be add by 1 in the following.
         data.push_back(x);
         data.push_back(z);
      }
   }

   fclose(fid);

}


// Function: compute_error_load_3D_data
//
// Load the valid 3D point data into memeory for mapping
// Refer to function <load_point_cloud_as_images>
void compute_error_load_3D_data(char *fn, vector<double> &data, int type = 0)
{

   // based on type, load different dataset
   if ( type == 0 ) {
      compute_error_load_3D_data_bpa(fn, data, type);
   }
   else if ( type == 1 ) {
      compute_error_load_3D_data_ptx(fn, data, type);
   }
      
}

// Function: compute_error_obtain_LUT_for_each_height
//
// Compute the LUT based on the ordered boundaries
// Input:  ordered boundaries represented with line segments (4 points)
// Output: LUT array, each height corresponds to an element,
//         size: 1024x392,
//         mapping: integer (index(x,y)) -> vector<int> of [PIXEL, DISTANCE, LINE END POINTS(2)] (4 elements)
void compute_error_obtain_LUT_for_each_height(array_t *arr_height, array_t *arr_boundaries, array_t *arr_LUT, int start, int end, int THRESH_ERROR = 40)
{
   int k;
   vector<int> *line_set;
   arrayForEachItem(vector<int> *, arr_boundaries, k, line_set) {

      // rule out layers which are not in the range
      if ( k > end || k < start )
         continue;
   
      // for each boundary, let's compute the LUT based on 4-connect kernel
      st_table *st_lut = st_init_table(st_ptrcmp, st_ptrhash);
      array_insert_last(st_table *, arr_LUT, st_lut);

      assert(line_set->size() % 4 == 0);
      BYTE **dila_im = new_image(image_height, image_width);

      // initialization step
      {
         // processing for each line segment
         for (int i = 0; i < line_set->size(); i += 4 )
         {
            // obtain the current points
            vector<int> *linePixels = pixels_between_2_points(image_height, image_width,
                                                              line_set->at(i),
                                                              line_set->at(i+1),
                                                              line_set->at(i+2),
                                                              line_set->at(i+3));

            for (int j = 0 ; j < linePixels->size(); j++)
            {
               int ind_pts = linePixels->at(j);
               if ( dila_im[0][ind_pts] == WHITE ) {
                  dila_im[0][ind_pts] = BLACK;
                  
                  vector<int> *status = new vector<int>;
                  status->push_back(ind_pts);
                  status->push_back(0);
                  status->push_back(index(line_set->at(i  ), line_set->at(i+1)));
                  status->push_back(index(line_set->at(i+2), line_set->at(i+3)));

                  st_insert(st_lut, (char *)ind_pts, (char *)status);
               }
            }

            delete linePixels;
         }
      }

      // do the dilation based on 4-connect components
      // two extra st_table is neeed:
      //    1. st_iteratoin - store the new points and for next iteration points
      //    2. st_backup    - store the next iteration points

      st_table *st_backup = st_lut;
      int iteration = 0;
      int IMAGE_MAX_INDEX = image_width * image_height;
      while ( iteration < THRESH_ERROR ) {
         iteration ++;

         st_table *st_iteration = st_init_table(st_ptrcmp, st_ptrhash);

         int *cur_point1;
         st_generator *gen;
         vector<int> *status;
         st_foreach_item(st_backup, gen, (char **) &cur_point1, (char **)&status)
         {
            int ind_pts;
            int cur_point = (int) cur_point1;
            ind_pts = cur_point - image_width; // check 4-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               vector<int> *new_st = new vector<int>(*status);
               new_st->at(1) = iteration;  // 0: a point on edge, 1: distance, 2,3: the end points of this edge
               st_insert(st_iteration, (char *)ind_pts, (char *)new_st);
               
            }
            
            ind_pts = cur_point + image_width; // check 4-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               vector<int> *new_st = new vector<int>(*status);
               new_st->at(1) = iteration;  // 0: a point on edge, 1: distance, 2,3: the end points of this edge
               st_insert(st_iteration, (char *)ind_pts, (char *)new_st);
               
            }
            
            ind_pts = cur_point - 1; // check 4-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               vector<int> *new_st = new vector<int>(*status);
               new_st->at(1) = iteration; // 0: a point on edge, 1: distance, 2,3: the end points of this edge
               st_insert(st_iteration, (char *)ind_pts, (char *)new_st);
               
            }
            
            ind_pts = cur_point + 1; // check 4-connected points
            if ( ind_pts >= 0 && ind_pts < IMAGE_MAX_INDEX && dila_im[0][ind_pts] == WHITE)
            {
               dila_im[0][ind_pts] = BLACK;
               vector<int> *new_st = new vector<int>(*status);
               new_st->at(1) = iteration; // 0: a point on edge, 1: distance, 2,3: the end points of this edge
               st_insert(st_iteration, (char *)ind_pts, (char *)new_st);
               
            }
         }

         // we only need to dilate the new dilated points; added the new points to LUT.
         if ( iteration > 1) // do NOT free st_lut where ( iteration == 1 )
            st_free_table(st_backup);
         
         st_backup = st_iteration;
         st_foreach_item(st_iteration, gen, (char **)&cur_point1, (char **)&status) {
            assert ( !st_lookup(st_lut, (char *)cur_point1, (char **)NULL) );
            st_insert(st_lut, (char *)cur_point1, (char *)status);
         }
      }  //end of while

      free_image(dila_im);
      
   } // end of each height.
}


// Function: compute_error_order_boundaries
//
// Compute the ordered boundaries based on height
// Input:  non-ordered end_points with point-to-point connection.
// Output: arr_height, arr_boundaries, for each height interval, an line segments array is computed.
// Assumption: only extrueded whole structure exists!, no tapered, segmented units for now.
void compute_error_order_boundaries(array_t *end_points, array_t *z_arr, array_t *arr_height, array_t *arr_boundaries)
{
   // let do extrueded unit only, z_arr(2) --> 1: tapered, 0: extruded.
   
   // the order algorithms: go througth the array with two vars, prev_min, cur_min.
   // prev_min is the minumun value found already.
   // cur_min is to be determined. Until cur_min == prev_min

   float THRESH_HEIGHT = 1.1;     //0.68;       // 1.1
   float prev_min = -1.0;
   float cur_min = THRESH_HEIGHT;    // MAX z_arr is 1.0
   float cur_min_high_end; // high end of this interval
   vector<float> *z_val;
   int k;
   while ( true ) {
      arrayForEachItem(vector<float> *, z_arr, k, z_val) {
         if (z_val->at(2) < 1.0 &&   // 1.0 tapered, 0.0 extruede.
             z_val->at(0) > prev_min && z_val->at(0) < cur_min)  // MAX z_arr is 1.0
         {
            cur_min = z_val->at(0);
            cur_min_high_end = z_val->at(1);
         }
      }
      prev_min = cur_min;

      if ( cur_min == THRESH_HEIGHT )  // no new heighs anymore
         break;

      // found a minumun one
      vector<float> *v_height = new vector<float>;
      v_height->push_back(cur_min);
      v_height->push_back(cur_min_high_end);
      array_insert_last(vector<float> *, arr_height, v_height);

      vector<int> *line_set = new vector<int>;
      array_insert_last(vector<int> *, arr_boundaries, line_set);

      cur_min = THRESH_HEIGHT;

   }

   {  // re-arrange the end_points.
      array_t *point_arr; // = array_alloc(vector<int> *, 0);
      assert( array_n(end_points) == array_n(z_arr) );
      arrayForEachItem(array_t *, end_points, k, point_arr ) {
         z_val = array_fetch(vector<float> *, z_arr, k);
         if (z_val->at(2) > 0.0 )
            continue;

         // find the index of the boundaries.
         int j = -1;
         vector<float> *v_height;
         arrayForEachItem(vector<float> *, arr_height, j, v_height) {
            if ( z_val->at(0) == z_val->at(1) )  // e.g. 685 slice.
               continue;
            
            if ( z_val->at(0) == v_height->at(0) ) {
               if ( z_val->at(1) != v_height->at(1) ) {
                  printf("Unmatched interval: [%f - %f] v.s. [%f - %f]\n", z_val->at(0), z_val->at(1), v_height->at(0), v_height->at(1));
               }
               assert(z_val->at(1) == v_height->at(1));   // Make sure the assumption is hold, ie, only consider whole extruded unit for now.
               break;
            }
         }

         // temp solution
         if ( j == array_n(arr_height) )
            continue;
         
         assert( j < array_n(arr_height));  // j is the index

         // construct line_set from point_arr;
         if ( array_n(point_arr) <= 1 ) //otherwise, let's ignore it. a single point
            continue;
         
         int i;
         vector<int> *point_vec;
         vector<int> *line_set_seg = new vector<int>;
         arrayForEachItem(vector<int> *, point_arr, i, point_vec) {
            if ( i == 0 ) {
               line_set_seg->push_back(point_vec->at(0));
               line_set_seg->push_back(point_vec->at(1));
            } else if ( i < array_n( point_arr ) - 1) {
               line_set_seg->push_back(point_vec->at(0));
               line_set_seg->push_back(point_vec->at(1));
               line_set_seg->push_back(point_vec->at(0));
               line_set_seg->push_back(point_vec->at(1));
            } else {
               assert ( i == array_n(point_arr) - 1);  // the last point
               line_set_seg->push_back(point_vec->at(0));
               line_set_seg->push_back(point_vec->at(1));
            }
         }

         // concatenate this line_set_seg into line_set
         vector<int> *line_set = array_fetch(vector<int> *, arr_boundaries, j);
         for (int index = 0; index < line_set_seg->size(); index ++) {
            line_set->push_back(line_set_seg->at(index));
         }

         delete line_set_seg;

      }
   }

   { // test
      
      arrayForEachItem(vector<float> *, arr_height, k, z_val) {
         printf("HEIGHT: [%f -> %f]: LINE SEGMENT #: %d\n", z_val->at(0), z_val->at(1), (array_fetch(vector<int> *, arr_boundaries, k))->size()/4);
      }
      printf("Total %d layers!\n", array_n(arr_height));
   }

 }

// Function: compute_error_texture_mapping
//
// Compute the texture mapping
// Input:  a vector of 3D data point cloud data
// Output: corresponding error texture images
// Algorithm: based on Y axis of data, find the corresponding arr_height and therefore corresponding LUT.
//            based on the X, Z value, look up the point and structure for mapping.
void compute_error_texture_mapping(vector<double> &data, array_t *err_LUT,
                                   array_t *arr_height, array_t *arr_boundaries,
                                   int start, int end, vector<double> &paper_stat, int dataset_type)
{
   int THRESH_ERROR = 40;  // the same threshold as LUT computation.
      
   // create all image patches for this model
   double x_min, y_min, z_min;
   double x_max, y_max, z_max;

   assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, dataset_type);

   // create all image patches for this model
   double z_scaler = (double)image_width / (x_max - x_min);
   double depth_bottom = z_min * z_scaler; // -2.116044 * z_scaler;
   double depth_top    = z_max * z_scaler; // 30.216660 * z_scaler;
   double depth_inter  = depth_top - depth_bottom; 

   int    sample_num   = 1000;
   float  error_max    = 15.0;  // maximum error bound

   st_table *st_name2img = st_init_table(strcmp, st_strhash);

   int i;
   vector<int> *line_set;
   vector<float> *v_height;
   arrayForEachItem(vector<int> *, arr_boundaries, i, line_set) {

      // rule out layer which are not in the range
      if ( i > end || i < start )
         continue;
      
      assert(line_set->size() % 4 == 0);
      v_height = array_fetch(vector<float> *, arr_height, i);
      char img_fn[1000];

      int img_w;
      int img_h = (int) abs(depth_inter * (v_height->at(1) - v_height->at(0)));
      img_h = img_h > 0 ? img_h : 1;
      for (int j = 0; j < line_set->size(); j += 4)
      {
         sprintf(img_fn, "texture_%.3f_%.3f_%d-%d_%d-%d_image.png",
                 v_height->at(0),
                 v_height->at(1),
                 line_set->at(j),
                 line_set->at(j+1),
                 line_set->at(j+2),
                 line_set->at(j+3) );

         img_w = (int)sqrt( (float) (line_set->at(j+2) - line_set->at(j  ))*((line_set->at(j+2) - line_set->at(j))) +
                            (line_set->at(j+3) - line_set->at(j+1))*((line_set->at(j+3) - line_set->at(j+1))));
         assert(img_w >= 1 && img_h >= 1);
         BYTE **im = new_image(img_h, img_w);
         memset(im[0], 255, img_h * img_w);
         char *copy_fn = strdup(img_fn);
         vector<char *> *im_info = new vector<char *>;
         im_info->push_back((char *)img_w);
         im_info->push_back((char *)img_h);
         im_info->push_back((char *)im);
         st_insert(st_name2img, (char *)copy_fn, (char *)im_info);
      }
   }
   
   // based on Y axis of data, find the corresponding arr_height and therefore corresponding LUT.
   // based on the X, Z value, look up the point and structure for mapping.
   // data: y, x, z

   int count = 0;

#ifdef MSVC_60
   long paper_local_stat = 0;
   long paper_local_num = 0;
#else
   long long paper_local_stat = 0;
   long long paper_local_num = 0;
#endif 
   assert( data.size() % 3 == 0);
   for ( i = 0; i < data.size(); i += 3 ) {

      double ratio = (data[i] - y_min) / (y_max - y_min);

      // find the right LUT
      int k;
      vector<float> *v_height;
      arrayForEachItem(vector<float> *, arr_height, k, v_height) {
         if ( v_height->at(0) > ratio )
            break;
      }
      assert(k > 0);

      // rule out layers which are not in the range
      if ( k > end + 1 || k <= start)  // make sure k-- is between [start, end]
         continue;
         
      //if ( k == array_n(arr_height) )  // this point is not in the range.
      //   continue;

      k -= 1;
      v_height = array_fetch(vector<float> *, arr_height, k);

      if ( v_height->at(1) < ratio )  // gap between two layers? ( found a bug where ratio > v_height[1], therefore y_patch < 0)
         continue;

      assert( k - start >= 0 && k - start < array_n(err_LUT) );
      st_table *st_lut = array_fetch(st_table *, err_LUT, k - start);  // [k - start]; don't need to minue start

      // mapping the reults
      // get the x, y coordinates

      int IMAGE_WIDTH  = image_width;
      int IMAGE_HEIGHT = image_height;
      int x_2D_1 = (int)(((data[i+1] - x_min)/(x_max - x_min))*IMAGE_WIDTH  + .5); // x
      double scale = (double)IMAGE_WIDTH / (x_max - x_min);
      int y_2D_1 = IMAGE_HEIGHT - (int)((data[i+2] - z_min) * scale + .5) - 1; // z

      if ( y_2D_1 < 0 )  // ignore negative numbers as used in <load_point_cloud_as_images>
         continue;

      int index_ = index(x_2D_1, y_2D_1);
      vector<int> *status;
      if ( st_lookup(st_lut, (char *)index_, (char **)&status) ) {

         // find the patch
         char patch_name[1000];
         sprintf(patch_name, "texture_%.3f_%.3f_%d-%d_%d-%d_image.png",
                 v_height->at(0),
                 v_height->at(1),
                 x_axis(status->at(2)),
                 y_axis(status->at(2)),
                 x_axis(status->at(3)),
                 y_axis(status->at(3)));
         vector<char *> *im_info;
         assert(st_lookup(st_name2img, (char *)patch_name, (char **)&im_info));
         int im_w = (int) im_info->at(0);
         int im_h = (int) im_info->at(1);
         BYTE **im_patch = (BYTE **)im_info->at(2);

         
         //draw the image patches based on distance
         float slope_line;
         if ( abs(x_axis(status->at(2)) - x_axis(status->at(3))) > abs(y_axis(status->at(2)) - y_axis(status->at(3))) )
            slope_line = (float) abs( x_axis(status->at(0)) - x_axis(status->at(2))) / abs( x_axis(status->at(3)) - x_axis(status->at(2)));
         else
            slope_line = (float) abs( y_axis(status->at(0)) - y_axis(status->at(2))) / abs( y_axis(status->at(3)) - y_axis(status->at(2)));
         
         int y_patch = (int) (im_h * (v_height->at(1) - ratio)/(v_height->at(1) - v_height->at(0)));
         int x_patch = (int) (im_w * slope_line);

         if ( y_patch == im_h )
            y_patch -= 1;
         if ( x_patch == im_w )
            x_patch -= 1;
         assert(y_patch >= 0 && x_patch >= 0 && y_patch < im_h && x_patch < im_w);
         
         count ++;

         // paper stats
         if ( status->at(1) > 0 ) {
            paper_local_stat += status->at(1);
            paper_local_num ++;
         }
         
         // status[0]: point [1]: distance [2-3]: two end points
         int new_value;
         if ( 0 ) {
            new_value = 255 - (int) (( (float) status->at(1) / (float) THRESH_ERROR) * 255);  // reverse.
         } else {
            new_value = status->at(1);
         }
         if ( im_patch[y_patch][x_patch] > new_value )
            im_patch[y_patch][x_patch] = new_value;    // Always use the largest/smallest error.
      }
      
   }
   printf("Total %d points are valid!\n", count);

   double paper_local_ave = (double)paper_local_stat / (double)paper_local_num;
   if ( paper_stat[0] == 0 ) {
      paper_stat[0] = paper_local_ave;
      paper_stat[1] = paper_local_num;
   } else {
      double all = paper_local_num + paper_stat[1];
      // 100/110 * a + 10/110 * b => 100/110 * a + 10/110*(b_sum/10);
      paper_stat[0] = ((double)paper_stat[1]/all)*paper_stat[0] + ((double)paper_local_stat/all); 
      paper_stat[1] += paper_local_num;
   }
   paper_stat[2] += st_count(st_name2img);
   
   // save the image patches.
   char *patch_fn;
   vector<char *> *im_info;
   st_generator *gen;
   char path_name[1000];
   st_foreach_item(st_name2img, gen, (char **)&patch_fn, (char **)&im_info ) {
      image_width  = (int) im_info->at(0);
      image_height = (int) im_info->at(1);
      BYTE **im = (BYTE **) im_info->at(2);
      sprintf(path_name, "%s/%s", gbl_opts->output_prefix, patch_fn);

      // Save a grey scale image.
#if 1 //ndef LINUX
      if ( 0 ) {
         //Save2File(path_name , im, (Bitmap *) 1, image_width, image_height, 0, NULL);
      } else {
         BYTE ***im_color = new_3D_image(image_height, image_width);
         float low = 0.0, thresh = 10.0, THRESH = 40.0;
         int r, g, b;
         for (int y = 0; y < image_height; y ++ )
            for (int x = 0; x < image_width; x ++ ) {
               float dis = im[y][x];
               if ( dis > THRESH ) {
                  r = g = b = 0;
               } else {
                  false_color(dis, low, thresh, r, g, b);
               }
               set_color(im_color, y, x, r, g, b);
            }
         Save2File(path_name, NULL, NULL, image_width, image_height, 1, im_color);
         free_image_3D(im_color);
      }
#endif

      // free resource;
      free_image(im);
      delete im_info;
   }

   st_free_table(st_name2img);
}


// Function: compute_error_taper_structure
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-s <N> -r <range> -f <face_width> -p <path> -w -h -P <texture_image save folder> -t"
void compute_error_taper_structure(array_t *end_points, array_t *z_arr, char *fn, int dataset_type)
{
   array_t *taper_points = array_alloc(array_t *, 0);
   array_t *taper_height = array_alloc(vector<float> *, 0);
   
   // filter the layers to keep taper structure only.
   // for quick paper implementation: ASSUME the height is the same.
   float bottom = -1.0;
   float top = -1.0;
   int k;
   vector<float> *vec_height;
   vector<int> *vec_points;
   arrayForEachItem(vector<float> *, z_arr, k, vec_height) {
      if ( (*vec_height)[2] > 0.5 ) { // 1.0 taper, 0.0 extrude
         array_insert_last(array_t *, taper_points, array_fetch(array_t *, end_points, k));
         array_insert_last(vector<float> *, taper_height, vec_height);

         if ( bottom == -1.0 ) {
            bottom = (*vec_height)[0];
            top = (*vec_height)[1];
         } else {
            assert( bottom == (*vec_height)[0]);
            assert( top == (*vec_height)[1]);
         }
      }
   }

   if ( array_n(taper_height) == 0 ) {
      printf("Error: No taper structures found!\n");
      return;
   }
   
   // TODO:
   // sort the point cloud data based on y axis.
   // CURRENT: collect once all point clouds between -thres + bottom_taper, top_taper + thres

   // BOX : -36.2841 82.3821 -2.4001 80.6962 -15.4828 136.499
   // TEST: -x 20 -X 90 -z 20 -Z 60 -y -3.0 -Y 44.0

   // create all image patches for this model
   double BOX_MIN_X;
   double BOX_MAX_X;
   double BOX_MIN_Y;
   double BOX_MAX_Y;
   double BOX_MIN_Z;
   double BOX_MAX_Z;
   assign_3D_box_Y_dir(BOX_MIN_X, BOX_MAX_X, BOX_MIN_Y, BOX_MAX_Y, BOX_MIN_Z, BOX_MAX_Z, dataset_type);

   float scale = image_width/(BOX_MAX_X - BOX_MIN_X);
   float thres = 40.0/scale;
   float range_low  = bottom * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y - thres;
   float range_high = top    * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y + thres;
   float taper_low  = bottom * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y;
   float taper_high = top    * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y;
   float taper_diff = taper_high - taper_low;

   char str_line[1000];
   char x_s[30], y_s[30], z_s[30];
   float x, y, z;
   vector<float> data0;
   FILE* fid = fopen(fn, "r");
   assert(fid);
   printf("loading data from file between %.3f and %.3f ...\n", range_low, range_high);
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", z_s, y_s, x_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         // rule out of some points
         if ( y > range_low && y < range_high) {
            data0.push_back(x);
            data0.push_back(y);
            data0.push_back(z);
         }
      }
   }
   fclose(fid);
   printf("STAT: totally %d points are in the taper range!\n", data0.size()/3);

   // for each face of the taper structure, convert the 2D point back to 3D coordniates
   // compute the 40 pixels to get the 3D mm distance, use this as a threshold for bounding boxes around the
   // 3D point, and collect all 3D point clouds inside this 3D bounding box.
   // compute the latest distance from the point clouds to the 3D point. If no point cloud data found,
   // use the black instead for this 2D pixel.

   int i;
   array_t *points;
   int x0, y0, x1, y1;
   arrayForEachItem(array_t *, taper_points, k, points) {
      printf("Processing taper No. %d ...\n", k);
      arrayForEachItem(vector<int> *, points, i, vec_points) {
         if ( i == 0 ) {
            x0 = (*vec_points)[0];
            y0 = (*vec_points)[1];
            x1 = (*vec_points)[2];
            y1 = (*vec_points)[3];
            continue;
         }

         // check the faces that is polygon, instead of triangle
         if ( x1 == (*vec_points)[2] && y1 == (*vec_points)[3] ) {
            continue;
         }

         // compute the size of the image
         int x2, y2, x3, y3;
         x2 = (*vec_points)[0];
         y2 = (*vec_points)[1];
         x3 = (*vec_points)[2];
         y3 = (*vec_points)[3];
         image_width  = (int)sqrt((float)(x0-x2)*(x0-x2) + (y0-y2)*(y0-y2));
         image_height = (int)sqrt((float)(x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));
         printf("INFO: Found a face, H: %d, W: %d, [%d, %d] -> [%d, %d] -> [%d, %d]\n",
                image_height, image_width, x0, y0, x2, y2, x1, y1);
         assert(image_width > 0 && image_height > 0);

         // filter some data based on smaller bounding box
         vector<float> data;
         float x_3D_min1 = get_3D_coordinate_from_2D_pixel_value(1, 0, min(x0, x2));
         float x_3D_max1 = get_3D_coordinate_from_2D_pixel_value(1, 0, max(x0, x2));
         float z_3D_min1 = get_3D_coordinate_from_2D_pixel_value(1, 2, min(y0, y2));
         float z_3D_max1 = get_3D_coordinate_from_2D_pixel_value(1, 2, max(y0, y2));
         float x_3D_min = min(x_3D_min1, x_3D_max1);
         float x_3D_max = max(x_3D_min1, x_3D_max1);
         float z_3D_min = min(z_3D_min1, z_3D_max1);
         float z_3D_max = max(z_3D_min1, z_3D_max1);
         for (int index = 0; index < data0.size(); index += 3) {
            if ( data0[index] > x_3D_min - thres && data0[index] < x_3D_max + thres &&
                 data0[index+2] > z_3D_min - thres && data0[index+2] < z_3D_max + thres) {
               data.push_back(data0[index]);
               data.push_back(data0[index+1]);
               data.push_back(data0[index+2]);
            }
         }
         
         float diff_y = y1 - y0;
         int dir_x = 1.0;
         if ( x2 < x0 ) {
            dir_x = -1.0;
         } else if ( x2 ==  x0 ) {
            printf("WARNING: taper on Z? [%d, %d], [%d, %d]\n", x0, y0, x2, y2);
         }
         // compute the errors for each pixel
         BYTE ***im = new_3D_image(image_height, image_width);
         for (int y = 0; y < image_height; y ++ ) {
            printf("INFO: computing image height %d.\n", y);
            for ( int x = 0; x < image_width; x ++ ) {
               float ratio_from_bottom_to_top_of_y = (image_height - y)/(float)image_height;

               int   x_2D = x0 + x*dir_x;
               int   z_2D = y0 + ratio_from_bottom_to_top_of_y*diff_y;
               float x_3D = get_3D_coordinate_from_2D_pixel_value(1, 0, x_2D);
               float y_3D = taper_low + taper_diff * ratio_from_bottom_to_top_of_y;
               float z_3D = get_3D_coordinate_from_2D_pixel_value(1, 2, z_2D);

               // find all error data inside the bounding box, and compute the distance.
               float min_dis = 3000.0;
               for (int index = 0; index < data.size(); index += 3) {
                  if ( data[index] > x_3D - thres && data[index] < x_3D + thres &&
                       data[index+1] > y_3D - thres && data[index+1] < y_3D + thres &&
                       data[index+2] > z_3D - thres && data[index+2] < z_3D + thres) {
                     float tmp = abs(data[index] - x_3D) + abs(data[index+1] - y_3D) + abs(data[index+2] - z_3D);
                     if ( tmp < min_dis ) {
                        min_dis = tmp;
                     }
                        
                  }
               }
               
               int r, g, b;
               float THRESH = 10 * thres; // 40.
               if ( min_dis > THRESH ) {
                  r = g = b = 0;
               } else {
                  false_color(min_dis, 0.0, THRESH, r, g, b);
               }
               set_color(im, y, x, r, g, b);
               
            }
         }

         // Save the texture/error image
         char texture_name[1000];
         sprintf(texture_name, "%s/texture_%.3f_%.3f_%d-%d_%d-%d_image.png", gbl_opts->output_prefix, bottom, top, x0, y0, x2, y2);
         Save2File(texture_name, NULL, NULL, image_width, image_height, 1, im);

         // reset the vars
         x0 = x2; y0 = y2;
         x1 = x3; y1 = y3;
         free_image_3D(im);
      }
   }
   


   
}

// Function: compute_error_extrusion_structure
//
// Compute the error for a model in IR
//
void compute_error_extrusion_structure(vector<double> &data_all,
                                       vector<int> *lines,
                                       float bottom,
                                       float top,
                                       int im_w)
{
   // TODO:
   // sort the point cloud data based on y axis.
   // CURRENT: collect once all point clouds between -thres + bottom_taper, top_taper + thres

   // BOX : -36.2841 82.3821 -2.4001 80.6962 -15.4828 136.499
   // TEST: -x 20 -X 90 -z 20 -Z 60 -y -3.0 -Y 44.0
   float BOX_MIN_X = 20.0;
   float BOX_MAX_X = 90.0;
   float BOX_MIN_Y =  0.0;
   float BOX_MAX_Y = 44.0;
   float BOX_MIN_Z = 20.0;
   float BOX_MAX_Z = 60.0;

   float scale = 14.6285714; // z_scaler = 1024/(BOX_MAX_X - BOX_MIN_X) = 1024/70 = 14.6285714
   float thres = 40.0/scale;
   float thres_layer = 2.0/scale;
   float range_low  = bottom * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y - thres;
   float range_high = top    * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y + thres;
   float taper_low  = bottom * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y;
   float taper_high = top    * (BOX_MAX_Y - BOX_MIN_Y) + BOX_MIN_Y;
   float taper_diff = taper_high - taper_low;

   image_height = (int)  (scale * (abs(top - bottom) * (BOX_MAX_Y - BOX_MIN_Y)));
   image_width  = im_w;
   printf("image height: %d, lines : %d for [%.3f - %.3f]\n", image_height, lines->size(), bottom, top);
   assert(image_width > 0);
   if ( image_height == 0 ) {
      printf(" ==== WARNING: the height is 0 for layer [%.3f - %.3f]\n", bottom, top);
      return;
   }
   return;

   // test
   if ( 0 && (bottom < 0.85 || bottom > 0.9) )
       return;
   
   vector<float> data0;
   for ( int i = 0; i < data_all.size(); i += 3) {
      if ( data_all[i] > range_low && data_all[i] < range_high) {
         data0.push_back((data_all)[i+1]);  // y, x, z
         data0.push_back((data_all)[i]);
         data0.push_back((data_all)[i+2]);
      }
   }
   printf("STAT: totally %d points are in the taper range!\n", data0.size()/3);

   // debug purpose - print out all the data in this layer
   if (0){
      int IMAGE_HEIGHT = 392;
      int IMAGE_WIDTH = 1024;
      float diff_x = BOX_MAX_X - BOX_MIN_X;
      float scale = (float)IMAGE_WIDTH / diff_x;
      BYTE **im = new_image(IMAGE_HEIGHT, IMAGE_WIDTH);
      image_height = IMAGE_HEIGHT;
      image_width = IMAGE_WIDTH;
      for (int i = 0; i < data0.size(); i+=3)
      {
         // CHANGE: BOX_MIN_Z
         int z_i;
         z_i = IMAGE_HEIGHT - (int)((data0[i+2] - BOX_MIN_Z) * scale + .5) - 1; // z
         if (z_i < 0)
            continue;

         int x_i;
         x_i = (int)(((data0[i] - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
         if (x_i == IMAGE_WIDTH)
            x_i -= 1;

         im[z_i][x_i] = BLACK;

      }

      char ofn[1000];
      sprintf(ofn, "image_slice_test.png");
      Save2File(ofn, im, NULL, IMAGE_WIDTH, IMAGE_HEIGHT, 0, NULL);
      free_image(im);
      exit(0);
   }
   
   // end of debug
   
   BYTE ***im = new_3D_image(image_height, image_width);

   // for each face of the taper structure, convert the 2D point back to 3D coordniates
   // compute the 40 pixels to get the 3D mm distance, use this as a threshold for bounding boxes around the
   // 3D point, and collect all 3D point clouds inside this 3D bounding box.
   // compute the latest distance from the point clouds to the 3D point. If no point cloud data found,
   // use the black instead for this 2D pixel.
   int x0, y0, x2, y2;
   int gbl_width = 0;
   int patch_width;
   vector<float> data1;
   for (int k = 0; k < lines->size(); k += 4)
   {
      {
         x0 = (*lines)[k];
         y0 = (*lines)[k+1];
         x2 = (*lines)[k+2];
         y2 = (*lines)[k+3];
      }

      // check the faces that is polygon, instead of triangle
      if ( x0 == x2 && y0 == y2) {
         continue;
      }

      // filter some data based on smaller bounding box
      float x_3D_min1 = get_3D_coordinate_from_2D_pixel_value(1, 0, x0);
      float x_3D_max1 = get_3D_coordinate_from_2D_pixel_value(1, 0, x2);
      float z_3D_min1 = get_3D_coordinate_from_2D_pixel_value(1, 2, y0);
      float z_3D_max1 = get_3D_coordinate_from_2D_pixel_value(1, 2, y2);
      float x_3D_min = min(x_3D_min1, x_3D_max1);
      float x_3D_max = max(x_3D_min1, x_3D_max1);
      float z_3D_min = min(z_3D_min1, z_3D_max1);
      float z_3D_max = max(z_3D_min1, z_3D_max1);
      for (int index = 0; index < data0.size(); index += 3) {
         if ( data0[index] > x_3D_min - thres && data0[index] < x_3D_max + thres &&
              data0[index+2] > z_3D_min - thres && data0[index+2] < z_3D_max + thres) {
            data1.push_back(data0[index]);   // x
            data1.push_back(data0[index+1]); // y
            data1.push_back(data0[index+2]); // z
         }
      }
         
      float diff_x = x2 - x0;
      float diff_y = y2 - y0;

      // compute the size of the image
      patch_width = (int)sqrt(diff_x*diff_x + diff_y*diff_y);

      // compute the errors for each pixel
      for (int y = 0; y < image_height; y ++ ) {
         for ( int x = 0; x < patch_width; x ++ ) {
            float ratio_from_bottom_to_top_of_y = (float)(image_height - y)/(float)image_height;
            float ratio_from_left_to_right_of_x = (float)(patch_width  - x)/(float)patch_width;

            // x_2D in image is from x0 to x2 with a ratio of patch_width, note the +/- to x2
            // z_2D in image is from y0 to y2 with a ratio of patch_width, note the +/- to y2
            int   x_2D = x0 + diff_x*ratio_from_left_to_right_of_x;
            int   z_2D = y0 + diff_y*ratio_from_left_to_right_of_x;
            float x_3D = get_3D_coordinate_from_2D_pixel_value(1, 0, x_2D);
            float y_3D = taper_low + taper_diff * ratio_from_bottom_to_top_of_y;
            float z_3D = get_3D_coordinate_from_2D_pixel_value(1, 2, z_2D);

            // testing
            /*
            float diff_x = BOX_MAX_X - BOX_MIN_X;
            int IMAGE_WIDTH = 1024;
            int IMAGE_HEIGHT = 392;
            float t_x_2D = (int)(((x_3D - BOX_MIN_X)/diff_x)*IMAGE_WIDTH  + .5); // x
            double scale = (double)IMAGE_WIDTH / diff_x;
            float t_z_2D = IMAGE_HEIGHT - (int)((z_3D - BOX_MIN_Z) * scale + .5) - 1; // z
            */
            // end testing
            
            //printf("BOX, [%.3f, %.3f] = [%.3f, %.3f], here, [%.3f, %.3f, %.3f]\n", x_3D_min, x_3D_max,
            //     z_3D_min, z_3D_max, x_3D, y_3D, z_3D);
            // find all error data inside the bounding box, and compute the distance.
            float min_dis = 3000.0;
            for (int index = 0; index < data1.size(); index += 3) {
               float thres1 = thres;
               float thres2 = thres_layer;
               if ( data1[index]   > x_3D - thres1 && data1[index]   < x_3D + thres1  &&
                    data1[index+2] > z_3D - thres1 && data1[index+2] < z_3D + thres1  &&
                    data1[index+1] > y_3D - thres2 && data1[index+1] < y_3D + thres2)
               {
                  float d1 = data1[index] - x_3D;
                  float d2 = data1[index+1] - y_3D;
                  float d3 = data1[index+2] - z_3D;
                  float tmp = sqrt(d1*d1 + d2*d2 + d3*d3);
                  if ( tmp < min_dis ) {
                     min_dis = tmp;
                  }
                        
               }
            }
               
            int r, g, b;
            float THRESH = gbl_opts->KSD_ratio * thres; // 40.
            float thres_dis = THRESH*4;
            if ( min_dis > THRESH ) {
               r = g = b = 0;
            } else {
               false_color(min_dis, 0.0, thres_dis, r, g, b);
            }
            set_color(im, y, x + gbl_width, r, g, b);
               
         }
      }

      data1.clear();
      gbl_width += patch_width;
   }

   // Save the texture/error image
   char texture_name[1000];
   sprintf(texture_name, "%s/texture_%.3f_%.3f_image.png", gbl_opts->output_prefix, bottom, top);
   Save2File(texture_name, NULL, NULL, image_width, image_height, 1, im);
   free_image_3D(im);
   
}

// Function: compute_error_for_IR_face_based
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-s <N> -r <range> -f <face_width> -p <path> -w -h -P <texture_image save folder>"
// Algorithm:
//    The idea is to compute a LUT based on IR. This LUT is for each pixel in the image of the same height,
//    which point on the line segment will reach it earliest based on dilation processing.
//    Then, for each 3D point, we can get the corresponding LUT point and distance (in terms of pixel, do not
//    use the math distance from point to line) and map them into texture image.
void compute_error_for_IR_face_based(char *fn)
{
   char *path_str = "result/error_comp/debug_errors";
   if (!fn) {
      printf(" Please specify the model file !\n");
      exit(0);
   }

   char *load_fn = "../data/Rotated.bpa";
   gbl_opts->output_prefix = "result/error_comp";
   int  frame_num = 1000;
   int  face_width = 5;
   int  search_range = 40;
   int  im_w = 1024;
   int  im_h = 392;
   int  ignore_taper = 1;
   int dataset_type = 0; // 0: bpa, 1: ptx

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "r:e:m:s:f:L:w:th:p:P:")) != EOF)
      {
         switch (c) {
            case 'e':
               break;
            case 'm':
               dataset_type = atoi(util_optarg);
               break;
            case 's':
               frame_num = atoi(util_optarg);
               break;
            case 'r':
               search_range = atoi(util_optarg);
               break;
            case 'p':
               path_str = strdup(util_optarg);
               break;
            case 'P':
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'L':
               load_fn = strdup(util_optarg);
               break;
            case 'f':
               face_width = atoi(util_optarg);
               break;
            case 't':
               ignore_taper = 0;
               break;
            case 'w':
               im_w = atoi(util_optarg);
               break;
            case 'h':
               im_h = atoi(util_optarg);
               break;
            default:
               printf("Error: No option for this command!\n");
               break;
         }
      }
   }

   image_height = im_h;
   image_width  = im_w;
   
   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));

   // if necessary, compute texture images for taper structures.
   if ( ignore_taper == 0 ) {
      compute_error_taper_structure(end_points, z_arr, load_fn, dataset_type);
      return;
   }

   // get the 3D points and measure the distance from LUT.
   vector<double> data;
   compute_error_load_3D_data(load_fn, data);

   // get the lookup-table based on the height, measure the point and distance.
   // ordered by z_arr;
   array_t *arr_height = array_alloc(vector<float> *, 0);
   array_t *arr_boundaries = array_alloc(vector<int> *, 0);
   printf("Ordering the key slicing...\n");
   compute_error_order_boundaries(end_points, z_arr, arr_height, arr_boundaries);

   // has to do this to reduce the requirement for resources
   // split the whole process into a group of smaller problems, and solve them one by one
   int group_num = 20;
   vector<double> paper_stat(3, 0.0);   // For writing: paper_stat[0] - the average error for all points.
                                        // paper_stat[1] - the total number of points so far
                                        // paper_stat[2] - the total number of faces.
   FILE *fd_paper = fopen("paper_stat.txt", "a+");
   for ( int layer = 0; layer < array_n(arr_height); layer += group_num) {
      
	  array_t *arr_LUT = array_alloc(st_table *, 0);

      int end_layer = min(layer + group_num, array_n(arr_height));
      end_layer --;
      
      printf("Computing the LUT from %d to %d...\n", layer, end_layer);
      compute_error_obtain_LUT_for_each_height(arr_height, arr_boundaries, arr_LUT, layer, end_layer);

      // draw the texture images
      printf("Computing the texture mapping ...\n");
      compute_error_texture_mapping(data, arr_LUT, arr_height, arr_boundaries, layer, end_layer, paper_stat, dataset_type);

      // free resources.  LUTs.
      {
         int k;
         st_table *st_lut;
         arrayForEachItem(st_table *, arr_LUT, k, st_lut ) {
            int *cur_point1;
            st_generator *gen;
            vector<int> *status;
            st_foreach_item(st_lut, gen, (char **) &cur_point1, (char **)&status) {
               delete status;
            }
            st_free_table(st_lut);
         }
		 array_free(arr_LUT);
      }

      // reset the image size globablly
      image_height = im_h;
      image_width  = im_w;
   
   }

   fprintf(fd_paper,"%s - PAPER RESULT -  AVERAGE ERROR: [%.3f] TOTAL FACES: [%f]\n", gbl_opts->output_prefix, paper_stat[0], paper_stat[2]);
   fclose(fd_paper);
   
   // free resources.  z_arr, end_points, arr_height, arr_boundaries

}

// Function: compute_error_for_IR
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-s <N> -r <range> -f <face_width> -p <path> -w -h"
void compute_error_for_IR_grey(char *fn)
{
   char *path_str = "result/error_comp/debug_errors";
   if (!fn) {
      printf(" Please specify the model file !\n");
      exit(0);
   }
   
   int  frame_num = 1000;
   int  face_width = 5;
   int  search_range = 40;
   int  im_w = 1024;
   int  im_h = 392;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "r:s:f:w:h:p:")) != EOF)
      {
         switch (c) {
            case 's':
               frame_num = atoi(util_optarg);
               break;
            case 'r':
               search_range = atoi(util_optarg);
               break;
            case 'p':
               path_str = strdup(util_optarg);
               break;
            case 'f':
               face_width = atoi(util_optarg);
               break;
            case 'w':
               im_w = atoi(util_optarg);
               break;
            case 'h':
               im_h = atoi(util_optarg);
               break;
            default:
               printf("Error: No option for this command!\n");
               break;
         }
      }
   }
               
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);

   assert(array_n(end_points) == array_n(z_arr));

#if 0 // for debug purpose - print out model sliced image  
   image_height  = 392;  // default values
   image_width   = 1024;
   // save color image for debugging.
   //for (int i = 0 ; i < frame_num; i ++)
   for (int i = 173 ; i < 174; i ++)
   {
      printf("Processing the frame %d ... \n", i);
      char out_fn[1000];
      char *ds = digit_string(4, i);
      //sprintf(out_fn, "result/error_comp/model_images/model_slice_%s.png", ds);
      sprintf(out_fn, "%s/model_slice_%s_color.png", path_str, ds);
      free(ds);
      vector<int> line_set;
      load_lines_from_end_points(end_points, line_set, i, frame_num, z_arr);
      //write_lines_to_bw_image(out_fn, line_set,  image_height, image_width);
      write_lines_to_image(out_fn, line_set,  image_height, image_width, NULL);
   }
   exit(0);
#endif   

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   // clear the error file
   char err_fn[1000];
   sprintf(err_fn, "%s/../error_comp_result.txt", path_str);
   FILE *ef = fopen(err_fn, "w");
   fclose(ef);
   
   BYTE **cur_im;
   for (int i = 0 ; i < frame_num; i ++)
   {
      printf("Processing the frame %d ... \n", i);
      char in_fn[1000];
      //char out_fn[1000];
      char *ds = digit_string(4, i);
      sprintf(in_fn,  "%s/image_slice_%s.png",path_str, ds);
      //sprintf(out_fn, "result/error_comp/debug_errors/model_slice_%s_color.png", ds);
      free(ds);

      // get the image
      int h, w;
      orig_img = load_image(in_fn, h, w);
      set_image(cur_im, orig_img);

      // set the reference image
      vector<int> line_set;
      load_lines_from_end_points(end_points, line_set, i, frame_num, z_arr);
      //write_lines_to_image(out_fn, line_set,  image_height, image_width, NULL);

      // compute the errors.
      compute_error_diff_between_two_im(cur_im, line_set, i, path_str, frame_num);

      delete orig_img;
      free_image(cur_im);
   }

}

// Function: compute_error_for_IR_layer_based
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-a 2 -L <bpa file> -P <texture_image save folder>"
// Algorithm:
//    The idea is to compute a big wide image for a layer. The width of the image is the addition of
//    line segments in this layer of the model.
//    For each pixel, compute the shortest distance by mapping it back to 3D space as did in taper
//    face error computation.
//    For texture mapping, set the (u,v) or (s,t) based on the proportion of line segments in the
//    long wide image.
void compute_error_for_IR_layer_based(char *fn)
{
   char *path_str = "result/error_comp/debug_errors";
   if (!fn) {
      printf(" Please specify the model file !\n");
      exit(0);
   }

   char *load_fn = "../data/Rotated.bpa";
   gbl_opts->output_prefix = "result/error_comp";
   int  frame_num = 1000;
   int  face_width = 5;
   int  search_range = 40;
   int  im_w = 1024;
   int  im_h = 392;
   int  ignore_taper = 1;
   int  dataset_type = 0;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:m:r:s:f:L:w:tT:h:p:P:")) != EOF)
      {
         switch (c) {
            case 'a':
            case 'T':
               break;
            case 's':
               frame_num = atoi(util_optarg);
               break;
            case 'm':
               dataset_type = atoi(util_optarg);
               break;
            case 'r':
               search_range = atoi(util_optarg);
               break;
            case 'p':
               path_str = strdup(util_optarg);
               break;
            case 'P':
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'L':
               load_fn = strdup(util_optarg);
               break;
            case 'f':
               face_width = atoi(util_optarg);
               break;
            case 't':
               ignore_taper = 0;
               break;
            case 'w':
               im_w = atoi(util_optarg);
               break;
            case 'h':
               im_h = atoi(util_optarg);
               break;
            default:
               printf("Error: No option for this option %c!\n", c);
               break;
         }
      }
   }

   image_height = im_h;
   image_width  = im_w;
   
   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));

   // if necessary, compute texture images for taper structures.
   if ( ignore_taper == 0 ) {
      compute_error_taper_structure(end_points, z_arr, load_fn, dataset_type);
      return;
   }

   // get the 3D points and measure the distance from LUT.
   vector<double> data;
   compute_error_load_3D_data(load_fn, data);

   // get the lookup-table based on the height, measure the point and distance.
   // ordered by z_arr;
   // the taper layer has been removed in the arr_height.
   array_t *arr_height = array_alloc(vector<float> *, 0);
   array_t *arr_boundaries = array_alloc(vector<int> *, 0);
   printf("Ordering the key slicing...\n");
   compute_error_order_boundaries(end_points, z_arr, arr_height, arr_boundaries);

   // has to do this to reduce the requirement for resources
   // split the whole process into a group of smaller problems, and solve them one by one
   vector<double> paper_stat(3, 0.0);   // For writing: paper_stat[0] - the average error for all points.
                                        // paper_stat[1] - the total number of points so far
                                        // paper_stat[2] - the total number of faces.
   FILE *fd_paper = fopen("paper_stat.txt", "a+");
   for ( int layer = 0; layer < array_n(arr_height); layer ++)
   {
      // reset the image size globablly
      int k;
      vector<int> *points;
      float bottom = array_fetch(vector<float> *, arr_height, layer)->at(0);
      float top    = array_fetch(vector<float> *, arr_height, layer)->at(1);
      im_w = 0;
      int x0, y0, x1, y1;
      vector<int> *lines = array_fetch(vector<int> *, arr_boundaries, layer);
      for (int i = 0; i < lines->size(); i += 4) {
         x0 = lines->at(i);
         y0 = lines->at(i+1);
         x1 = lines->at(i+2);
         y1 = lines->at(i+3);
         float x_l = x0 - x1;
         float y_l = y0 - y1;
         im_w += (int)(sqrt(x_l*x_l + y_l*y_l));
      }

      printf("Infor: Layer %d, image width: %d ", layer, im_w);
      
      // compute the error like taper structure.
      compute_error_extrusion_structure(data, lines, bottom, top, im_w);

   }

   fprintf(fd_paper,"%s - PAPER RESULT -  AVERAGE ERROR: [%.3f] TOTAL FACES: [%f]\n", gbl_opts->output_prefix, paper_stat[0], paper_stat[2]);
   fclose(fd_paper);
   
   // free resources.  z_arr, end_points, arr_height, arr_boundaries

}

// Function: compute_error_texture_mapping
//
// Compute the texture mapping
// Input:  a vector of 3D data point cloud data
// Output: corresponding error texture images
// Algorithm: based on Y axis of data, find the corresponding arr_height and therefore corresponding LUT.
//            based on the X, Z value, look up the point and structure for mapping.
void compute_error_texture_mapping_layer_with_faces(vector<double> &data, array_t *err_LUT,
                                   array_t *arr_height, array_t *arr_boundaries,
                                   int start, int end, vector<double> &paper_stat, int THRESH_ERROR, int type, double mean_pred = -1.0)
{
   double x_min, y_min, z_min;
   double x_max, y_max, z_max;

   assign_3D_box_Y_dir(x_min, x_max, y_min, y_max, z_min, z_max, type);

   // create all image patches for this model
   double z_scaler = (double)image_width / (x_max - x_min);
   double depth_bottom = z_min * z_scaler; // -2.116044 * z_scaler;
   double depth_top    = z_max * z_scaler; // 30.216660 * z_scaler;
   double depth_inter  = depth_top - depth_bottom; 
   int    sample_num   = 1000;
   float  error_max    = 15.0;  // maximum error bound

   double variance = 0.0;

   st_table *st_name2img = st_init_table(strcmp, st_strhash);
   vector<char *> *im_save = new vector<char *>;

   int i;
   vector<int> *line_set;
   vector<float> *v_height;
   arrayForEachItem(vector<int> *, arr_boundaries, i, line_set) {

      // rule out layer which are not in the range
      if ( i > end || i < start )
         continue;
      
      assert(line_set->size() % 4 == 0);
      v_height = array_fetch(vector<float> *, arr_height, i);
      char img_fn[1000];

      int img_w = 0;
      int img_h = (int) abs(depth_inter * (v_height->at(1) - v_height->at(0)));
      img_h = img_h > 0 ? img_h : 1;
      for (int j = 0; j < line_set->size(); j += 4)
      {
         int x0 = line_set->at(j);
         int y0 = line_set->at(j+1);
         int x1 = line_set->at(j+2);
         int y1 = line_set->at(j+3);
         float d_x = x0 - x1;
         float d_y = y0 - y1;

         img_w += (int)sqrt(d_x*d_x + d_y*d_y);
      }
      assert(img_w >= 1 && img_h >= 1);
      BYTE **im = new_image(img_h, img_w);
      memset(im[0], 255, img_h * img_w);
      sprintf(img_fn, "texture_%.3f_%.3f_image.png", v_height->at(0), v_height->at(1));
      im_save->push_back((char *)img_w);
      im_save->push_back((char *)img_h);
      im_save->push_back((char *)im);
      im_save->push_back((char *)strdup(img_fn));
      
      int gbl_width = 0;
      for (int j = 0; j < line_set->size(); j += 4)
      {
         sprintf(img_fn, "texture_%.3f_%.3f_%d-%d_%d-%d_image.png",
                 v_height->at(0),
                 v_height->at(1),
                 line_set->at(j),
                 line_set->at(j+1),
                 line_set->at(j+2),
                 line_set->at(j+3) );

         img_w = (int)sqrt( (float) (line_set->at(j+2) - line_set->at(j  ))*((line_set->at(j+2) - line_set->at(j))) +
                            (line_set->at(j+3) - line_set->at(j+1))*((line_set->at(j+3) - line_set->at(j+1))));
         assert(img_w >= 1 && img_h >= 1);
         char *copy_fn = strdup(img_fn);
         vector<char *> *im_info = new vector<char *>;
         im_info->push_back((char *)img_w);
         im_info->push_back((char *)img_h);
         im_info->push_back((char *)im);
         im_info->push_back((char *)gbl_width);
         st_insert(st_name2img, (char *)copy_fn, (char *)im_info);

         gbl_width += img_w;
      }
      
      
   }
   
   // based on Y axis of data, find the corresponding arr_height and therefore corresponding LUT.
   // based on the X, Z value, look up the point and structure for mapping.
   // data: y, x, z

   int count = 0;

#ifdef MSVC_60
   long paper_local_stat = 0;
   long paper_local_num = 0;
#else
   long long paper_local_stat = 0;
   long long paper_local_num = 0;
#endif 
   assert( data.size() % 3 == 0);
   for ( i = 0; i < data.size(); i += 3 ) {

      double ratio = (data[i] - y_min) / (y_max - y_min);

      // find the right LUT
      int k;
      vector<float> *v_height;
      arrayForEachItem(vector<float> *, arr_height, k, v_height) {
         if ( v_height->at(0) > ratio )
            break;
      }
      assert(k > 0);

      // rule out layers which are not in the range
      if ( k > end + 1 || k <= start)  // make sure k-- is between [start, end]
         continue;
         
      //if ( k == array_n(arr_height) )  // this point is not in the range.
      //   continue;

      k -= 1;
      v_height = array_fetch(vector<float> *, arr_height, k);

      if ( v_height->at(1) < ratio )  // gap between two layers? ( found a bug where ratio > v_height[1], therefore y_patch < 0)
         continue;

      assert( k - start >= 0 && k - start < array_n(err_LUT) );
      st_table *st_lut = array_fetch(st_table *, err_LUT, k - start);  // [k - start]; don't need to minue start

      // mapping the reults
      // get the x, y coordinates

      int IMAGE_WIDTH  = image_width;
      int IMAGE_HEIGHT = image_height;
      int x_2D_1 = (int)(((data[i+1] - x_min)/(x_max - x_min))*IMAGE_WIDTH  + .5); // x
      double scale = (double)IMAGE_WIDTH / (x_max - x_min);
      int y_2D_1 = IMAGE_HEIGHT - (int)((data[i+2] - z_min) * scale + .5) - 1; // z

      if ( y_2D_1 < 0 )  // ignore negative numbers as used in <load_point_cloud_as_images>
         continue;

      int index_ = index(x_2D_1, y_2D_1);
      vector<int> *status;
      if ( st_lookup(st_lut, (char *)index_, (char **)&status) ) {

         // find the patch
         char patch_name[1000];
         sprintf(patch_name, "texture_%.3f_%.3f_%d-%d_%d-%d_image.png",
                 v_height->at(0),
                 v_height->at(1),
                 x_axis(status->at(2)),
                 y_axis(status->at(2)),
                 x_axis(status->at(3)),
                 y_axis(status->at(3)));
         vector<char *> *im_info;
         assert(st_lookup(st_name2img, (char *)patch_name, (char **)&im_info));
         int im_w = (int) im_info->at(0);
         int im_h = (int) im_info->at(1);
         BYTE **im_all = (BYTE **)im_info->at(2);
         int gbl_width = (int) im_info->at(3);

         
         //draw the image patches based on distance
         float slope_line;
         if ( abs(x_axis(status->at(2)) - x_axis(status->at(3))) > abs(y_axis(status->at(2)) - y_axis(status->at(3))) )
            slope_line = (float) abs( x_axis(status->at(0)) - x_axis(status->at(2))) / abs( x_axis(status->at(3)) - x_axis(status->at(2)));
         else
            slope_line = (float) abs( y_axis(status->at(0)) - y_axis(status->at(2))) / abs( y_axis(status->at(3)) - y_axis(status->at(2)));
         
         int y_patch = (int) (im_h * (v_height->at(1) - ratio)/(v_height->at(1) - v_height->at(0)));
         int x_patch = (int) (im_w * slope_line);

         if ( y_patch == im_h )
            y_patch -= 1;
         if ( x_patch == im_w )
            x_patch -= 1;
         assert(y_patch >= 0 && x_patch >= 0 && y_patch < im_h && x_patch < im_w);
         
         count ++;

         // paper stats
         if ( status->at(1) > 0 ) {
            paper_local_stat += status->at(1);
            paper_local_num ++;
            if ( mean_pred != -1.0 )
               variance += ((double)status->at(1)/z_scaler - mean_pred) * ((double)status->at(1)/z_scaler - mean_pred);
         }
         
         // status[0]: point [1]: distance [2-3]: two end points
         int new_value;
         if ( 0 ) {
            new_value = 255 - (int) (( (float) status->at(1) / (float) THRESH_ERROR) * 255);  // reverse.
         } else {
            new_value = status->at(1);
         }
         if ( im_all[y_patch][x_patch+gbl_width] > new_value )
            im_all[y_patch][x_patch+gbl_width] = new_value;    // Always use the largest/smallest error.
      }
      
   }
   printf("Total %d points are valid!\n", count);

   variance = variance / (double)paper_local_num;
   double paper_local_ave = (double)paper_local_stat / (double)paper_local_num;
   if ( paper_stat[0] == 0 ) {
      paper_stat[0] = paper_local_ave;
      paper_stat[1] = paper_local_num;
      paper_stat[3] = variance;
   } else {
      double all = paper_local_num + paper_stat[1];
      // 100/110 * a + 10/110 * b => 100/110 * a + 10/110*(b_sum/10);
      paper_stat[0] = ((double)paper_stat[1]/all)*paper_stat[0] + ((double)paper_local_stat/all); 
      paper_stat[1] += paper_local_num;
      paper_stat[3] = ((double)paper_stat[1]/all)*paper_stat[3] + ((double)paper_local_num*variance)/all; 
   }
   paper_stat[2] += st_count(st_name2img);
   
   // save the image patches.
   assert(im_save->size() % 4 == 0);
   char path_name[1000];
   for (int i = 0; i < im_save->size(); i += 4 ) {
      image_width  = (int) im_save->at(i);
      image_height = (int) im_save->at(i+1);
      BYTE **im = (BYTE **) im_save->at(i+2);
      char *fn = im_save->at(i+3);
      sprintf(path_name, "%s/%s", gbl_opts->output_prefix, fn);
      printf("Saving the file %s.\n", path_name);

      // Save a grey scale image.
#if 1 //ndef LINUX
      if ( 0 ) {
         //Save2File(path_name , im, (Bitmap *) 1, image_width, image_height, 0, NULL);
      } else {
         BYTE ***im_color = new_3D_image(image_height, image_width);
         float low = 0.0, thresh = 10.0, THRESH = 40.0;
         int r, g, b;
         for (int y = 0; y < image_height; y ++ )
            for (int x = 0; x < image_width; x ++ ) {
               float dis = im[y][x];
               if ( dis > THRESH ) {
                  // r = g = b = 0; // or not???
               } else {
                  false_color(dis, low, thresh, r, g, b);
               }
               set_color(im_color, y, x, r, g, b);
            }
         Save2File(path_name, NULL, NULL, image_width, image_height, 1, im_color);
         free_image_3D(im_color);
      }
#endif

      // free resource;
      free_image(im);
      free(fn);
   }
   delete im_save;

   char *patch_fn;
   vector<char *> *im_info;
   st_generator *gen;
   st_foreach_item(st_name2img, gen, (char **)&patch_fn, (char **)&im_info ) {
      free(patch_fn);
      delete im_info;
   }
   st_free_table(st_name2img);

   // change the unit from pixel to mm;
   paper_stat[0] /= z_scaler;
}

// Function: compute_error_for_IR_layer_based_with_faces
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-s <N> -r <range> -f <face_width> -p <path> -w -h -P <texture_image save folder>"
// Algorithm:
//    The idea is to compute a LUT based on IR. This LUT is for each pixel in the image of the same height,
//    which point on the line segment will reach it earliest based on dilation processing.
//    Then, for each 3D point, we can get the corresponding LUT point and distance (in terms of pixel, do not
//    use the math distance from point to line) and map them into texture image.
void compute_error_for_IR_layer_based_with_faces(char *fn)
{
   char *path_str = "result/error_comp/debug_errors";
   if (!fn) {
      printf(" Please specify the model file !\n");
      exit(0);
   }

   char *load_fn = "../data/Rotated.bpa";
   gbl_opts->output_prefix = "result/error_comp";
   int  frame_num = 1000;
   int  face_width = 5;
   int  search_range = 40;
   int  im_w = 1024;
   int  im_h = 392;
   int  ignore_taper = 1;
   int  dataset_type = 0;  // 0: bpa, 1: ptx, 2: all
   int  thresh_err = 40;  // 40 for Tom; 4 for Theater;
   double mean_pred = -1.0;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:e:m:r:s:f:L:w:tT:h:p:P:")) != EOF)
      {
         switch (c) {
            case 'a':
            case 'T':
               break;
            case 'e':
               thresh_err = atoi(util_optarg);
               break;
            case 'm':
               dataset_type = atoi(util_optarg);
               break;
            case 's':
               frame_num = atoi(util_optarg);
               break;
            case 'r':
               // search_range = atoi(util_optarg);
               mean_pred = atof(util_optarg);
               break;
            case 'p':
               path_str = strdup(util_optarg);
               break;
            case 'P':
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'L':
               load_fn = strdup(util_optarg);
               break;
            case 'f':
               face_width = atoi(util_optarg);
               break;
            case 't':
               ignore_taper = 0;
               break;
            case 'w':
               im_w = atoi(util_optarg);
               break;
            case 'h':
               im_h = atoi(util_optarg);
               break;
            default:
               printf("Error: No option for this command!\n");
               break;
         }
      }
   }

   image_height = im_h;
   image_width  = im_w;
   
   // get the data from IR txt file:
   // end_points is an array of boundaries. The height of the boundaries is stored in z_arr.
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points = load_end_points_from_IR(fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));

   // if necessary, compute texture images for taper structures.
   if ( ignore_taper == 0 ) {
      compute_error_taper_structure(end_points, z_arr, load_fn, dataset_type);
      return;
   }

   // get the 3D points and measure the distance from LUT.
   vector<double> data;
   compute_error_load_3D_data(load_fn, data, dataset_type);

   // get the lookup-table based on the height, measure the point and distance.
   // ordered by z_arr;
   array_t *arr_height = array_alloc(vector<float> *, 0);
   array_t *arr_boundaries = array_alloc(vector<int> *, 0);
   printf("Ordering the key slicing...\n");
   compute_error_order_boundaries(end_points, z_arr, arr_height, arr_boundaries);

   // has to do this to reduce the requirement for resources
   // split the whole process into a group of smaller problems, and solve them one by one
   int group_num = 20;
   vector<double> paper_stat(4, 0.0);   // For writing: paper_stat[0] - the average error for all points.
                                        // paper_stat[1] - the total number of points so far
                                        // paper_stat[2] - the total number of faces.
                                        // paper_stat[3] - the variance.
   FILE *fd_paper = fopen("paper_stat.txt", "a+");
   for ( int layer = 0; layer < array_n(arr_height); layer += group_num)
   {
      array_t *arr_LUT = array_alloc(st_table *, 0);
      int end_layer = min(layer + group_num, array_n(arr_height));
      end_layer --;
      
      printf("Computing the LUT from %d to %d...\n", layer, end_layer);
      compute_error_obtain_LUT_for_each_height(arr_height, arr_boundaries, arr_LUT, layer, end_layer, thresh_err);

      // draw the texture images
      printf("Computing the texture mapping ...\n");
      compute_error_texture_mapping_layer_with_faces(data, arr_LUT, arr_height, arr_boundaries, layer, end_layer, paper_stat, thresh_err, dataset_type, mean_pred);

      // free resources.  LUTs.
      {
         int k;
         st_table *st_lut;
         arrayForEachItem(st_table *, arr_LUT, k, st_lut ) {
            int *cur_point1;
            st_generator *gen;
            vector<int> *status;
            st_foreach_item(st_lut, gen, (char **) &cur_point1, (char **)&status) {
               delete status;
            }
            st_free_table(st_lut);
         }
		 array_free(arr_LUT);
      }

      // reset the image size globablly
      image_height = im_h;
      image_width  = im_w;
   
   }

   fprintf(fd_paper,"%s - PAPER RESULT -  AVERAGE ERROR: [%.3f] TOTAL FACES: [%f] VARIANCE: [%f]\n", gbl_opts->output_prefix, paper_stat[0], paper_stat[2], paper_stat[3]);
   fclose(fd_paper);
   
   // free resources.  z_arr, end_points, arr_height, arr_boundaries

}



// Function: compute_error_for_IR
//
// Compute the error for a model in IR
//
// command: project.exe -D "model file" -O "-s <N> -r <range> -f <face_width> -p <path> -w -h -P <texture_image save folder>"
// Algorithm:
//    The idea is to compute a LUT based on IR. This LUT is for each pixel in the image of the same height,
//    which point on the line segment will reach it earliest based on dilation processing.
//    Then, for each 3D point, we can get the corresponding LUT point and distance (in terms of pixel, do not
//    use the math distance from point to line) and map them into texture image.
void compute_error_for_IR(char *fn)
{
   char *path_str = "result/error_comp/debug_errors";
   char *opt_backup = strdup(global_opts);
   char *load_fn = "../data/Rotated.bpa";
   gbl_opts->output_prefix = "result/error_comp";
   gbl_opts->KSD_ratio = 1.0;
   int  frame_num = 1000;
   int  face_width = 5;
   int  search_range = 40;
   int  im_w = 1024;
   int  im_h = 392;
   int  ignore_taper = 1;

   int approach = 3;   // layer based for default with faces

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "a:e:m:r:s:f:L:w:tT:h:p:P:")) != EOF)
      {
         switch (c) {
            case 'e':
            case 'm':
               break;
            case 'a':
               approach = atoi(util_optarg);
               break;
            case 's':
               frame_num = atoi(util_optarg);
               break;
            case 'r':
               search_range = atoi(util_optarg);
               break;
            case 'p':
               path_str = strdup(util_optarg);
               break;
            case 'P':
               gbl_opts->output_prefix = strdup(util_optarg);
               break;
            case 'L':
               load_fn = strdup(util_optarg);
               break;
            case 'f':
               face_width = atoi(util_optarg);
               break;
            case 't':
               ignore_taper = 0;
               break;
            case 'w':
               im_w = atoi(util_optarg);
               break;
            case 'h':
               im_h = atoi(util_optarg);
               break;
            case 'T':
               gbl_opts->KSD_ratio = atof(util_optarg);
               break;
            default:
               printf("Error: No option for this command!\n");
               break;
         }
      }
   }
   
   if (global_opts)
      free(global_opts);
   global_opts = strdup(opt_backup);

   if ( approach == 0 )  // Grey scale implementation, not accurate 
      compute_error_for_IR_grey(fn);
   else if ( approach == 1) // Face based, generate two many image and too many texture mapping operations.
      compute_error_for_IR_face_based(fn);
   else if ( approach == 2) // For each layer, generate a wide image.
      compute_error_for_IR_layer_based(fn);
   else if ( approach == 3) // For each layer, generate a wide image, combined with face based method.
      compute_error_for_IR_layer_based_with_faces(fn);
}



#if 1  // use points to constuct face, and extrusion to construct the layers.
// Function: generate_skp_from_IR  
//
// generate the SketchUp script file from IR
//
// command: project.exe -C "file name"
void generate_skp_from_IR(char *fn)
{
   int  samples_num = 1000;
   int  frame_num = 200;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "n:s:")) != EOF)
      {
         switch (c) {
            case 's':
               samples_num = atoi(util_optarg);
               break;
            case 'n':
               frame_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }
               
   FILE *fd = fopen("building.rb", "w");
   assert(fd);

   // write some head info in the ruby script
   fprintf(fd, "require 'sketchup'\n");
   fprintf(fd, "def draw_building\n");
   fprintf(fd, "   model = Sketchup.active_model\n");
   fprintf(fd, "   entities = model.entities\n");
   fprintf(fd, "   pts = []\n");
   

   int  line_no = 20;
   //float depth_bottom = 0;
   float z_scaler = 15.604761;
   float depth_bottom = -2.116044 * z_scaler;
   //float depth_top    = 43.216660;
   float depth_top    = 30.216660 * z_scaler;
   //float depth_top    = 1000;
   float depth_inter  = (depth_top - depth_bottom);

   char *color_str[] = {"red", "blue", "green"};
   int color_idx = 0;
   array_t *z_arr = array_alloc(vector<float> *, 0);
   const char *ir_fn = strcmp(fn, "") == 0 ? "rep.txt" : fn;
   array_t *end_points_arr = load_end_points_from_IR(ir_fn, z_arr);
   assert(array_n(end_points_arr) == array_n(z_arr));
   int k, bnd_index = 0;
   array_t *end_points;
   int gbl_cc = 0;
   arrayForEachItem(array_t *, end_points_arr, k, end_points) {
      fprintf(fd, "   i = 0\n");
      vector<int> line_set;
      vector<float> *z_v = array_fetch(vector<float> *, z_arr, k);
      float bottom_z = depth_bottom + (*z_v)[0]*depth_inter;
      float top_z = depth_bottom + (*z_v)[1]*depth_inter;
      int unit_type = (*z_v)[2] == 0.0 ? 0 : 1;  // 0: extruded, 1: tapered.

      fprintf(fd, "      UI.messagebox \"starting creating layer%d, face%d\" \n", k, gbl_cc);
      
      // if end_points could not construct a face, ignore
      if ( array_n(end_points) < 3 )
         continue;
      
      // temp code for test
      if (unit_type == 1)
         continue;
      
      color_idx = k % 3;
      int count_pt = 0, count_pt_ = 0, count_edge = 0;
      vector<float> point1, point2;
      int i;
      vector<int> *end_pts;
      arrayForEachItem(vector<int> *, end_points, i, end_pts) {      
         //load_lines_from_end_points(end_points, line_set, i, frame_num, z_arr);

         int idx = 0;
         {
            float x1 = ((*end_pts)[idx]   );//+ 316.971701) ;// 15.604761;
            float y1 = ((*end_pts)[idx+1] );//+ 340.620716) ;// 15.604761;

            fprintf(fd, "   pts[%d] = Geom::Point3d.new(%f, %f, %f)\n", count_pt_, x1, y1, bottom_z);
            count_pt_ ++;

            // make sure we have at least 3 distinguished points to construct a face.
            if (count_edge == 0) {
               point1.push_back(x1);
               point1.push_back(y1);
               count_edge ++;
            } else if (count_edge == 1) {
               if (x1 != point1[0] || y1 != point1[1] ) {
                  point2.push_back(x1);
                  point2.push_back(y1);
                  count_edge ++;
               }
            } else if (count_edge == 2 ) {
               if ( (x1 != point1[0] || y1 != point1[1]) &&
                    (x1 != point2[0] || y1 != point2[1])) {
                  count_edge ++;
               }
            }
         }
      }

      // if end_points could not construct a face, ignore
      if (count_edge < 3) {
         fprintf(fd, "   pts.clear\n");
         continue;
      }
      
      fprintf(fd, "   face%d = entities.add_face pts\n", gbl_cc);
      fprintf(fd, "   if (face%d)\n", gbl_cc);
      //fprintf(fd, "      face%d.back_material = \"%s\"\n", gbl_cc, color_str[color_idx]);
      //fprintf(fd, "      face%d.material = \"%s\"\n", gbl_cc, color_str[color_idx]);
      //fprintf(fd, "      UI.messagebox \"Successfully creating face%d\" \n", gbl_cc);
      fprintf(fd, "      face%d.pushpull %f\n", gbl_cc, (top_z - bottom_z));
      fprintf(fd, "   else\n");
      fprintf(fd, "      msg = sprintf(\"Failure on creating face%d, i is %%d\", i) \n", gbl_cc);
      fprintf(fd, "      UI.messagebox msg \n");
      fprintf(fd, "   end\n");
      fprintf(fd, "   pts.clear\n");
      gbl_cc ++;
   }

   fprintf(fd, "   model.start_operation \"Building\"\n");
   fprintf(fd, "   model.commit_operation\n");
   fprintf(fd, "end # def draw_building\n");
   fprintf(fd, "UI.menu(\"PlugIns\").add_item(\"Draw Building\") { draw_building }\n");

   fclose(fd);
   
}

#else
// Function: generate_skp_from_IR
//
// generate the SketchUp script file from IR
//
// command: project.exe -C "file name"
void generate_skp_from_IR(char *fn)
{
   int  samples_num = 1000;
   int  frame_num = 200;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "n:s:")) != EOF)
      {
         switch (c) {
            case 's':
               samples_num = atoi(util_optarg);
               break;
            case 'n':
               frame_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }
               
   FILE *fd = fopen("building.rb", "w");
   assert(fd);

   // write some head info in the ruby script
   fprintf(fd, "require 'sketchup'\n");
   fprintf(fd, "def draw_building\n");
   fprintf(fd, "   model = Sketchup.active_model\n");
   fprintf(fd, "   entities = model.entities\n");
   fprintf(fd, "   edges = []\n");
   

   int  line_no = 20;
   //float depth_bottom = 0;
   float z_scaler = 15.604761;
   float depth_bottom = -2.116044 * z_scaler;
   //float depth_top    = 43.216660;
   float depth_top    = 30.216660 * z_scaler;
   //float depth_top    = 1000;
   float depth_inter  = (depth_top - depth_bottom);

   char *color_str[] = {"red", "blue", "green"};
   int color_idx = 0;
   array_t *z_arr = array_alloc(vector<float> *, 0);
   const char *ir_fn = strcmp(fn, "") == 0 ? "rep.txt" : fn;
   array_t *end_points_arr = load_end_points_from_IR(ir_fn, z_arr);
   assert(array_n(end_points_arr) == array_n(z_arr));
   int k, bnd_index = 0;
   array_t *end_points;
   int gbl_cc = 0;
   arrayForEachItem(array_t *, end_points_arr, k, end_points) {
      fprintf(fd, "   i = 0\n");
      vector<int> line_set;
      vector<float> *z_v = array_fetch(vector<float> *, z_arr, k);
      float bottom_z = depth_bottom + (*z_v)[0]*depth_inter;
      float top_z = depth_bottom + (*z_v)[1]*depth_inter;

      fprintf(fd, "      UI.messagebox \"starting creating layer%d\" \n", k);
      color_idx = k % 3;
      int count_pt = 0, count_pt_ = 0, count_edg = 0;
      int i;
      vector<int> *end_pts;
      arrayForEachItem(vector<int> *, end_points, i, end_pts) {      
         //load_lines_from_end_points(end_points, line_set, i, frame_num, z_arr);

         int idx = 0;
         {
            float x1 = ((*end_pts)[idx]   );//+ 316.971701) ;// 15.604761;
            float y1 = ((*end_pts)[idx+1] );//+ 340.620716) ;// 15.604761;
            float x2 = ((*end_pts)[idx+2] );//+ 316.971701) ;// 15.604761;
            float y2 = ((*end_pts)[idx+3] );//+ 340.620716) ;// 15.604761;

            fprintf(fd, "   pt%d_ = Geom::Point3d.new(%f, %f, %f)\n", count_pt_, x1, y1, bottom_z);
            fprintf(fd, "   pt%d  = Geom::Point3d.new(%f, %f, %f)\n", count_pt , x2, y2, top_z);
            fprintf(fd, "   if ( pt%d_ != pt%d )\n", count_pt_, count_pt);
            fprintf(fd, "      edges[i] = entities.add_line(pt%d_, pt%d)\n", count_pt_, count_pt);
            fprintf(fd, "      i = i + 1\n");
            fprintf(fd, "   end\n");
            if ( i > 0 ) {
               fprintf(fd, "   if ( pt%d_ != pt%d_ ) \n", count_pt_, count_pt_-1);
               fprintf(fd, "      edges[i] = entities.add_line(pt%d_, pt%d_)\n", count_pt_, count_pt_-1);
               fprintf(fd, "      i = i + 1\n");
               fprintf(fd, "   end\n");
               fprintf(fd, "   if ( pt%d != pt%d ) \n", count_pt, count_pt-1);
               fprintf(fd, "      edges[i] = entities.add_line(pt%d, pt%d)\n", count_pt, count_pt-1);
               fprintf(fd, "      i = i + 1\n");
               fprintf(fd, "   end\n");
               fprintf(fd, "   face%d = entities.add_face edges\n", gbl_cc);
               fprintf(fd, "   if (face%d)\n", gbl_cc);
               fprintf(fd, "      face%d.back_material = \"%s\"\n", gbl_cc, color_str[color_idx]);
               fprintf(fd, "      face%d.material = \"%s\"\n", gbl_cc, color_str[color_idx]);
               //fprintf(fd, "   else\n");
               // fprintf(fd, "      msg = sprintf(\"Failure on creating face%d, i is %%d\", i) \n", gbl_cc);
               //fprintf(fd, "      UI.messagebox msg \n");
               fprintf(fd, "   end\n");
               fprintf(fd, "   edges_temp = edges[1]\n");
               fprintf(fd, "   edges.clear\n");
               fprintf(fd, "   edges[0] = edges_temp\n");
               fprintf(fd, "   i = 1\n");
               count_edg = 1;
               gbl_cc ++;
            }
            
            count_pt_ ++;
            count_pt ++;
         }
      }
   }

   fprintf(fd, "   model.start_operation \"Building\"\n");
   fprintf(fd, "   model.commit_operation\n");
   fprintf(fd, "end # def draw_building\n");
   fprintf(fd, "UI.menu(\"PlugIns\").add_item(\"Draw Building\") { draw_building }\n");

   fclose(fd);
   
}

#endif

// Function: generate_dxf_from_IR
//
// generate the dxf file from IR
//
// command: project.exe -I "file name"
void generate_dxf_from_IR(char *fn)
{
   int  samples_num = 1000;
   int  frame_num = 200;

   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "n:s:")) != EOF)
      {
         switch (c) {
            case 's':
               samples_num = atoi(util_optarg);
               break;
            case 'n':
               frame_num = atoi(util_optarg);
               break;
            default:
               break;
         }
      }
   }
               
   FILE *fd = copy_dxf_head("IR.dxf");
   assert(fd);

   int  line_no = 20;
   float depth_bottom = -2.116044;
   //float depth_top    = 43.216660;
   float depth_top    = 30.216660;
   float depth_inter  = (depth_top - depth_bottom) / frame_num;
   float depth = depth_bottom;

   array_t *z_arr = array_alloc(vector<float> *, 0);
   const char *ir_fn = strcmp(fn, "") == 0 ? "rep.txt" : fn;
   array_t *end_points = load_end_points_from_IR(ir_fn, z_arr);
   assert(array_n(end_points) == array_n(z_arr));
   for (int i = 0 ; i < frame_num; i ++)
   {
      vector<int> line_set;
      load_lines_from_end_points(end_points, line_set, i, frame_num, z_arr);
      for (int k = 0; k < line_set.size(); k+=4)
      {
         float x1 = (line_set[k]   + 316.971701) / 15.604761;
         float y1 = (line_set[k+1] + 340.620716) / 15.604761;
         float x2 = (line_set[k+2] + 316.971701) / 15.604761;
         float y2 = (line_set[k+3] + 340.620716) / 15.604761;
         fprintf(fd, "\nLINE\n");
         fprintf(fd, "5\n%d\n8\n0\n",line_no);
         fprintf(fd, "10\n%f\n20\n%f\n30\n%f\n", x1, y1, depth);
         fprintf(fd, "11\n%f\n21\n%f\n31\n%f\n", x2, y2, depth);
         fprintf(fd, "0");
         line_no ++;
      }

      depth += depth_inter;
   }

   fprintf(fd, "\nENDSEC\n0\nEOF\n");
   fclose(fd);
   
}

// Function: integrate_images
// Helper function to integrate sliced image for ACCV 2009
//
// Usage:
// project -J -O "-r result/point_cloud_process_1000/slices_1000_1024_392_bottom_up/image_slice -w Main/Paper/ACCV/figures/image_slice -s 940 -e 951"
void integrate_images()
{
   int start_id = 0;
   int end_id = 0;
   char *read_path  = NULL;
   char *write_path = NULL;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "s:e:r:w:")) != EOF)
      {
         switch (c) {
            case 's':
               start_id = atoi(util_optarg);
               break;
            case 'e':
               end_id = atoi(util_optarg);
               break;
            case 'r':
               read_path = strdup(util_optarg);
               break;
            case 'w':
               write_path = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(end_id > start_id);
   assert(read_path);
   assert(write_path);

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   char *fn_ext;
   {
      char fn[1000];
      sprintf(fn, "%s_0100.tif", read_path);
      if ( !file_exist(fn) ) {
         fn_ext = strdup("png");
      } else {
         fn_ext = strdup("tif");
      }
   }
   
   char fn[1000];
   BYTE **cur_im, **int_im;
   int h, w;
   for (int i = start_id; i < end_id; i++ ) {
      char *ds = digit_string(4, i);
      sprintf(fn, "%s_%s.%s", read_path, ds, fn_ext);
      free(ds);
      printf("Integrating %s ...\n", fn);
      
      orig_img = load_image(fn, h, w);
      set_image(cur_im, orig_img);

      if ( i == start_id ) {
         int_im = cur_im;
      } else {
         for (int k = 0; k < h*w; k ++ )
            int_im[0][k] |= cur_im[0][k];
         free_image(cur_im);
      }

      delete orig_img;
   }

   // write out the image
   char *ds = digit_string(4, start_id);
   char *ds2 = digit_string(4, end_id);
   sprintf(fn, "%s_%s_%s.png", write_path, ds, ds2);
   free(ds);
   free(ds2);
   Save2File(fn, int_im, NULL, w, h, 0, NULL);
}

// Function: noise_removal_by_mask
// Remove noise based on mask images
//
// Usage:
// project -M -O "-r result/point_cloud_interior_1000/slices_1000_640_800_bottom_up/image_slice -w result/point_cloud_interior_1000/slices_1000_640_800_bottom_up_clear/image_slice -m result/point_cloud_interior_1000/slices_1000_640_800_bottom_up_masks -s 0 -e 1000"
void noise_removal_by_mask()
{
   int start_id = 0;
   int end_id = 0;
   char *read_path  = NULL;
   char *write_path = NULL;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "s:e:r:w:m:")) != EOF)
      {
         switch (c) {
            case 's':
               start_id = atoi(util_optarg);
               break;
            case 'e':
               end_id = atoi(util_optarg);
               break;
            case 'r':
               read_path = strdup(util_optarg);
               break;
            case 'w':
               write_path = strdup(util_optarg);
               break;
            case 'm':
               gbl_opts->BBM_mask_folder = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(end_id > start_id);
   assert(read_path);
   assert(write_path);
   assert(gbl_opts->BBM_mask_folder);

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   char in_fn[1000];
   char ou_fn[1000];
   int w, h;
   BYTE **cur_im;
   for ( int i = start_id; i < end_id; i ++ )
   {
      char *ds = digit_string(4, i);
      sprintf(in_fn, "%s_%s.png", read_path, ds);
      sprintf(ou_fn, "%s_%s.png", write_path, ds);
      free(ds);

      orig_img = load_image(in_fn, h, w);
      set_image(cur_im, orig_img);
      clear_slices_using_mask(cur_im, i);
      Save2File(ou_fn, cur_im, NULL, w, h, 0, NULL);

      // memory free
      delete orig_img;
      free_image(cur_im);
   }
      
}


// Function: UsagePrint
// Helper function to print out the parameters
//
void UsagePrint(char *name)
{
   printf(" \n \
Usage: %s \n \
          -B <file>    : use Ball-Pivot Algorithm to detect boundary.\n \
          -b           : do the boundary matching to find the clusters. \n \
          -d <file>    : use DP algorithm.\n \
          -e epsilon   : specify the epsilon value.\n \
          -h           : print out this message. \n \
          -H <file>    : do the hough transform. \n \
          -i           : generate iv format from bpa data file.\n \
          -o <file>    : specify the output file name.\n \
          -O \"opts\"    : specify more options.\n \
          -p <file>    : do the preprocess with alogrithm 2\n \
          -P <file>    : do the preprocess with alogrithm 1\n \
          -1           : do the data recover and symmetry line based on stratgy 1\n \
          -S           : system-like batch processing. \n \
          -R           : generate dxf file from ras2vec output. \n \
          -s \"Params\"  : generate dxf file for Google Sketchup. \n \
          -t <file>    : output test data to file for DP algorithm.\n \
          -x <file>    : generate tif image from the line segments. \n \
          -2 <file>    : placehold for argment 2 \n \
          -3 <file>    : do the preprocess with alogrithm 3\n \
          -4 <file>    : do the preprocess with alogrithm 4 - tiled based divide and conquer\n \
         \n", name);
}


void compute_line()
{
   FILE *fd = fopen(gbl_opts->input_prefix, "r");
   char line[1000];
   float a, b, c, x, y, z;
   float max_long = 0.0;
   int line_no = 0;

   assert(fd);
   while (fgets(line, 1000, fd) ) {
      line_no ++;
      if ( line[0] == 'l' ) {
         if ( sscanf(line, "l %f %f %f %f %f %f", &a, &b, &c, &x, &y, &z) ) {
            float tmp = sqrt((a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z));
            if (tmp > max_long) {
               max_long = tmp;
               printf("LONGER: [%d] - %f\n", line_no, max_long);
            }
         }
      }
   }
   
   fclose(fd);
}

// Function: compute_trans
// Transform the data to be rectified
//
// command: project -n -F ShepardHall_50th.ptx -f ShepardHall_trans.ptx -O "-s 0"
void compute_trans(char *trans_fn = NULL)
{
   FILE *fd_in = fopen(gbl_opts->input_prefix, "r");
   FILE *fd_out = fopen(gbl_opts->output_prefix, "w");
   char line[1000];
   float a, b, c, x, y, z;
   float max_long = 0.0;
   int line_no = 0;

   assert(fd_in);
   assert(fd_out);

   // good float M[] = { -0.7679,0.0164,0.6406,0.2781,0.9019,0.3222,0.5772,-0.4319,0.6970};
   //float M[] = { -0.7679,0.0164,0.6406,0.2781,0.9019,0.3222,0.5772,-0.4319,0.6970};
   //float M[] = {-0.8471,-0.0026,-0.5337,-0.2271,-0.9018,0.3695,-0.4823,0.4346,0.7634};
   float M[12];

   if (1)
   {
      char *tr_fn = trans_fn ? trans_fn : strdup("trans.txt");
      FILE *fd = fopen(tr_fn, "r");
      assert(fd);
      char str[10000];
      float a, b, c, x, y, z;
      int i = 0;
      while (fgets(str, 10000, fd))
      {
         assert(sscanf(str, "%f %f %f",&M[i],&M[i+1],&M[i+2]) == 3);
         i += 3;
      }
      assert(i == 9);
      fclose(fd);
   }
   

   while (fgets(line, 1000, fd_in) ) {
      line_no ++;
      {
         assert ( sscanf(line, "%f %f %f", &a, &b, &c)  == 3);
         {
            float p1 = a*M[0] + b*M[3] + c*M[6];
            float p2 = a*M[1] + b*M[4] + c*M[7];
            float p3 = a*M[2] + b*M[5] + c*M[8];
            fprintf(fd_out, "%f %f %f\n", p1, p2, p3);
         }
      }
   }
   
   fclose(fd_in);
   fclose(fd_out);
}

typedef struct _line_info {
   float max_x1;
   float max_y1;
   float max_z1;
   float max_x2;
   float max_y2;
   float max_z2;
   float ave_x;
   float ave_y;
   float ave_z;
   float sum_x;
   float sum_y;
   float sum_z;
   float is_filled;
   float total;
   float max_len;
}LINE_INFO;

// Function: compute_axis
// Cluster the axis.
//
// command: project -n -F ShepardHall_50th -O "-s 1"
void compute_axis(int bin_size = 0)
{
   FILE *fd_all = fopen(gbl_opts->input_prefix, "r");
   char line[1000];
   float a, b, c, x, y, z;
   float max_long = 0.0;
   int line_no = 0;
   static int CANDIDATE_LEN = bin_size ? bin_size : 30;
   LINE_INFO *cands = (LINE_INFO *)malloc(CANDIDATE_LEN*sizeof(LINE_INFO));
   float M[4][4];

   assert(fd_all);

#ifdef LINUX
   int total_lines = 0;
   while (fgets(line, 1000, fd_all) ) { // This is the file containing the files;
      line[strlen(line)-1] = '\0';
      char *full_fn = strdup(line);
      char *new_ptr = index(line, '/');
      char *path = line;
      char *fn = new_ptr+1;
      *new_ptr = '\0';
      // printf("Path is %s, and file name is %s\n", path, fn); // OK

      // let's first get transform info
      // get the transform file name. If it is not existed, continue;
      char *template_path = strdup(path);
      char *template_fn = strdup(fn);
      char *post_fix = index(template_fn, '.');
      *post_fix = '\0';
      post_fix = index(template_path, '_');
      *post_fix = '\0';
      char trans_fn[1000];
      sprintf(trans_fn, "%s_trans/%s.trans", template_path, template_fn+2);
      if (file_exist(trans_fn) == NULL) {
         printf("File %s is not existed, ignore %s\n", trans_fn, fn);
         continue;
      }

      {
         FILE *fd = fopen(trans_fn, "r");
         char str[10000];
         float a, b, c, x, y, z;
         int i = 0;
         while (fgets(str, 10000, fd))
         {
            assert(sscanf(str, "%f %f %f",&M[i][0],&M[i][1],&M[i][2]) == 3);
            i ++;
         }
         assert(i == 4);
         fclose(fd);
      }

      

      // compute the lines in the BLxxx.linesp, and RAxxx.linesp
      // compute the average, # of lines, and the longest line.
      FILE *fd = fopen(full_fn, "r");
      char str[10000];
      float a, b, c, x, y, z;
      while (fgets(str, 10000, fd))
      {
         if ( fn[0] == 'B' ) {
            assert(fn[1] == 'L');
            if (str[0] == 'l') {
               assert(sscanf(str, "l %f %f %f %f %f %f", &a, &b, &c, &x, &y, &z) == 6);
            } else {
               continue; // for "p ...." let's ignore
            }
         } else {
            assert(fn[0] == 'R' && fn[1] == 'A');
            assert(sscanf(str, "%f %f %f %f %f %f", &a, &b, &c, &x, &y, &z) == 6);
         }

         // let's transform the points
         {
            float u, v, w;
            u = a*M[0][0]+b*M[1][0]+c*M[2][0]+M[3][0];
            v = a*M[0][1]+b*M[1][1]+c*M[2][1]+M[3][1];
            w = a*M[0][2]+b*M[1][2]+c*M[2][2]+M[3][2];
            a = u;
            b = v;
            c = w;
            u = x*M[0][0]+y*M[1][0]+z*M[2][0]+M[3][0];
            v = x*M[0][1]+y*M[1][1]+z*M[2][1]+M[3][1];
            w = x*M[0][2]+y*M[1][2]+z*M[2][2]+M[3][2];
            x = u;
            y = v;
            z = w;
         }

         total_lines++;
         // now let's compute the vector and related info
         float diff_x = x - a;
         float diff_y = y - b;
         float diff_z = z - c;
         
         float line_len = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z );

         float n_d_x = diff_x/line_len;
         float n_d_y = diff_y/line_len;
         float n_d_z = diff_z/line_len;

         float unit_len = n_d_x*n_d_x + n_d_y*n_d_y + n_d_z*n_d_z;
         assert(unit_len < 1.1 && unit_len > 0.9);

         int cand_index = 0;
         float min_dis = 10000.0;
         int i;
         int sign = 1;
         for ( i = 0 ; i < CANDIDATE_LEN ; i ++ ) {
            if ( i == 0 && cands[i].is_filled == 0 ) {
               cands[i].max_x1 = a;
               cands[i].max_y1 = b;
               cands[i].max_z1 = c;
               cands[i].max_x2 = x;
               cands[i].max_y2 = y;
               cands[i].max_z2 = z;
               cands[i].ave_x = n_d_x;
               cands[i].ave_y = n_d_y;
               cands[i].ave_z = n_d_z;
               cands[i].sum_x = n_d_x;
               cands[i].sum_y = n_d_y;
               cands[i].sum_z = n_d_z;
               cands[i].is_filled = 1;
               cands[i].total = 1;
               cands[i].max_len = line_len;
               break;
            }

            if ( cands[i].is_filled ) {
               float d_x = n_d_x - cands[i].ave_x;
               float d_y = n_d_y - cands[i].ave_y;
               float d_z = n_d_z - cands[i].ave_z;
               float dis1 = sqrt(d_x*d_x + d_y*d_y + d_z*d_z);
               d_x = -n_d_x - cands[i].ave_x;
               d_y = -n_d_y - cands[i].ave_y;
               d_z = -n_d_z - cands[i].ave_z;
               float dis2 = sqrt(d_x*d_x + d_y*d_y + d_z*d_z);
               float dis = min(dis1, dis2);
               if ( dis < min_dis ) {
                  min_dis = dis;
                  cand_index = i;
                  if ( dis1 > dis2 )
                     sign = -1;
                  else
                     sign = 1;
               }
            }

            if ( cands[i].is_filled == 0 )
               break;
         }
         if ( min_dis < 0.15 ) { // find it
            i = cand_index;
            cands[i].sum_x += sign*n_d_x;
            cands[i].sum_y += sign*n_d_y;
            cands[i].sum_z += sign*n_d_z;
            cands[i].total ++;
            cands[i].ave_x = cands[i].sum_x/cands[i].total;
            cands[i].ave_y = cands[i].sum_y/cands[i].total;
            cands[i].ave_z = cands[i].sum_z/cands[i].total;
            if ( line_len > cands[i].max_len ) {
               cands[i].max_x1 = a;
               cands[i].max_y1 = b;
               cands[i].max_z1 = c;
               cands[i].max_x2 = x;
               cands[i].max_y2 = y;
               cands[i].max_z2 = z;
               cands[i].max_len = line_len;
            }
            
         } else if ( min_dis < 5.0 && i < CANDIDATE_LEN)
         {
            assert(cands[i].is_filled == 0);
            cands[i].max_x1 = a;
            cands[i].max_y1 = b;
            cands[i].max_z1 = c;
            cands[i].max_x2 = x;
            cands[i].max_y2 = y;
            cands[i].max_z2 = z;
            cands[i].ave_x = n_d_x;
            cands[i].ave_y = n_d_y;
            cands[i].ave_z = n_d_z;
            cands[i].sum_x = n_d_x;
            cands[i].sum_y = n_d_y;
            cands[i].sum_z = n_d_z;
            cands[i].is_filled = 1;
            cands[i].total = 1;
            cands[i].max_len = line_len;
         }

      }

      printf("Complete file %s...\n", fn);
      
                
   }

   // let's show the results
   {
      int max_total = -1;
      int bin_num = 0;
      bool found = true;
      map<int, int> map_counted;
      int i_index = 0;
      while ( found ) {

         found = false;

         int found_id = 0;
         max_total = -1;
         for (int i = 0 ; i < CANDIDATE_LEN ; i ++ ) {
            if ( cands[i].is_filled && map_counted.find(i) == map_counted.end() ) {
               if (cands[i].total > max_total ) {
                  found = true;
                  max_total = cands[i].total;
                  found_id = i;
               }
            }
         }

         if ( found ) 
         {
            int i = found_id;
            map_counted[i] = 1;
            
            bin_num += cands[i].total;
            printf("Axis %d: #L: %3.0f, x: %f, y: %f, z: %f, P1: [%f %f %f], P2: [%f %f %f]\n", ++i_index, 
                   cands[i].total,
                   cands[i].ave_x,
                   cands[i].ave_y,
                   cands[i].ave_z,
                   cands[i].max_x1,
                   cands[i].max_y1,
                   cands[i].max_z1,
                   cands[i].max_x2,
                   cands[i].max_y2,
                   cands[i].max_z2);
            
         }
      }
      printf("Total lines is %d, %d is filled.\n", total_lines, bin_num);
   }

#else
   printf("Currently, only run this on LINUX machine because of function index()\n");
   assert(0);
#endif   
   
   fclose(fd_all);
}

// Function: sanity_check
// do the sanity check
// project -N <1,2> -F "IR.txt"
// N: 1 - integer, 2 - float
void sanity_check(int type)
{
   // check whether there is duplicate points or not;
   array_t *z_arr = array_alloc(vector<float> *, 0);
   array_t *end_points;

   type -=  1;
   if ( type == 0 ) {
      end_points = load_end_points_from_IR(gbl_opts->input_prefix, z_arr);
   } else if ( type == 1 ) {
      end_points = load_end_points_from_IR_with_dirs(gbl_opts->input_prefix, z_arr);
   }
   
   // assert(array_n(end_points) == array_n(z_arr));

   int k;
   array_t *arr_pts;
   bool found = false;
   arrayForEachItem(array_t *, end_points, k, arr_pts) 
   {

      st_table *st_pts = st_init_table(strcmp, st_strhash);
      
      int l = 0;

      while ( l < array_n(arr_pts) )
      {

         if ( l == array_n(arr_pts) - 1 )
            break;


         char str[1000];

         if ( type == 1 ) {
            vector<float> *pts = array_fetch(vector<float> *, arr_pts, l );
            float a = pts->at(0);
            float b = pts->at(1);

            int num_col = 3;
            if ( num_col == 2) {
               sprintf(str, "%f %f", a, b);
            } else {
               float c = pts->at(2);
               sprintf(str, "%f %f %f", a, b, c);
            }
            
         } else if ( type == 0 ) {
            vector<int> *pts = array_fetch(vector<int> *, arr_pts, l );
            int a = pts->at(0);
            int b = pts->at(1);
            sprintf(str, "%d %d", a, b);
         }
         
         if ( st_is_member(st_pts, str)) {
            found = true;
            printf("point [%s] duplicated!\n", str);
         } else {
            st_insert(st_pts, (char *)strdup(str), (char *) 0);
         }

         l ++;
         
      }

      st_generator *stGen;
      char *str_pt;
      st_foreach_item(st_pts, stGen, (char **)&str_pt, (char **)NULL) {
         free(str_pt);
      }
      st_free_table(st_pts);
   }

   if ( !found) {
      printf("Dataset is ok!\n");
   }
}


// Function: rectify_scans
// Rectify the dataset
//
// To do the rectification:
// 1. [\ls CooperUnion_lines/* > CooperUnion_50th]: this is to obtain the file list of lines.
// 2. [project -n -F ShepardHall_50th -O "-s 1 -b 100"]: this is to obtain the major axis.
// 3. to check the correctness of the major axis, do this following:
//     *. put the longest line points into CooperUnion_50th.iv (red, green, blue)
//     *. use DrawStyle{ style LINES; lineWidth 5 }, refer to src/result/LinesOnly/ShepardHall_50th.iv
// 4. put the vertical line in the middle, construct the M = [r1, r2, r3]:
//     r1: the horizontal line
//     r2: the vertical line
//     r3: CROSS(r1, r2) or CROSS(r2, r1);
//     MM = inv(M);
//     if the vertical direction is wrong, r2=-r2, do it again to get MM.
//     put MM into say trans.txt
// 4.xxx
//    actually, we do not need vertical line - just pick up two major lines perperticular to each other.
//    make them unit vector by r=r/sqrt(r*r'), where r = p1 - p0 (end points of the lines).
//    make r3 = CROSS(r1, r2), and T1 = [r1;r2;r3], T1_inv = inv(T1);
//    say another transform T2_inv to make another facades rectfied. Then, to register two set of facades,
//    use T = T1 * T2_inv; or T = T2 * T1_inv;
//    to test the correctness, try to show the points with ivview to see whether they are merged or not
//    ( wei.ptx - merge points, wei_side1.ptx, wei_side2.ptx - the two transformed points
//      new_two_sides.iv - two set of data by T1_inv and T2_inv. )
// 5. [project -n -F ShepardHall_50th.ptx -f ShepardHall_trans.ptx -O "-s 0 -p trans.txt"]
// 6. [project -j -O "-t 0 -p CooperUnion_trans.ptx -P ccc.ptx -w 111"], then ivview.
// comments: in ivview, x, y, z are corresponding to left-right, bottom-up, face-inside.
//           in SketchUp, x, y, z are r, g, b axies.
void rectify_scans()
{
   int step = 0;
   char *input_file_name = NULL;
   char *output_file_name = NULL;
   int bin_size = 0;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "s:b:p:P:")) != EOF)
      {
         switch (c) {
            case 's':
               step = atoi(util_optarg);
               break;
            case 'b':
               bin_size = atoi(util_optarg);
               break;
            case 'p':
               input_file_name = strdup(util_optarg);
               break;
            case 'P':
               output_file_name = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   //compute_line(); // compute the longest line 
   if ( step == 0 ) {
      compute_trans(input_file_name);
   } else if ( step == 1) {
      compute_axis(bin_size);
   }
      
}

void graph_cut()
{

#ifndef LINUX   
   gc_main();
#endif   
   
}

void fill_polygon(vector<int> &vec_poly, vector<int> &vec_fill)
{
   // public-domain code by Darel Rex Finley, 2007
   // http://alienryderflex.com/polygon_fill/

   int polyCorners = vec_poly.size();
   vector<int> polyY, polyX, nodeX;
   for ( int i = 0; i < polyCorners; i ++) {
      polyX.push_back(x_axis(vec_poly[i]));
      polyY.push_back(y_axis(vec_poly[i]));
   }
   
   int  nodes, pixelX, pixelY, i, j, swap ;

   int IMAGE_TOP = 0;
   int IMAGE_BOT = image_height;
   int IMAGE_LEFT = 0;
   int IMAGE_RIGHT = image_width;
   //  Loop through the rows of the image.
   for (pixelY=IMAGE_TOP; pixelY<IMAGE_BOT; pixelY++)
   {
      //  Build a list of nodes.
      nodes=0; j=0;
      nodeX.clear();
      for (i=1; i<polyCorners; i++)
      {
         if (polyY[i]<(double) pixelY && polyY[j]>=(double) pixelY ||
             polyY[j]<(double) pixelY && polyY[i]>=(double) pixelY)
         {
            nodeX.push_back((int) (polyX[i]+(pixelY-polyY[i])/(float)(polyY[j]-polyY[i])*(polyX[j]-polyX[i])));
            nodes ++;
         }

         j=i;
      }

      //  Sort the nodes, via a simple bubble sort.
      i=0;
      while (i<nodes-1)
      {
         if (nodeX[i]>nodeX[i+1])
         {
            swap=nodeX[i];
            nodeX[i]=nodeX[i+1];
            nodeX[i+1]=swap;
            if (i) i--;
         }
         else {
            i++;
         }
      }

      //  Fill the pixels between node pairs.
      for (i=0; i<nodes-1; i+=2)
      {
         if   (nodeX[i  ]>=IMAGE_RIGHT) break;
         if   (nodeX[i+1]> IMAGE_LEFT )
         {
            if (nodeX[i  ]< IMAGE_LEFT )
               nodeX[i  ]=IMAGE_LEFT ;
            if (nodeX[i+1]> IMAGE_RIGHT)
               nodeX[i+1]=IMAGE_RIGHT;
            for (j=nodeX[i]; j<nodeX[i+1]; j++)
               vec_fill.push_back(index(j, pixelY));
         }
      }
   }
   
}

// project.exe -q -F <input.ir.txt> -f <output.png.image> -W image_w -w image_h 
void load_ir_to_image()
{
   {
      // try load image from BPA points
      vector<int> all_lines;
      image_width   = gbl_opts->img_w == 0 ? 1024 : image_width;
      image_height  = gbl_opts->img_h == 0 ?  512 : image_height;
      load_lines_from_BPA_dump(all_lines, gbl_opts->input_prefix, image_height, image_width);
      write_lines_to_bw_image(gbl_opts->output_prefix, all_lines,  image_height, image_width);
   }

}

/////////////// STARTING ////////////////////////
extern void ca_load_variable_length_info(char *fn, vector<vector<int> *> &vec_segments, bool ignore_first = false);

vector<int> *vec_sort_index(vector<int> &vec_sorting)
{
   vector<int> vec_new (vec_sorting);
   sort(vec_new.begin(), vec_new.end(), greater<int> ());

   vector<int> *return_vec = new vector<int> (vec_sorting.size(), -1);
   assert(return_vec->size() == vec_sorting.size());

   for ( int i = 0; i < vec_sorting.size(); i ++ ) {
      for (int j = 0; j < vec_new.size(); j ++ ) {
         if ( vec_sorting[i] == vec_new[j] ) {
            while ( return_vec->at(j) != -1 )
               j ++;
            return_vec->at(j) = i;
            break;
         }
      }
   }

   for ( int i = 0; i < return_vec->size(); i ++ )
      assert(return_vec->at(i) != -1 );

   if ( 0 ) {
      printf("\norignal order:\n");
      for ( int i = 0; i < vec_sorting.size(); i ++ )
         printf(" %3d", vec_sorting[i]);
      printf("\nsorted order:\n");
      for ( int i = 0; i < vec_new.size(); i ++ )
         printf(" %3d", vec_new[i]);
      printf("\nindex order:\n");
      for ( int i = 0; i < return_vec->size(); i ++ )
         printf(" %3d", return_vec->at(i));
      printf("\n");
   }
   

   return return_vec;
}

void load_global_settings( FILE *fd )
{
   char str_line[1000];
   char flag[1000];
   char value[100];

   if ( fd ) {
      while (fgets(str_line, 1000, fd )) {
         if (str_line[0] == '#')
            continue;
         if (sscanf(str_line, "set %s %s", flag, value) == 2 ) {
            avl_insert(avlFlagTable, strdup(flag), strdup(value));
         }
      }
   }
}

const int aux_item_num = 21;
char *aux_items[] = {
   "ca_aux_bounding_box",
   "ca_aux_total_slices",
   "ca_aux_image_size",
   "ca_aux_is_quadrangle",           // assume quandrangle of the base geometry
   "ca_aux_HD_threshold",            // thresh for keyslices
   "ca_aux_BPA_threshold",           // thresh for BPA boundary
   "ca_aux_window_slices",           // # of slices for windows
   "ca_aux_window_ratio",            // ratio for projecting window segment
   "ca_aux_window_size",             // ???
   "ca_aux_window_depth_ratio",      // ratio for original window 3D depth
   "ca_aux_win_extrusion_reverse",   // change the extrusion direction !!!!
   "ca_aux_win_area_thresh",         // max windows ratio w.r.t. the whole image.
   "ca_aux_taper_type",              // TTL or TTP
   "ca_aux_taper_center",            
   "ca_aux_extrusion_reverse",       // change the extrusion direction !!!!
   "ca_aux_bounding_box_face1",
   "ca_aux_bounding_box_face2",
   "ca_aux_bounding_box_face3",
   "ca_aux_bounding_box_face4",
   "ca_aux_image_size_face1",
   "ca_aux_image_size_face2",
   "ca_aux_image_size_face3",
   "ca_aux_image_size_face4",
};

void ca_clear_aux_for_each_unit()
{
   char *oldValue;
   for ( int i = 0; i < aux_item_num; i ++ ) {
      //updateRunTimeFlag(aux_items[i], NULL);
      if ( avl_delete(avlFlagTable, &aux_items[i], &oldValue) )
         free(oldValue);
   }
}

void ca_write_aux_for_each_unit(char *dir, char *key, char *value)
{
   char fn[1000];
   sprintf(fn, "%s/ca_aux.txt", dir);
   FILE *fd = fopen(fn, "a");

   if ( fd ) {
      fprintf(fd, "%s %s\n", key, value);
      fclose(fd);
   } else {
      printf("Could not open file %s for writing.\n", fn);
      assert(0);
   }
}

bool ca_load_aux_for_each_unit(char *dir)
{
   ca_clear_aux_for_each_unit();

   char fn[1000];
   sprintf(fn, "%s/ca_aux.txt", dir);

   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("WARNING: Could not open file %s for writing.\n", fn);
      return false;
   }

   char str[1000];
   char key[1000], value[1000];
   while (fgets(str, 1000, fd)) {
      assert(sscanf(str, "%s %s", key, value) == 2);
      updateRunTimeFlag(key, strdup(value));
   }

   fclose(fd);

   return true;
   
}

bool ca_load_aux_top_level(char *dir)
{
   char fn[1000];
   sprintf(fn, "%s/ca_aux.txt", dir);

   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("WARNING: Could not open file %s for writing.\n", fn);
      return false;
   }

   char str[1000];
   char key[1000], value[1000];
   while (fgets(str, 1000, fd)) {
      assert(sscanf(str, "%s %s", key, value) == 2);
      updateRunTimeFlag(key, strdup(value));
   }

   fclose(fd);

   return true;
   
}

void ca_update_aux_for_each_unit(char *dir, char *key, void * params_orig, int num)
{
   ca_load_aux_for_each_unit(dir);

   char *value;
   //if ( !readRunTimeFlag(key, &value) || strcmp(value, "") == 0) {
   {
      char str_value[1000];
      if ( strncmp(key, "ca_aux_bounding_box", 16 ) == 0 ) {
         assert(num == 6);
         float *params = (float *)params_orig;
         sprintf(str_value, "%f_%f_%f_%f_%f_%f",
                 (float)params[0], (float)params[1], (float)params[2],
                 (float)params[3], (float)params[4], (float)params[5]);
      }
      else if ( strcmp(key, "ca_aux_total_slices" ) == 0 ) {
         assert(num == 1);
         int *params = (int *)params_orig;
         sprintf(str_value, "%d", (int)params[0]);
      }
      else if ( strncmp(key, "ca_aux_image_size", 10 ) == 0 ) {
         assert(num == 2);
         int *params = (int *)params_orig;
         sprintf(str_value, "%dx%d", (int)params[0], (int)params[1]);
      }
      
      updateRunTimeFlag(key, strdup(str_value));
      ca_write_aux_for_each_unit(dir, key, str_value);
   }
}

void ca_load_aux_dump_data(char *data_fn, char *folder_name)
{
   double x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
   vector<double> data_pts;
   vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
   x_min = vec_bounding_box->at(0);
   x_max = vec_bounding_box->at(1);
   y_min = vec_bounding_box->at(2);
   y_max = vec_bounding_box->at(3);
   z_min = vec_bounding_box->at(4);
   z_max = vec_bounding_box->at(5);
   diff_x = x_max - x_min;
   diff_y = y_max - y_min;

   int h, w, t;
   const int LARGE = 1024;
   float scale = diff_x /diff_y;
   if ( scale > 1 )
      scale = 1 / scale;
   scale = scale * LARGE;
   t = (int) (scale + .5);
   t += ( 8 - (t % 8));
      
   if ( diff_x > diff_y ) {
      w = LARGE;
      h = t;
   } else {
      w = t;
      h = LARGE;
   }

   {
      float *params = (float *) malloc (sizeof(float) * 6 );
      params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
      ca_update_aux_for_each_unit(folder_name, "ca_aux_bounding_box", (void *)params, 6);
      free(params);
   }

   {
      int *params = (int *) malloc (sizeof(int) * 2 );
      params[0] = w; params[1] = h;
      ca_update_aux_for_each_unit(folder_name, "ca_aux_image_size", (void *)params, 2);
      free(params);
   }
   
}

void ca_compute_merge_HT_on_BPA_result(char *bpa_fn, char *ht_out_fn)
{
   vector<int> all_lines;
   load_lines_from_BPA_dump(all_lines, bpa_fn, image_height, image_width);
   BYTE **orig_im = get_image_from_vec_lines(all_lines, image_height, image_width);

   int THRESH_CLEAR_WIDTH = 4;
   int THRESH_BPA_DIST = 4;

   printf("Merge HT on BPA result: %s \n", bpa_fn);

   char *tmp_value;
   if ( readRunTimeFlag("ca_aux_BPA_threshold", &tmp_value) ) {
      THRESH_CLEAR_WIDTH = THRESH_BPA_DIST = atoi(tmp_value);
   }
   
   // BPA to get 4 lines
   int w = image_width;
   int h = image_height;
   int pdetect;
   int tetadetect;
   vector<int> temp;      
   vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
   BYTE **Imbinary = copy_image(orig_im, h, w);
   int old_value = gbl_opts->BPA_clear_data_mask;
   gbl_opts->BPA_clear_data_mask = THRESH_CLEAR_WIDTH;
   while (true)
   {
      my_HT(Imbinary, h, w, pdetect, tetadetect);
         
      // draw line on the image
      // draw_line_on_data(pdetect, tetadetect, Imbinary, h, w, NULL, orig_im, line_set);
      HT_get_two_points(pdetect, tetadetect, h, w, Imbinary, line_set);
         
      temp = find(*Imbinary,h*w, BLACK);
      if (temp.size() == 0) break;
   }
   gbl_opts->BPA_clear_data_mask = old_value;

   // debug the HT results
   char de_fn[1000], orig_fn[1000];
   if ( 1 )
   {
      sprintf(orig_fn, "%s_after_load_result.png", bpa_fn);
      sprintf(de_fn, "%s_HT_result.png", bpa_fn);
      write_lines_to_image(de_fn, line_set, h, w);
      Save2File(orig_fn, orig_im, NULL, w, h, 0, NULL);

      sprintf(de_fn, "%s_HT_result.txt", bpa_fn);
      FILE *fd = fopen(de_fn, "w");
      assert(fd);
      for (int i = 0; i < line_set.size(); i += 4) {
         fprintf(fd, "%d %d\n", line_set[i], line_set[i+1]);
      }
      fclose(fd);

   }

   // do the replacement / substitute starting from longest matched line
   // take care of the broken cases where some lines are saparated.
   // take care of the case where the line goes through another line.

   // starting the replacing process
   // Method:
   //        for each point on bpa list, check whether it can be removed.
   
   {
      // sort the lines based on the mount of data point matched.
      // this maybe needless -- the HT has already sorted the lines somehow.
      assert(line_set.size() % 4 == 0 );

      // transform the boundary point in all_lines
      vector<int> all_points;
      map<int, int> map_bpa_pt;
      int straight_line_count = 0;
      map<int, int> map_straight_line; // used to keep straight lines
      int pre_x = -1, pre_y = -1, pre_index = -1;
      int equal_mode = -1; // 0: x; 1: y
      for (int i = 0; i < all_lines.size(); i += 4){
         int pt = index(all_lines[i], all_lines[i+1]);
         all_points.push_back(pt);
         map_bpa_pt[pt] = i / 4;

         // let's remember straight lines.
         // count consective points on a straight line.
         if ( (all_lines[i] == pre_x && equal_mode == 0 ) ||
              (all_lines[i+1] == pre_y && equal_mode == 1)) {

            if ( straight_line_count == 0 ) {
               pre_index = all_points.size() - 2;
            }
            straight_line_count ++;
         } else {
            if ( straight_line_count > 3 ) {
               assert(pre_index != -1);
               map_straight_line[pre_index] = 1;
               map_straight_line[all_points.size() - 2] = 1;
               pre_index = -1;
            }
            straight_line_count = 0;

            if ( all_lines[i] == pre_x )
               equal_mode = 0;

            if ( all_lines[i+1] == pre_y )
               equal_mode = 1;
         }
            
         pre_x = all_lines[i];
         pre_y = all_lines[i+1];
      }

      vector<int> vec_line_count(line_set.size() / 4);
      map<int, int> map_HT_pt;
      map<int, int> map_pt_multi_ln;
      vector<float> vec_line_slope;
      for ( int i = 0; i < line_set.size(); i += 4)
      {
         int x1 = line_set[i];
         int y1 = line_set[i+1];
         int x2 = line_set[i+2];
         int y2 = line_set[i+3];

         vector<int> *line_pixels = pixels_between_2_points(h, w, x1, y1, x2, y2);
         vector<int> *dila_pixels = pixels_dilation(line_pixels, THRESH_BPA_DIST); // IMPORTANT THRESHOLD for merging HT and BPA 1 -> 2
         vector<int> *matched_pixels = find(orig_im[0], dila_pixels, BLACK);

         vec_line_count[i/4] = matched_pixels->size();
         for (int k = 0; k < dila_pixels->size(); k ++ ) {
            if ( map_HT_pt.find(dila_pixels->at(k)) == map_HT_pt.end()) {
               map_HT_pt[dila_pixels->at(k)] = i/4;
            } else {
               map_pt_multi_ln[dila_pixels->at(k)] = 1;
            }
         }

         float slope = 0.0;
         if ( x2 != x1 )
            slope = (y2 - y1)/(float)(x2 - x1);
         vec_line_slope.push_back(slope);

         delete line_pixels;
         delete dila_pixels;
         delete matched_pixels;
      }
      vector<int> *vec_sort_count = vec_sort_index(vec_line_count);

      vector<int> all_points_new;
      int pt_len = all_points.size();
      int pre_pt = -1;
      for (int i = 0; i < pt_len; i ++ )
      {
         int cur_pt = all_points[i];

         // if the first point OR
         // the end points of straight lines
         if ( i == 0 ||
              map_straight_line.find(i) != map_straight_line.end() ) {
            all_points_new.push_back(cur_pt);
            pre_pt = cur_pt;
            continue;
         }
         
         int nxt_pt = all_points[(i+1)%pt_len];
         if ( map_HT_pt.find(cur_pt) != map_HT_pt.end() ) {
            float ln_slope = vec_line_slope[map_HT_pt[cur_pt]];

            float slope_cur_pre = 0.0;
            float slope_cur_nxt = 0.0;
            int x0 = x_axis(cur_pt);
            int y0 = y_axis(cur_pt);
            int xp = x_axis(pre_pt);
            int yp = y_axis(pre_pt);
            int xn = x_axis(nxt_pt);
            int yn = y_axis(nxt_pt);

            if ( x0 != xp )
               slope_cur_pre = (y0 - yp)/(float)(x0 - xp);
            if ( x0 != xn )
               slope_cur_nxt = (y0 - yn)/(float)(x0 - xn);

            ln_slope = abs(ln_slope) > 1.0 ? 1/ln_slope: ln_slope;
            slope_cur_pre = abs(slope_cur_pre) > 1.0 ? 1/slope_cur_pre: slope_cur_pre;
            slope_cur_nxt = abs(slope_cur_nxt) > 1.0 ? 1/slope_cur_nxt: slope_cur_nxt;

            if ( (map_HT_pt.find(nxt_pt) != map_HT_pt.end() &&
                  map_HT_pt[nxt_pt] == map_HT_pt[cur_pt] &&
                  abs(slope_cur_pre - ln_slope) < 0.2 &&
                  abs(slope_cur_nxt - ln_slope) < 0.2 ) ||  // if two points lie on the same line and no other line
                 (map_HT_pt[nxt_pt] == map_HT_pt[cur_pt] &&
                  map_pt_multi_ln.find(nxt_pt) == map_pt_multi_ln.end() &&
                  map_pt_multi_ln.find(cur_pt) == map_pt_multi_ln.end()) ) {
               // ignore this point
            } else {

               // TODO: here we could improve the result:
               // if a point sitting on multple lines, we should check for each line,
               // whether the above condition holds for all shared lines.

               all_points_new.push_back(cur_pt);
            }

            pre_pt = cur_pt;
               
         }
         
      }

      
      /*
      int mask = 1;
      for (int i = 0; i < vec_sort_count->size(); i ++ )
      {
         int line_index = vec_sort_count->at(i) * 4;
         int x1 = line_set[line_index];
         int y1 = line_set[line_index+1];
         int x2 = line_set[line_index+2];
         int y2 = line_set[line_index+3];
         vector<int> *line_pixels = pixels_between_2_points_in_order(h, w, x1, y1, x2, y2);

         float slope = 0.0;
         if ( x2 != x1 )
            slope = (y2 - y1)/(float)(x2 - x1);

         for (int i_p = 0; i_p < line_pixels->size(); i_p ++ )
         {
            int x0 = x_axis(line_pixels->at(i_p));
            int y0 = y_axis(line_pixels->at(i_p));

            // checking from inner to outer loop for possible matching.
            int offset = 0;
            bool found = false;
            int matched_pt = -1;
            while ( !found && offset <= mask )
            {
               for ( int x = x0 - offset; !found && x <= x0 + offset; x += 2*offset )
                  for (int y = y0 - offset; y <= y0 + offset; y ++ ) {
                     if ( map_bpa_pt.find(index(x, y)) != map_bpa_pt.end() ) {
                        found = true;
                        matched_pt = index(x, y);
                        break;
                     }
                  }

               for ( int y = y0 - offset; !found && y <= y0 + offset; y += 2*offset )
                  for (int x = x0 - offset; x <= x0 + offset; x ++ ) {
                     if ( map_bpa_pt.find(index(x, y)) != map_bpa_pt.end() ) {
                        found = true;
                        matched_pt = index(x, y);
                        break;
                     }
                  }
               
               offset ++;
            }

            // found a point
            if ( found ) {
               assert(matched_pt != -1 );
               
            }
         }
      }
      */

      {
         all_lines.clear();
         int len = all_points_new.size();
         for ( int i = 1; i <= len; i ++ ) {
            all_lines.push_back(x_axis(all_points_new[i-1]));
            all_lines.push_back(y_axis(all_points_new[i-1]));
            all_lines.push_back(x_axis(all_points_new[i%len]));
            all_lines.push_back(y_axis(all_points_new[i%len]));
         }
      }
      // show the replaced/combined image.
      {
         strncpy(de_fn, ht_out_fn, strlen(ht_out_fn) - 4);
         de_fn[strlen(ht_out_fn) - 4] = 0;
         sprintf(de_fn, "%s_combine_HT_BPA_rad.png", de_fn);
         write_lines_to_image(de_fn, all_lines, h, w, NULL);
      }
   }            


   // dump the new result
   if ( gbl_opts->BPA_dump_the_vectors )
   {
      FILE *fp = fopen(ht_out_fn, "w");
      assert(fp);

      fprintf(fp, "ImageSize %dx%d\n", image_width, image_height);
      fprintf(fp, "BEGIN POLYGON\n");
      int pre_pt = -1;
      for (int i = 0; i < all_lines.size(); i+=4)
      {
         int x0 = all_lines[i];
         int y0 = all_lines[i+1];
         int cur_pt = index(x0, y0);
         if ( pre_pt != cur_pt ) {
            fprintf(fp, "%d %d\n", x0, y0);
            pre_pt = cur_pt;
         }
      }
      fprintf(fp, "%d %d\n", all_lines[0], all_lines[1]);
      fprintf(fp, "END POLYGON\n");

      fclose(fp); // 3.24.08 found a bug, if not close, the file is empty.
      
   }
   
}


/* helper: dump vector into file

*/

void ca_dump_simple_vector(char *fn, vector<int> *vec)
{
   FILE *fd = fopen(fn, "w");
   assert(fd);

   for (int i = 0; i < vec->size(); i ++ )
   {
      fprintf(fd, "%d\n", vec->at(i));
   }

   fclose(fd);
}

/* helper: load vector into file

*/

vector<int> *ca_load_simple_vector(char *fn)
{
   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("ERROR: Could not open file %s in ca_load_simple_vector().\n", fn);
      exit(0);
   };

   vector<int> *return_vec = new vector<int> ();

   char str[1000];
   int value;
   while (fgets(str, 1000, fd) ) {
      assert(sscanf(str, "%d", &value) ==  1);
      return_vec->push_back(value);
   }

   fclose(fd);
   return return_vec;
}


bool ca_has_body()
{
   char *value;
   bool ret_value = true;
   
   if ( !readRunTimeFlag("result_segment_body_roof", &value) )
      value = "result_seg_body_roof.txt";
   
   vector<int> *vec_ledger = ca_load_simple_vector(value);
   if ( vec_ledger->size() == 0 || vec_ledger->at(0) ==  0) {
      ret_value = false;
   }

   delete vec_ledger;

   return ret_value;
}

/*
  Algorithm:

  Failed:
  1. just compare the # of data points with previoius image
     - Due to cases where roof part could also satisfied the threshold ratio.
     - Due to partial thicking, not overall ledger part.

  Tried:
  2. with 1, add a reference image which integrate all data points at certain point, say 1/3 height
     - ignore roof part if new coming image BIT_AND results less than a threshold for consective 5 slices.
  3. use Hausdorff distance mediate value as threshold. 
 */
void ca_segment_body_roof( )
{
   int ledger_return_index; // an old parameter

   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *output_fn = NULL;
   if ( !readRunTimeFlag("result_segment_body_roof", &output_fn) )
      output_fn = "result_seg_body_roof.txt";

   if ( file_exist(output_fn ) )
      return;

   printf("\n\nMODULE - ca_segment_body_roof(): \n\n");
   
   char *src_folder;
   char *dst_folder;
   char *img_prefix;
   if ( readRunTimeFlag("slices_bottom_up", &src_folder) == 0 )
      src_folder = "bottom_up";
   if ( readRunTimeFlag("result_dir_segmentation", &dst_folder) == 0 )
      dst_folder = "segmentation";
   if ( readRunTimeFlag("slice_name_prefix", &img_prefix) == 0 )
      img_prefix = "image_slice";

   float seg_ledger_min = 3.0;
   float seg_ledger_max = 8.0;
   float seg_ledger_ref = 0.3;
   if ( readRunTimeFlag("segment_ledger_ratio_min", &value) )
      seg_ledger_min = atof(value);
   if ( readRunTimeFlag("segment_ledger_ratio_max", &value) )
      seg_ledger_max = atof(value);
   if ( readRunTimeFlag("segment_ledger_ref_height", &value) )
      seg_ledger_ref = atof(value);
   
   int total_slices = 1000;
   ca_load_aux_top_level("bottom_up");
   if ( readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);

   FILE *output_fd = fopen(output_fn, "a");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }

   // create "segmentation" folder if needed.
   if ( !file_exist(dst_folder) ) {
      char cmd[1000];
      sprintf(cmd, "mkdir %s", dst_folder);
      system(cmd);
   }
   
   
   int ref_slices = (int) (total_slices * seg_ledger_ref);
      
   int h, w;
   char ou_fn[1000];
   char file_name[1000];
   BYTE **cur_im, **ref_im = NULL;
   int consective_num = 0;
   int point_num;
   int starting = 1;
   for (int i = starting; i < total_slices; i ++ )
   {
      char *ds = digit_string(4, i);
      sprintf(file_name, "%s/slices/%s_%s.png", src_folder, img_prefix, ds);
      sprintf(ou_fn, "%s/%s_%s.png", dst_folder, img_prefix, ds);
      free(ds);

      printf("Processing file %s\n", file_name);
      cur_im = load_image_array(file_name, h, w);

      // count the # of data points for ledger detection
      int points = count_image_data_points(cur_im);

      if ( i == starting ) {
         point_num = points;
         ref_im = cur_im;
         continue;
      } else if ( i < ref_slices ) {
         int len = h * w;
         for (int k = 0; k < len; k++)
            ref_im[0][k] |= cur_im[0][k];
      }
            

      float ratio = (float)points/point_num;

      if ( ratio > seg_ledger_min && ratio < seg_ledger_max ) {
         printf("\nFOUND a ledger: ratio-%.3f, index-%d\n\n", ratio, i);
         fprintf(output_fd, "%d", i);
         Save2File(ou_fn, cur_im, NULL, w, h, 0, NULL);
      }
                                                                 
      point_num = points;

      // check if we have reached roof part
      if ( i > ref_slices )
      {
         int matched_num = count_image_data_points(cur_im, ref_im);

         float match_ratio = 0.5;
         int   consective_num_thresh = 5;
         if ( readRunTimeFlag("segment_roof_to_ref_ratio", &value) )
            match_ratio = atof(value);
         if ( readRunTimeFlag("thresh_roof_consective_num", &value) )
            consective_num_thresh = atoi(value);
         
         if ( (float)matched_num/(float)points < match_ratio ) {

            consective_num ++;

            if ( consective_num > consective_num_thresh )
            {
               ledger_return_index = i - consective_num;

               printf("Roof structure reached at index %d, quitting...\n", ledger_return_index);
               sprintf(ou_fn, "%s/integrate_reference.png", dst_folder);
               Save2File(ou_fn, ref_im, NULL, w, h, 0, NULL);

               // fprintf(output_fd, "%d", ledger_return_index);
               free_image(cur_im);
               break;
            }
         } else
            consective_num = 0;
      }

      free_image(cur_im);
   }

   fclose(output_fd);
}

void ca_load_trans_matrix(char *fn, float *M)
{
   // do the transformation on the data;
   {
      FILE *fd = fopen(fn, "r");
      assert(fd);      
      int i = 0;
      char str[1000];
      while (fgets(str, 1000, fd))
      {
         assert(sscanf(str, "%f %f %f",&M[i],&M[i+1],&M[i+2]) == 3);
         i += 3;
      }
      assert(i == 9);
      fclose(fd);
   }
}

void ca_dump_trans_matrix(char *fn, float **M)
{
   {
      FILE *fd = fopen(fn, "w");
      assert(fd);      

      for (int i = 0; i < 3; i ++ )
         fprintf(fd, "%f\t%f\t%f\n", M[i][0], M[i][1], M[i][2]);
                 
      fclose(fd);
   }
}

float* ca_compute_multi_vec_matrix(float a, float b, float c, float *M)
{
   float *p = (float *) malloc (sizeof(float) * 3);
   p[0] = a*M[0] + b*M[3] + c*M[6];
   p[1] = a*M[1] + b*M[4] + c*M[7];
   p[2] = a*M[2] + b*M[5] + c*M[8];

   return p;
}


void ca_segment_body_roof_show_result ()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *output_fn = NULL;
   if ( !readRunTimeFlag("result_segment_roof_region_faces", &output_fn) )
      output_fn = "result_seg_roof_region_faces.txt";

   if ( file_exist(output_fn ) )
      return;

   if ( !readRunTimeFlag("result_segment_body_roof", &output_fn) )
      output_fn = "result_seg_body_roof.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_str[1000];
   int index = -1;
   while (fgets(index_str, 1000, output_fd ) ) {
      assert(sscanf(index_str, "%d", &index ) == 1);
      break;
   }
   fclose(output_fd);

   if ( index == -1 )
      return;
   
   printf("\n\nMODULE - ca_segment_body_roof_show_result(): \n\n");
   
   // index = 652; // for synthetic CU data
   printf("The ledger index is %d\n", index);

   // compute the height
   ca_load_aux_top_level("bottom_up");
   assert(readRunTimeFlag("box_bottom_up", &value));

   float x, X, y, Y, z, Z;
   assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

   int total_slices = 1000;
   if (readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);
   
   float cur_z = z + (Z - z)*((float)index/total_slices); // 3D coord of Z.
   printf("BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   
   char file_name[1000];
   for ( int count = 1; count < total_faces; count ++ )
   {
      sprintf(file_name, "segmentation/face%d_body_roof.png", count);

      // in ivview: x, y, z is left-right, bottom-up, and face-inside directions. (has nothing to do with SketchUp at this point)
      // transfer a point with Y=652, x, and z could be (0,0) back to face1 coordinate, got the height in the image

      char fn_trans[1000];
      sprintf(fn_trans, "face%d/trans.txt", count);

      float M[9];
      ca_load_trans_matrix(fn_trans, M);
      float *new_P = ca_compute_multi_vec_matrix(0.0, 0.0, cur_z, M);
      float new_y = new_P[1];

      // LOAD 2nd BOX
      sprintf(fn_trans, "face%d", count);
      ca_load_aux_top_level(fn_trans);
      sprintf(fn_trans, "box_face%d", count);
      assert(readRunTimeFlag(fn_trans, &value));

      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
      printf("FACE BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);
   
      // LOAD IMAGE HERE
      int h, w;
      BYTE **cur_im;
      assert(readRunTimeFlag("face_total_slices", &value));
      int mid_index = atoi(value) / 2;
      char *str_mi = digit_string(4, mid_index);
      sprintf(fn_trans, "face%d/slices/image_slice_%s.png", count, str_mi);
      cur_im = load_image_array(fn_trans, h, w);
      free(str_mi);

      float diff_x = X - x;
      float scale = (float)image_width / diff_x;
      int im_y = image_height - (int)((new_y - y) * scale + .5) - 1;

      printf("Ledger here: %d\n", im_y);
      for (int x = 0; x < w; x ++ )
         cur_im[im_y][x] = BLACK;
      Save2File(file_name, cur_im, NULL, w, h, 0, NULL);

      free_image(cur_im);

   }
}

// compute the wall boundary of the slice
void ca_segment_width_boundary_of_wall(int face_count, int wall_count)
{
   char image_fn[1000];
   char *ds = digit_string(4, wall_count);
   sprintf(image_fn, "face%d/slices/image_slice_%s", face_count, ds);
   free(ds);

   int h, w;
   BYTE **cur_im = load_image_array(image_fn, h, w);

   //TODO: manually set for now
#if 0   
   {
      // mask the image with height im_y ??? or just skip data points under height
      // compute the walls.
      const int mask_size = 8;
      const float mask_thres = 0.5;
      BYTE **seg_lut = new_image(h, w);
      bool found = false;
      int total_mount_pts_image = 0;
      for (int x = 0; x < w; x += mask_size ) {
         for (int y = 0; y < im_y; y += mask_size) {
            // 1. search for big trunk.
            // 2. expand a big trunk.
            // 3. compute the size of big trunk and ratio of the data/region

            if ( seg_lut[y][x] == 1 )
               continue;
               
            // step 1. let's ignore noise case at this point
            if ( cur_im[y][x] == BLACK &&
                 count_image_data_points_with_mask(cur_im, mask_size, x, y) / (float)(mask_size*mask_size) > mask_thres ) {
               item_seg_vector_with_mask(y, x, cur_im, seg_lut, count_pts, h, w, mask_size, mask_thres);
            }
         }
      }
   }
#endif   

   free_image(cur_im);
}

vector<int> * ca_compute_intersection_point(vector<int> *line1, vector<int> *line2)
{
   assert(line1->size() == 4);
   assert(line2->size() == 4);

   int l1_x0 = line1->at(0);
   int l1_y0 = line1->at(1);
   int l1_x1 = line1->at(2);
   int l1_y1 = line1->at(3);

   int l2_x0 = line2->at(0);
   int l2_y0 = line2->at(1);
   int l2_x1 = line2->at(2);
   int l2_y1 = line2->at(3);

   int diff_x1 = l1_x1 - l1_x0;
   int diff_x2 = l2_x1 - l2_x0;

   if ( diff_x1 == 0 && diff_x2 == 0 ) {
      return NULL;
   }

   if ( diff_x1 == 0 && diff_x2 != 0 ) {
      int y;
      if ( l2_y1 == l2_y0 ) {
         y = l2_y1;
      } else {
         // 10.19.2010 - wrong equation
         //y = (int) ((l2_y1 - ((l2_y1 - l1_y1) * (l2_x1 - l2_x0)/ (float) (l2_y1 - l2_y0))) + .5 );
         y = (int) ((l2_y1 - ((l2_y1 - l2_y0) * (l2_x1 - l1_x0)/ (float) (l2_x1 - l2_x0))) + .5 );
      }
      vector<int> *result = new vector<int> ();
      result->push_back(l1_x1);
      result->push_back(y);
      return result;
   }

   if ( diff_x1 != 0 && diff_x2 == 0 ) {
      int y;
      if ( l1_y1 == l1_y0 ) {
         y = l1_y1;
      } else {
         //y = (int) ((l1_y1 - ((l1_y1 - l2_y1) * (l1_x1 - l1_x0)/ (float)(l1_y1 - l1_y0))) + .5);
         y = (int) ((l1_y1 - ((l1_y1 - l1_y0) * (l1_x1 - l2_x0)/ (float)(l1_x1 - l1_x0))) + .5);
      }
      vector<int> *result = new vector<int> ();
      result->push_back(l2_x1);
      result->push_back(y);
      return result;
   }

   // regular case: x = (b2 - b1)/(m1 - m2); y = (m1b2 - m2b1)/(m1 - m2);
   float m1 = (l1_y1 - l1_y0)/(float)(l1_x1 - l1_x0);
   float m2 = (l2_y1 - l2_y0)/(float)(l2_x1 - l2_x0);
   float b1 = (l1_y1 - m1 * l1_x1);
   float b2 = (l2_y1 - m2 * l2_x1);

   int x = (int) ( (b2 - b1)/(m1 - m2) + .5);
   int y = (int) ( (m1*b2 - m2*b1)/(m1 - m2) + .5);

   vector<int> *result = new vector<int> ();
   result->push_back(x);
   result->push_back(y);
   return result;
   
   
}


/* FUNCTION: ca_segment_roof_show_result

   compute the segment region and hightlight in different color

Algorithm:
 1. compute lines based on the wall information obtained earlier.
 2. compute the vertices for out-most boundary,
 3. compute the intersection points inside the boundary
 4. highlight the sub-region with random color.

Threshold:
 NONE

Statement:

Assumption:
 Sub-regions are defined with FOUR vertices.

*/
 
void ca_segment_show_result( int mode )
{
   char *mode_str = mode == 0 ? "roof" : "body";
   char str_name[1024];
   
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *output_fn = NULL;
   char *output_fn_body_only = NULL;
   if ( mode == 0 && !readRunTimeFlag("result_segment_roof_region_faces", &output_fn) )
      output_fn = "result_seg_roof_region_faces.txt";

   if ( mode == 0 && file_exist(output_fn ) )
      return;

   if ( mode == 1 && !readRunTimeFlag("result_segment_body_region_faces", &output_fn_body_only) )
      output_fn_body_only = "result_seg_body_region_faces.txt";

   if ( mode == 1 && file_exist(output_fn_body_only ) )
      return;

   if ( mode == 1 && !ca_has_body() )
      return;

   printf("\n\nMODULE - ca_segment_%s_show_result(): \n\n", mode_str);
   
   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   vector<vector<int> > result_faces(total_faces - 1);

   if ( mode == 0 && !readRunTimeFlag("result_segment_roof_only", &output_fn) )
      output_fn = "result_seg_roof_units.txt";
   if ( mode == 1 && !readRunTimeFlag("result_segment_body_only", &output_fn) )
      output_fn = "result_seg_body_units.txt";
   
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      if ( mode == 0 ) {
         printf("ERROR: could not open %s\n", output_fn);
         assert(0);
      } else {
         printf("INFO: There is no %s, so let's skip show body result\n", output_fn);

         // we should generate the result file
         FILE *fd = fopen(output_fn_body_only, "w");
         assert(fd);
         fprintf(fd, "region_0");
         for (int i = 0; i < total_faces - 1; i ++ )
            fprintf(fd, " %d", i);
         fprintf(fd, "\n");
         fclose(fd);
         return;

      }
   }
   char index_str[1000];
   int face, im_index, x1, x2, x_w;
   while (fgets(index_str, 1000, output_fd ) ) {
      if (sscanf(index_str, "%d %d %d %d %d", &face, &im_index, &x1, &x2, &x_w ) == 5) {
         result_faces[face-1].push_back(im_index);
         result_faces[face-1].push_back(x1);
         result_faces[face-1].push_back(x2);
         result_faces[face-1].push_back(x_w);
      }
   }
   fclose(output_fd);

   int total_slices = 1000;
   ca_load_aux_top_level("bottom_up");
   if (readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);
   
   char file_name[1000];
   sprintf(file_name, "segmentation/segment_%s.png", mode_str);

   if ( ! file_exist(file_name ) ) {
      // let's copy a file for calibration if needed.
      char cpy_cmd[1000];
      sprintf(cpy_cmd, "copy bottom_up\\slices\\image_slice_0020.png segmentation\\segment_%s.png", mode_str);
      system(cpy_cmd);
   }
   
   // LOAD IMAGE HERE
   int h, w;
   BYTE **cur_im = load_image_array(file_name, h, w);
   BYTE **all_im = copy_image(cur_im, h, w);

   // global hash tables
   int global_line_index = 0;
   st_table *st_boundary_lines = st_init_table(st_numcmp, st_numhash);         // all boundary line index
   st_table *st_all_pts  = st_init_table(st_numcmp, st_numhash);               // all points of lines -> line_no 
   st_table *st_intersection_pts = st_init_table(st_numcmp, st_ptrhash);       // insection pts -> all list of line no.
   st_table *st_line_2_pts = st_init_table(st_numcmp, st_ptrhash);             // line segment number -> all points on this line
   st_table *st_line_2_pts_all = st_init_table(st_numcmp, st_ptrhash);         // line number -> all points on this line
   st_table *st_polygon_pts = st_init_table(st_numcmp, st_ptrhash);            // ploygon pts -> all list of line crossing this point.
   deque<int> vec_polygon_boundary_pts;                                        // ordered boundary points (the bounding box of the roof)
   st_table *st_pts_2_region = st_init_table(st_numcmp, st_ptrhash);           // all points of segmented region --> region id
   vector<vector<int> * > vec_region_vertices;                                 // the final region points
   vector<vector<int> * > vec_line_pts;                                        // for each line, 4 coordinates are pushed. (x0, y0) -> (x1, y1)
   vector<int> vec_line_2_face_no;                                             // for each line no, what is its face number.
   vector<vector<int> * > vec_region_faces;                                    // for each region, what are the faces touched.
   map<int, int> map_line2face;                                                // for a particular line, map it if it is a boundary one.
   // vector<vector<int> > vec_line_polygon_pts(global_line_index + 1);        // ordered polygon points on a line || defined later
   
   // draw partial lines.
   for ( int count = 1; count < total_faces; count ++ )
   {
      // in ivview: x, y, z is left-right, bottom-up, and face-inside directions. (has nothing to do with SketchUp at this point)
      // transfer a point with Y=652, x, and z could be (0,0) back to face1 coordinate, got the height in the image

      for ( int wall_count = 0; wall_count < result_faces[count-1].size(); wall_count +=4 )
      {
         global_line_index ++;
         vec_line_2_face_no.push_back(count);

         // LOAD 2nd BOX
         char fn_trans[1000];
         float x, X, y, Y, z, Z, cur_z;

         sprintf(fn_trans, "face%d", count);
         ca_load_aux_top_level(fn_trans);
         
         if (readRunTimeFlag("face_total_slices", &value) )
            total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", count);
         assert(readRunTimeFlag(fn_trans, &value));

         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
         cur_z = z + (Z - z)*((float)result_faces[count-1][wall_count]/total_slices); // 3D coord of Z.

         float min_x, max_x;
         int left_x = result_faces[count-1][wall_count+1];
         int right_x = result_faces[count-1][wall_count+2];
         int all_x = result_faces[count-1][wall_count+3];
         if ( left_x == right_x ) {
            min_x = x;
            max_x = X;
            if ( wall_count == 0 || wall_count == result_faces[count-1].size() - 4) { // assume the last one is boundary line
               st_insert(st_boundary_lines, (char *)(global_line_index), NULL); // insert the boundary lines
               printf("ADDING line %d as boundary line\n", global_line_index);
            }
         } else {
            min_x = left_x /(float)all_x * (X - x) + x;
            max_x = right_x/(float)all_x * (X - x) + x;
            if ( wall_count == 0 || wall_count == result_faces[count-1].size() - 4) { // assume the last one is boundary line
               st_insert(st_boundary_lines, (char *)(global_line_index), NULL); // insert the boundary lines
               printf("ADDING line %d as boundary line\n", global_line_index);
            }
         }
            
         sprintf(fn_trans, "face%d/trans_back.txt", count);
         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_P1 = ca_compute_multi_vec_matrix(min_x, Y, cur_z, M);
         float *new_P2 = ca_compute_multi_vec_matrix(max_x, Y, cur_z, M);

         // compute the boundary of the wall
         // ca_segment_width_boundary_of_wall(count, wall_count);

         // LOAD ORIGINAL BOX
         ca_load_aux_top_level("bottom_up");
         assert(readRunTimeFlag("box_bottom_up", &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
      
         float diff_x = X - x;
         float scale = (float)image_width / diff_x;
         int im_y1 = image_height - (int)((new_P1[1] - y) * scale + .5) - 1;
         int im_x1 = (int)(((new_P1[0] - x)/diff_x)*image_width  + .5); // x
         int im_y2 = image_height - (int)((new_P2[1] - y) * scale + .5) - 1;
         int im_x2 = (int)(((new_P2[0] - x)/diff_x)*image_width  + .5); // x

         draw_line_on_2D_image(cur_im, h, w, im_x1, im_y1, im_x2, im_y2);
         vector<int> *vec_pts = pixels_between_2_points_in_order(h, w, im_x1, im_y1, im_x2, im_y2);
         st_insert(st_line_2_pts, (char *)global_line_index, (char *)vec_pts); // insert all pts for a line.
         vector<int> *vec_lp = new vector<int> (); // insert end points for a line
         vec_lp->push_back(im_x1);
         vec_lp->push_back(im_y1);
         vec_lp->push_back(im_x2);
         vec_lp->push_back(im_y2);
         vec_line_pts.push_back(vec_lp);

         for (int i = 0; i < vec_pts->size(); i ++ ) {
            int pt = vec_pts->at(i);
            st_insert(st_all_pts, (char *)pt, (char *)global_line_index);  // insert all pts of lines
         }
         
      }

      // this is the out-most line
      map_line2face[global_line_index-1] = 1;
      
   }

   sprintf(str_name, "segmentation/segment_%s_result.png", mode_str);
   Save2File(str_name, cur_im, NULL, w, h, 0, NULL);
   free_image(cur_im);

   // compute st_intersection_pts
   for (int line_no = 0; line_no < global_line_index; line_no ++ )
   {
      for ( int j = line_no + 1; j < global_line_index; j ++ ) {
         vector<int> *share_pt = ca_compute_intersection_point(vec_line_pts[line_no], vec_line_pts[j]);
         if ( share_pt && valid_pixel((*share_pt)[0], (*share_pt)[1]) ) {
            int x = (*share_pt)[0];
            int y = (*share_pt)[1];
            int pt = index(x, y);
            
            // insert this into st_intersection_pts
            vector<int> *vec_lines = new vector<int> ();
            vec_lines->push_back(line_no+1);
            vec_lines->push_back(j+1);
            st_insert(st_intersection_pts, (char *)pt, (char *)vec_lines);
            printf("INTERSECTION POINT of line %d with line %d: [%d, %d]\n", line_no, j, x, y);
            //printf("line %d: [%d, %d], [%d, %d]\n", line_no, (*vec_line_pts[line_no])[0],(*vec_line_pts[line_no])[1],(*vec_line_pts[line_no])[2],(*vec_line_pts[line_no])[3]);
            //printf("line %d: [%d, %d], [%d, %d]\n", j, (*vec_line_pts[j])[0],(*vec_line_pts[j])[1],(*vec_line_pts[j])[2],(*vec_line_pts[j])[3]);

            bool is_inserted = false;
            vector<int> *vec_pts;
            assert(st_lookup(st_line_2_pts, (char *)(line_no+1), (char **)&vec_pts));
            float scale = abs(vec_line_pts[line_no]->at(2) - vec_line_pts[line_no]->at(0) ); // x
            int insert_y = 0;
            if ( scale == 0 || abs(vec_line_pts[line_no]->at(3) - vec_line_pts[line_no]->at(1) ) / scale > 1.0 )
               insert_y = 1;
            for (int k = 0; k < vec_pts->size(); k ++ ) {
               int x1 = x_axis(vec_pts->at(k));
               int y1 = y_axis(vec_pts->at(k));
               if ( (insert_y && (y1 == y) ) || (!insert_y && (x1 == x) )) {
                  vec_pts->insert(vec_pts->begin() + k, pt);
                  is_inserted = true;
                  break;
               }
            }
            //assert( is_inserted );

            is_inserted = false;
            assert(st_lookup(st_line_2_pts, (char *)(j+1), (char **)&vec_pts));
            scale = abs(vec_line_pts[j]->at(2) - vec_line_pts[j]->at(0) ); // x
            insert_y = 0;
            if ( scale == 0 || abs(vec_line_pts[j]->at(3) - vec_line_pts[j]->at(1) ) / scale > 1.0 )
               insert_y = 1;
            for (int k = 0; k < vec_pts->size(); k ++ ) {
               int x1 = x_axis(vec_pts->at(k));
               int y1 = y_axis(vec_pts->at(k));
               if ( (insert_y && (y1 == y) ) || (!insert_y && (x1 == x) )) {
                  vec_pts->insert(vec_pts->begin() + k, pt);
                  is_inserted = true;
                  break;
               }
            }
            //assert( is_inserted );
            
         }
      }
   }
   
#if 0   
   // draw another image with full line
   global_line_index = 0;
   for ( int count = 1; count < total_faces; count ++ )
   {
      // in ivview: x, y, z is left-right, bottom-up, and face-inside directions. (has nothing to do with SketchUp at this point)
      // transfer a point with Y=652, x, and z could be (0,0) back to face1 coordinate, got the height in the image

      for ( int wall_count = 0; wall_count < result_faces[count-1].size(); wall_count +=4 )
      {
         global_line_index ++;
         
         // LOAD 2nd BOX
         char fn_trans[1000];
         float x, X, y, Y, z, Z, cur_z;
         sprintf(fn_trans, "face%d", count);
         ca_load_aux_top_level(fn_trans);
         
         if (readRunTimeFlag("face_total_slices", &value) )
            total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", count);
         assert(readRunTimeFlag(fn_trans, &value));

         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
         cur_z = z + (Z - z)*((float)result_faces[count-1][wall_count]/total_slices); // 3D coord of Z.

         sprintf(fn_trans, "face%d/trans_back.txt", count);
         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_P1 = ca_compute_multi_vec_matrix(x, Y, cur_z, M);
         float *new_P2 = ca_compute_multi_vec_matrix(X, Y, cur_z, M);

         // compute the boundary of the wall
         // ca_segment_width_boundary_of_wall(count, wall_count);

         // LOAD ORIGINAL BOX
         ca_load_aux_top_level("bottom_up");
         assert(readRunTimeFlag("box_bottom_up", &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
      
         float diff_x = X - x;
         float scale = (float)image_width / diff_x;
         int im_y1 = image_height - (int)((new_P1[1] - y) * scale + .5) - 1;
         int im_x1 = (int)(((new_P1[0] - x)/diff_x)*image_width  + .5); // x
         int im_y2 = image_height - (int)((new_P2[1] - y) * scale + .5) - 1;
         int im_x2 = (int)(((new_P2[0] - x)/diff_x)*image_width  + .5); // x

         draw_line_on_2D_image(all_im, h, w, im_x1, im_y1, im_x2, im_y2);
         vector<int> *vec_pts = pixels_between_2_points_in_order(h, w, im_x1, im_y1, im_x2, im_y2);
         st_insert(st_line_2_pts_all, (char *)global_line_index, (char *)vec_pts); // insert all pts for a line.

         // let's do this with a 3x3 mask. otherwise, we may lose some intersection points.
         // for example, the two lines cross each other via shape of "X".
#if 0
         for (int i = 0; i < vec_pts->size(); i ++ ) {
            int pt = vec_pts->at(i);
            
            int *line_index;
            if ( !st_is_member(st_all_pts, (char *)pt) ) {
               st_insert(st_all_pts, (char *)pt, (char *)global_line_index);  // insert all pts of lines
            /*
            }

            {
               // check "X" shape crossing.
               int pt_neighbor[] = {pt - image_width, pt - image_width -1, pt - image_width + 1,
                                    pt - 1, pt + 1,
                                    pt + image_width, pt + image_width -1, pt + image_width + 1};
               bool found = false;
               int local_mask = 3;
               int x0 = x_axis(pt), y0 = y_axis(pt);
               for ( int y1 = y0 - local_mask; y1 < y0 + local_mask + 1; y1 ++ )
                  for ( int x1 = x0 - local_mask; x1 < x0 + local_mask + 1 ; x1 ++ ) {
                     if ( st_is_member(st_intersection_pts, (char *)index(x1, y1)) )
                        found = true;
                  }
               if ( !found ) {
                  for ( int j = 0; j < 8 ; j ++ ) {
                     if ( pt_neighbor[j] >= 0 && pt_neighbor[j] < image_width * image_height ) {
                        if ( st_lookup(st_all_pts, (char *)pt_neighbor[j], (char **)&line_index) ) {

                           if ( (int)line_index != global_line_index ) {  // insert intersection points.
                              vector<int> *vec_lines = new vector<int>();
                              vec_lines->push_back((int)line_index);
                              vec_lines->push_back(global_line_index);
                              st_insert(st_intersection_pts, (char *)pt, (char *)vec_lines);
                              st_insert(st_intersection_pts, (char *)pt_neighbor[j], (char *)vec_lines);
                              printf("BAD INTERSECTION POINT: [%d, %d]\n", x_axis(pt), y_axis(pt));
                              break;
                           }
                        }
                     }
                  }
               }
               }*/
            } else {
               st_lookup(st_all_pts, (char *)pt, (char **)&line_index);
               
               if ( (int)line_index != global_line_index ) {  // insert intersection points.
                  if ( !st_is_member(st_intersection_pts, (char *)pt ) ) {
                     vector<int> *vec_lines = new vector<int>();
                     vec_lines->push_back((int)line_index);
                     vec_lines->push_back(global_line_index);
                     st_insert(st_intersection_pts, (char *)pt, (char *)vec_lines);
                     printf("INTERSECTION POINT: [%d, %d]\n", x_axis(pt), y_axis(pt));
                  } else {
                     vector<int> *vec_lines;
                     st_lookup(st_intersection_pts, (char *)pt, (char **)&vec_lines);
                     vec_lines->push_back(global_line_index);
                  }
                  st_insert(st_all_pts, (char *)pt, (char *)global_line_index);
               }
            }
         }
#endif 
      }
   }

   sprintf(str_name, "segmentation/segment_%s_result_all.png", mode_str);
   Save2File(str_name, all_im, NULL, w, h, 0, NULL);
   free_image(all_im);
#endif   

   // compute all segement points.
   // log down these information:
   //  1. for each point, what are the lines it is located.
   //  2. for each boundary line segment, the ordered list of the points.

   // compute the exact end points for each line segments.
   // this will be used for later process.
   // and then compute the vertices of the boundary.

   BYTE **new_im = new_image(h, w);
   vector<vector<int> > vec_line_polygon_pts(global_line_index + 1); // ordered polygon points on a line
   
   // fill_polygon
   // get end points for each line segment
   for (int line_no = 1; line_no <= global_line_index; line_no ++)
   {
      vector<int> *vec_pts;
      assert(st_lookup(st_line_2_pts, (char *)line_no, (char **)&vec_pts));

      // find the first point
      int point1 = -1, point2 = -1;
      for (int i = 0; i < vec_pts->size(); i ++) {
         int pt = vec_pts->at(i);
         if ( !st_is_member(st_intersection_pts, (char *)pt) ) {
            continue;
         } else { // this is a intersection point
            
            point1 = pt;

            vector<int> *vec_lines;
            if ( !st_lookup(st_polygon_pts, (char *)pt, (char **)&vec_lines) ) {
               vec_lines = new vector<int> ();
            }
            {
               vector<int> *vec_lines_all;
               assert(st_lookup(st_intersection_pts, (char *)pt, (char **)&vec_lines_all));
               for ( int k = 0; k < vec_lines_all->size(); k ++ )
                  vec_line_polygon_pts[vec_lines_all->at(k)].push_back(pt); // make sure this point is added
            }
            vec_lines->push_back(line_no);
            
            break;
         }
      }
      assert(point1 != -1);

      // find the second point
      for (int i = vec_pts->size() - 1; i >= 0; i --) {
         int pt = vec_pts->at(i);
         if ( !st_is_member(st_intersection_pts, (char *)pt) ) {
            continue;
         } else {
            point2 = pt;
            
            vector<int> *vec_lines;
            if ( !st_lookup(st_polygon_pts, (char *)pt, (char **)&vec_lines) ) {
               vec_lines = new vector<int> ();
            }
            {
               vector<int> *vec_lines_all;
               assert(st_lookup(st_intersection_pts, (char *)pt, (char **)&vec_lines_all));
               for ( int k = 0; k < vec_lines_all->size(); k ++ )
                  vec_line_polygon_pts[vec_lines_all->at(k)].push_back(pt); // make sure this point is added
            }
            vec_lines->push_back(line_no);
            
            break;
         }
      }
      assert(point2 != -1);

      // find boundary point
      // assume each line is adjacent to the other (this assumption may be broken for some cases).
      if ( st_is_member(st_boundary_lines, (char *)line_no) ) {
         if ( vec_polygon_boundary_pts.size() == 0 ) {
            vec_polygon_boundary_pts.push_back(point1);
            vec_polygon_boundary_pts.push_back(point2);
            printf("DEBUG: Initially insert two points: [%d, %d], [%d, %d]\n", x_axis(point1), y_axis(point1), x_axis(point2), y_axis(point2));
         } else {
            int last = vec_polygon_boundary_pts.size() - 1;
            if ( vec_polygon_boundary_pts[0] == point1 )
               vec_polygon_boundary_pts.push_front(point2);
            else if ( vec_polygon_boundary_pts[0] == point2 )
               vec_polygon_boundary_pts.push_front(point1);
            else if ( vec_polygon_boundary_pts[last] == point1 )
               vec_polygon_boundary_pts.push_back(point2);
            else if ( vec_polygon_boundary_pts[last] == point2 )
               vec_polygon_boundary_pts.push_back(point1);
            else {
               printf("DEBUG: point1: [%d, %d], point2: [%d, %d], head: [%d, %d], tail: [%d, %d], size: %d, LINE: %d\n",
                      x_axis(point1), y_axis(point1), x_axis(point2), y_axis(point2),
                      x_axis(vec_polygon_boundary_pts[0]), y_axis(vec_polygon_boundary_pts[0]),
                      x_axis(vec_polygon_boundary_pts[last]), y_axis(vec_polygon_boundary_pts[last]), vec_polygon_boundary_pts.size(), line_no);
            }
         }
      }
            
      

      int im_x1 = x_axis(point1);
      int im_y1 = y_axis(point1);
      int im_x2 = x_axis(point2);
      int im_y2 = y_axis(point2);
      draw_line_on_2D_image(new_im, h, w, im_x1, im_y1, im_x2, im_y2);
   }

   sprintf(str_name, "segmentation/segment_%s_result_region.png", mode_str);
   Save2File(str_name, new_im, NULL, w, h, 0, NULL);

   // infer segmentation regions
   // locate the points of boundary lines. obtain all points inside the boundary.
   // start from a point, watersheding all points until walls are reached.
   // get the 4 most touched lines, get the end points.
   // keep doing this until all points inside the polygon are marked.

   // the watersheding can be done with a mask so that it will not go out of the
   // boundary of the bounding box.
   
   // print out the boundary points:
   // this should be four points!!!!
   vector<int> contour_pts;
   for (int i = 0; i < vec_polygon_boundary_pts.size(); i ++) {
      printf("Boundary point:  [%d, %d] \n", x_axis(vec_polygon_boundary_pts[i]), y_axis(vec_polygon_boundary_pts[i]));
      contour_pts.push_back(vec_polygon_boundary_pts[i]);
   }

   vector<int> vec_filled_pts;
   contour_pts.push_back(contour_pts[0]);  // fixed a bug, we have to have a closed polygon.

   // check whether the assumption is broken:
   //     assume each line is adjacent to the other (this assumption may be broken for some cases).
   assert(contour_pts.size() > 4 );
   
   fill_polygon(contour_pts, vec_filled_pts);

   BYTE **rgn_im = copy_image(new_im, h, w);

   if ( 0 ) {
      Save2File("segmentation/segment_before_filled_region.png", rgn_im, NULL, w, h, 0, NULL);
      for (int i = 0; i < vec_filled_pts.size(); i ++) {
         rgn_im[0][vec_filled_pts[i]] = BLACK;
      }
      Save2File("segmentation/segment_filled_region.png", rgn_im, NULL, w, h, 0, NULL);
   }


   char *region_result;
   if ( mode == 0 && !readRunTimeFlag("result_segment_roof_region", &region_result) )
      region_result = "result_seg_roof_regions.txt";
   if ( mode == 1 && !readRunTimeFlag("result_segment_body_region", &region_result) )
      region_result = "result_seg_body_regions.txt";
   FILE *fd_region_result = fopen(region_result, "w");
   assert(fd_region_result);
      
   int total_color = 6; /* red, green, blue, yellow, cyan, pink -- see http://html-color-codes.com/rgb.html */
   int r_array[] = {255,   0,   0,  255,   0, 255, 0};
   int g_array[] = {  0, 255,   0,  255, 255,   0, 0};
   int b_array[] = {  0,   0, 255,    0, 255, 255, 0};

   BYTE ***new_im_3D = new_3D_image(h, w);
   int region_id = 0;
   for (int i = 0; i < vec_filled_pts.size(); i ++) {
      int x = x_axis(vec_filled_pts[i]);
      int y = y_axis(vec_filled_pts[i]);

      
      if ( rgn_im[0][vec_filled_pts[i]] == BLACK)
         continue;
      
      if ( new_im[y][x] == BLACK || new_im[y][x-1] == BLACK || new_im[y][x+1] == BLACK ||
           new_im[y-1][x] == BLACK || new_im[y-1][x-1] == BLACK || new_im[y-1][x+1] == BLACK ||
           new_im[y+1][x] == BLACK || new_im[y+1][x-1] == BLACK || new_im[y+1][x+1] == BLACK )
         continue;

      /*
      int r = 127 + rand()%127;
      int g = 127 + rand()%127;
      int b = 127 + rand()%127;
      */
      int r = r_array[region_id%total_color];
      int g = g_array[region_id%total_color];
      int b = b_array[region_id%total_color];
      
      // watersheding the region starting at point vec_filled_pts[i]
      vector<int> vec_line_touched_count(global_line_index+1, 0); // how many times this line is touched by watersheding operation
      vector<int> init_pts;
      init_pts.push_back(vec_filled_pts[i]);
      while (true ) {

         vector<int> new_pts(init_pts);
         init_pts.clear();
         for (int i = 0; i < new_pts.size(); i ++ )
         {

            int x = x_axis(new_pts[i]);
            int y = y_axis(new_pts[i]);
         
            if (x<1 || x>w-2 || y<1 || y>h-2 )
            {
               continue;
            }
            if ( rgn_im[y][x] == BLACK )
               continue;
                 

            rgn_im[y][x] = BLACK;
            set_color(new_im_3D, y, x, r, g, b);
            st_insert(st_pts_2_region, (char *)new_pts[i], (char *)region_id);
            
            if ( new_im[y][x] == WHITE && new_im[y][x-1] == WHITE && new_im[y][x+1] == WHITE &&
                 new_im[y-1][x] == WHITE && new_im[y-1][x-1] == WHITE && new_im[y-1][x+1] == WHITE &&
                 new_im[y+1][x] == WHITE && new_im[y+1][x-1] == WHITE && new_im[y+1][x+1] == WHITE ) {

               if ( rgn_im[y][x+1] == WHITE )
                  init_pts.push_back(index(x+1, y)) ;
               if ( rgn_im[y][x-1] == WHITE )
                  init_pts.push_back(index(x-1, y));
               if ( rgn_im[y-1][x] == WHITE )
                  init_pts.push_back(index(x, y-1));
               if ( rgn_im[y-1][x+1] == WHITE )
                  init_pts.push_back(index(x+1, y-1));
               if ( rgn_im[y-1][x-1] == WHITE )
                  init_pts.push_back(index(x-1, y-1));
               if ( rgn_im[y+1][x] == WHITE )
                  init_pts.push_back(index(x, y+1));
               if ( rgn_im[y+1][x+1] == WHITE )
                  init_pts.push_back(index(x+1, y+1));
               if ( rgn_im[y+1][x-1] == WHITE )
                  init_pts.push_back(index(x-1, y+1));
            } else {
               int l_x = -1, l_y = -1;
               if (new_im[y-1][x-1] == BLACK) { l_x = x - 1; l_y = y - 1; }
               if (new_im[y-1][x]   == BLACK) { l_x = x;     l_y = y - 1; }
               if (new_im[y-1][x+1] == BLACK) { l_x = x + 1; l_y = y - 1; }
               if (new_im[y][x]     == BLACK) { l_x = x;     l_y = y; }
               if (new_im[y][x-1]   == BLACK) { l_x = x - 1; l_y = y; }
               if (new_im[y][x+1]   == BLACK) { l_x = x + 1; l_y = y; }
               if (new_im[y+1][x-1] == BLACK) { l_x = x - 1; l_y = y + 1; }
               if (new_im[y+1][x]   == BLACK) { l_x = x;     l_y = y + 1; }
               if (new_im[y+1][x+1] == BLACK) { l_x = x + 1; l_y = y + 1; } 

               assert( l_x !=  -1 && l_y != -1 );
               int *line_no;
               {
                  if ( st_lookup(st_all_pts, (char *)index(l_x, l_y), (char **)&line_no) ) {
                     vec_line_touched_count[(int)line_no] ++;
                  } else {

                     /* This part is useless, basically, we want to make sure the out-most line
                        will be touched by nearby pixels.
                        
                     int mask_size = 4;
                     int mb = 1;
                     bool found = true;
                     while ( !found && mb <= mask_size )
                     {
                        for (int x = l_x - mb; !found && x <= l_x + mb; x += mb*2 ) 
                           for (int y = l_y - mb; y <= l_y + mb; y ++ )
                              if ( st_lookup(st_all_pts, (char *)index(x, y), (char **)&line_no) ) {
                                 vec_line_touched_count[(int)line_no] ++;
                                 found = true;
                                 break;
                              }
                        for (int y = l_y - mb; !found && y <= l_y + mb; y += mb*2 ) 
                           for (int x = l_x - mb; !found && x <= l_x + mb; x ++ )
                              if ( st_lookup(st_all_pts, (char *)index(x, y), (char **)&line_no) ) {
                                 vec_line_touched_count[(int)line_no] ++;
                                 found = true;
                                 break;
                              }
                        mb ++;
                     }
                     */
                  }
               }
            }
         }

         if (init_pts.size() == 0)
            break;
      }

      region_id ++;
      
      // compute the boundary coordinates of the segment regions.
      // find the 4 dominate line numbers in vec_line_touched_count;
      // It seems we do not need to compute the polygon vertices.
      // we only need the mapping from region points to region number.
      // If needed, we can do this:
      // compute the distance from points in this region to all intersection points.
      // located at least 4 points with almost 0 distance. and then located 4 outmost
      // points by remove point in the middle of two intersection points.
      vector<int> vec_tmp(vec_line_touched_count);
      sort(vec_line_touched_count.begin(), vec_line_touched_count.end(), greater<int> ());
      int threshold = vec_line_touched_count[3]; // the most 4 touched lines.
      vector<int> lines_region;
      int region_pt1, region_pt2, region_pt3 = -1, region_pt4 = -1;
      bool found = false;
      int line_two_end_index = -1;

      // print out # of touched for each line
      for ( int i = 0; i < vec_line_touched_count.size(); i ++ ) {
         printf("%d, ", vec_line_touched_count[i]);
      }
      printf("\n");

      /*
      vector<int> *vec_faces_reg = new vector<int> ();
      for ( int i = 0; i < vec_tmp.size(); i ++ ) {  // 0 is meanlessness.
         if ( vec_tmp[i] >= threshold ) { // a valid line number i
            printf("line no: %d\n", i);
            
            if ( map_line2face.find(i-1) != map_line2face.end() )  // this is a boundary line
               vec_faces_reg->push_back(vec_line_2_face_no[i-1]); // face #
               
            if ( !found && vec_line_polygon_pts[i].size() == 2) { // the line with only two intersection points
               found = true;
               region_pt1 = vec_line_polygon_pts[i][0];
               region_pt2 = vec_line_polygon_pts[i][1];
               line_two_end_index = i; // the line number with only two end points.
               printf("LINE: %d, P1: [%d, %d], P2: [%d, %d]\n", i, x_axis(region_pt1), y_axis(region_pt1),
               x_axis(region_pt2), y_axis(region_pt2));
            } else {
               lines_region.push_back(i);
            }
         }
      }
      // debug:
      Save2File("segmentation/segment_debug_filled_region.png", rgn_im, NULL, w, h, 0, NULL);
      
      assert(lines_region.size() >= 3);
      assert(found);
      vec_region_faces.push_back(vec_faces_reg);

      // find the other two points
      int theOther1, theOther2;
      bool found_3rd_one = false;
      vector<int> *vec_lines;
      for ( int i = 0; i < lines_region.size(); i ++ ) {
         if ( i == 0 ) { theOther1 = lines_region[1]; theOther2 = lines_region[2];}
         if ( i == 1 ) { theOther1 = lines_region[0]; theOther2 = lines_region[2];}
         if ( i == 2 ) { theOther1 = lines_region[0]; theOther2 = lines_region[1];}
         for (int j = 0; j < vec_line_polygon_pts[lines_region[i]].size(); j ++) {
            int intersect_pt = vec_line_polygon_pts[lines_region[i]][j];
            if ( found_3rd_one && intersect_pt == region_pt3 )
               continue;
            
            assert(st_lookup(st_intersection_pts, (char *)intersect_pt, (char **)&vec_lines));
            bool found_pt = false;
            for ( int k = 0; k < vec_lines->size(); k ++) {
               if ( vec_lines->at(k) == theOther1 || vec_lines->at(k) == theOther2 ) {
                  if ( !found_3rd_one ) {
                     found_3rd_one = true;
                     region_pt3 = intersect_pt;
                  } else {
                     region_pt4 = intersect_pt;
                  }
                  found_pt = true;
                  break; // found the point
               }
            }
            if (found_pt )
               break;
         }
      }

      assert(region_pt3 != -1 && region_pt4 != -1);
      assert(st_lookup(st_intersection_pts, (char *)region_pt1, (char **)&vec_lines));
      int new_line = -1;
      for ( int k = 0; k < vec_lines->size(); k ++) {
         if ( vec_lines->at(k) != line_two_end_index ) {
            new_line = vec_lines->at(k);
            break;
         }
      }
      assert( new_line != -1); // this is the other line
      
      assert(st_lookup(st_intersection_pts, (char *)region_pt3, (char **)&vec_lines));
      bool found_line = false;
      for ( int k = 0; k < vec_lines->size(); k ++) {
         if ( vec_lines->at(k) == new_line ) {
            found_line = true;
            break;
         }
      }

      vector<int> *region_vec = new vector<int> ();
      if ( found_line ) {
         region_vec->push_back(region_pt2);
         region_vec->push_back(region_pt1);
         region_vec->push_back(region_pt3);
         region_vec->push_back(region_pt4);
         region_vec->push_back(region_pt2);
      } else {
         region_vec->push_back(region_pt1);
         region_vec->push_back(region_pt2);
         region_vec->push_back(region_pt3);
         region_vec->push_back(region_pt4);
         region_vec->push_back(region_pt1);
      }
      */

      vector<int> *region_vec = new vector<int> ();
      vector<int> *vec_faces_reg = new vector<int> ();
      {
         // construct the data structure
         vector<int> line_set;
         
         for ( int i = 1; i < vec_tmp.size(); i ++ ) {  // 0 is meanlessness.
            if ( vec_tmp[i] >= threshold ) { // a valid line number i
               printf("line no: %d\n", i);

               // if ( map_line2face.find(i-1) != map_line2face.end() )  // this is a boundary line
               {
                  int line_face_id = vec_line_2_face_no[i-1];
                  bool found = false;
                  for (int k = 0; k < vec_faces_reg->size(); k ++ ) {
                     if ( vec_faces_reg->at(k) == line_face_id ) {
                        found = true;
                        break;
                     }
                  }
                  if ( ! found ) {
                     vec_faces_reg->push_back(line_face_id);
                  }
               }
               
               vector<int> *vec_pts = vec_line_pts[i-1];
               line_set.push_back(vec_pts->at(0));
               line_set.push_back(vec_pts->at(1));
               line_set.push_back(vec_pts->at(2));
               line_set.push_back(vec_pts->at(3));
            }
         }

         // compute the 4 intersection points 
         assert(line_set.size() == 16);
         int total_intersect_pts = 0;
         vector<int> vec_intersect_pts;      /* the new intersection points */
         vector<int> vec_intersect_lines;    /* the line # intersected at the corresponding intersection point */
         for ( int i_line = 0; i_line < line_set.size() - 4; i_line += 4) {
            vector<int> *vec_l1 = new vector<int>();
            vector<int> *vec_l2 = new vector<int>();
            for (int k = 0; k < 4; k ++ )
               vec_l1->push_back(line_set[i_line+k]);

            for ( int sec_line = i_line + 4; sec_line < line_set.size(); sec_line += 4 ) {
               vec_l2->clear();
               for (int k = 0; k < 4; k ++ )
                  vec_l2->push_back(line_set[sec_line+k]);

               vector<int> *share_pt = ca_compute_intersection_point(vec_l1, vec_l2);
               if ( share_pt && valid_pixel((*share_pt)[0], (*share_pt)[1]) ) {
                  int x = (*share_pt)[0];
                  int y = (*share_pt)[1];
                  int pt = index(x, y);

                  printf("The %dth intersection point: LINE %d|%d is: %d, %d.\n", total_intersect_pts, i_line/4, sec_line/4, x, y );
                  vec_intersect_pts.push_back(pt);
                  vec_intersect_lines.push_back(i_line/4);
                  vec_intersect_lines.push_back(sec_line/4);
                  total_intersect_pts ++;
               }
            }

            // printf("Total %d intersection points found for LINE %d.\n", total_intersect_pts, i_line/4);

            delete vec_l1;
            delete vec_l2;
         }
      
         // compute the order of the intersection point
         assert(vec_intersect_pts.size() == 4);
         assert(vec_intersect_lines.size() == 8);
         vector<int> vec_pts_order;     /* the order for boundary generation (only 4 points ) */
         for (int i_pts = 0; i_pts < vec_intersect_pts.size(); i_pts ++ ) {
            int line1 = vec_intersect_lines[i_pts*2];
            int line2 = vec_intersect_lines[i_pts*2+1];
            for (int k = i_pts + 1; k < vec_intersect_pts.size(); k ++ ) {
               int nl1 = vec_intersect_lines[k*2];
               int nl2 = vec_intersect_lines[k*2+1];
               if ( nl1 == line1 || nl1 == line2 || nl2 == line1 || nl2 == line2 ) {
                  vec_pts_order.push_back(k);
                  if ( vec_pts_order.size() == 1)
                     vec_pts_order.push_back(0);

               } // end of if

               if ( vec_pts_order.size() == 4 )
                  break;
            
            } // end of for

            if ( vec_pts_order.size() == 4 )
               break;
         }

         assert( vec_pts_order.size() >= 4 );

         printf("Boundary of this quadrangle is:");
         for (int i = 0; i <= 4; i ++ ) {
            int x = x_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            int y = y_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            printf("P%d: (%d, %d), ", i, x, y );
            region_vec->push_back(vec_intersect_pts[vec_pts_order[i%4]]);
         }
         printf("\n");      
         
      }
      
      vec_region_vertices.push_back(region_vec);

      printf("Region %d: ", region_id);
      for (int i = 0; i < region_vec->size(); i ++ ) {
         printf("[%d, %d], ", x_axis(region_vec->at(i)), y_axis(region_vec->at(i)));
      }
      printf("\n");
         
      vec_region_faces.push_back(vec_faces_reg);
      
   }

   // black the boundary
   // looks bad
#if 0   
   for (int i = 1; i <= global_line_index; i ++ ) {
      vector<int> *vec_pts;
      if (st_lookup(st_line_2_pts, (char *)i, (char **)&vec_pts)) {
         for (int j = 0; j < vec_pts->size(); j ++ )
            set_color(new_im_3D, y_axis(vec_pts->at(j)), x_axis(vec_pts->at(j)), 0, 0, 0);
      }
   }
#endif    

   // output information to region files
   fprintf(fd_region_result, "Total %d\n", vec_region_vertices.size());
   fprintf(fd_region_result, "ImageSize %d %d\n", image_width, image_height);
   for (int i = 0; i < vec_region_vertices.size(); i ++ ) {
      fprintf(fd_region_result, "Region %d\n", i);
      
      for (int j = 0; j < vec_region_vertices[i]->size(); j ++ ) {
         fprintf(fd_region_result, "%d %d\n", x_axis(vec_region_vertices[i]->at(j)), y_axis(vec_region_vertices[i]->at(j)));
      }
   }

   sprintf(str_name, "segmentation/segment_%s_regions.png", mode_str);
   Save2File(str_name, NULL, NULL, image_width, image_height, 1, new_im_3D);
   printf("Total %d regions are segmented!\n", region_id);

   // region image
   free_image(new_im);
   free_image(rgn_im);
   free_image_3D(new_im_3D);
   fclose(fd_region_result);

   if ( mode == 0 && !readRunTimeFlag("result_segment_roof_region_faces", &region_result) )
      region_result = "result_seg_roof_region_faces.txt";
   if ( mode == 1 && !readRunTimeFlag("result_segment_body_region_faces", &region_result) )
      region_result = "result_seg_body_region_faces.txt";
   fd_region_result = fopen(region_result, "w");
   assert(fd_region_result);

   for (int i = 0; i < vec_region_vertices.size(); i ++ ) {
      fprintf(fd_region_result, "region_%d", i);
      vector<int> *vec_faces = vec_region_faces[i];
      st_table *st_unq = st_init_table(st_numcmp, st_numhash);
      for ( int k = 0; k < vec_faces->size(); k ++ )
         if ( !st_is_member(st_unq, (char *)vec_faces->at(k)) ) {
            st_insert(st_unq, (char *)vec_faces->at(k), (char *)NULL);
            fprintf(fd_region_result, " %d", vec_faces->at(k) - 1);
         }
      fprintf(fd_region_result, "\n");
      delete vec_faces;
      st_free_table(st_unq);
   }
   fclose(fd_region_result);
   
   
}

/* FUNCTION: ca_segment_roof_show_result

   compute the segment region and hightlight in different color
*/
 
void ca_segment_roof_show_result( )
{
   ca_segment_show_result( 0 );
}


/* FUNCTION: ca_segment_body_show_result

   compute the segment region and hightlight in different color
*/
 
void ca_segment_body_show_result( )
{
   ca_segment_show_result( 1 );
}


/* FUNCTION: ca_segment_wall_detection

Algorithm:
 1. search for big trunk.
 2. expand a big trunk.
 3. compute the size of big trunk and ratio of the data/region

Threshold:
 0. 0.8 - the ratio of data/mask_size under current pixel
    10  - mask size
 1. 0.2 - the ratio of data/region to be considered as wall
 2. 0.3 - the width of the truck compared to image width;
 3. 0.3 - the height of the truck compared to effecitve image height;

Statement:
 if ( count_image_data_points_with_mask(cur_im, mask_size, x, y) / (float)(mask_size*mask_size) > 0.8 ) 
 if ( diff_x/(float)w > 0.3 && diff_y/(float)im_y > 0.3 && (*count_pts)/(float)(diff_x*diff_y) > 0.2 )
    

 */
void ca_segment_wall_detection( )
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *output_fn = NULL;
   if ( !readRunTimeFlag("result_segment_roof_only", &output_fn) )
      output_fn = "result_seg_roof_units.txt";

   if ( file_exist(output_fn ) )
      return;

   printf("\n\nMODULE - ca_segment_wall_detection(): \n\n");
   
   if ( !readRunTimeFlag("result_segment_body_roof", &output_fn) )
      output_fn = "result_seg_body_roof.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_str[1000];
   int ledger_index = 0;
   while (fgets(index_str, 1000, output_fd ) ) {
      assert(sscanf(index_str, "%d", &ledger_index ) == 1);
      break;
   }
   fclose(output_fd);

   bool has_body = true;
   if ( ledger_index == 0 )
      has_body = false;
   
   // ledger_index = 652; // for synthetic CU data
   printf("The ledger index is %d\n", ledger_index);

   // compute the height
   ca_load_aux_top_level("bottom_up");
   assert(readRunTimeFlag("box_bottom_up", &value));

   float x, X, y, Y, z, Z;
   assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

   int total_slices = 1000;
   if (readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);
   
   float cur_z = z + (Z - z)*((float)ledger_index/total_slices); // 3D coord of Z.
   printf("BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   vector<vector<int> > result_faces_roof(total_faces - 1);
   vector<vector<int> > result_faces_body(total_faces - 1);
   vector<int> result_image_width(total_faces - 1);
   
   char file_name[1000];
   for ( int count = 1; count < total_faces; count ++ )
   {
      // in ivview: x, y, z is left-right, bottom-up, and face-inside directions. (has nothing to do with SketchUp at this point)
      // transfer a point with Y=652, x, and z could be (0,0) back to face1 coordinate, got the height in the image

      char fn_trans[1000];
      sprintf(fn_trans, "face%d/trans.txt", count);

      float M[9];
      ca_load_trans_matrix(fn_trans, M);
      float *new_P = ca_compute_multi_vec_matrix(0.0, 0.0, cur_z, M);
      float new_y = new_P[1];

      // LOAD 2nd BOX
      sprintf(fn_trans, "face%d", count);
      ca_load_aux_top_level(fn_trans);
         
      if (readRunTimeFlag("face_total_slices", &value) )
         total_slices = atoi(value);

      sprintf(fn_trans, "box_face%d", count);
      assert(readRunTimeFlag(fn_trans, &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      printf("Processing face%d...\n", count);
   
      // LOAD IMAGE HERE to get h and w, and then the height for current facade.
      int h, w;
      BYTE **cur_im;
      assert(readRunTimeFlag("slices_face_dimension", &value));
      assert(sscanf(value, "%dx%d", &w, &h) == 2);
      result_image_width[count-1] = w;

      image_width = w;
      image_height = h;

      float diff_x = X - x;
      float scale = (float)image_width / diff_x;
      int im_y = image_height - (int)((new_y - y) * scale + .5) - 1;

      // COMPUTE WALLs
      int max_mount_pts = 0, max_mount_index = -1; // In case, no slice can be found
      for (int i = 0; i < total_slices; i ++) {
         char *ds = digit_string(4, i);
         sprintf(fn_trans, "face%d/slices/image_slice_%s.png", count, ds);
         free(ds);

         printf("Processing face%d: %s...\n", count, fn_trans);
         
         cur_im = load_image_array(fn_trans, h, w);

         if ( ! has_body ) {
            im_y = image_height;
         } else {
            if ( im_y < 0 || im_y >= h) {
               printf("ERROR: im_y - %d, is not in the range of [0, %d]\n", im_y, h);
               assert( 0 );
            }
            for (int x = 0; x < w; x ++)
               cur_im[im_y][x] = WHITE;
         }

         // mask the image with height im_y ??? or just skip data points under height
         // compute the walls.
         const int mask_size = 10;
         const float mask_thres = 0.5;
         BYTE **seg_lut = new_image(h, w);
         bool found = false;
         int total_mount_pts_image = 0;

         // for roof part wall test
         for (int x = 0; x < w; x += mask_size ) {
            for (int y = 0; y < im_y; y += mask_size) {
               // 1. search for big trunk.
               // 2. expand a big trunk.
               // 3. compute the size of big trunk and ratio of the data/region

               if ( seg_lut[y][x] == 1 )
                  continue;
               
               // step 1. let's ignore noise case at this point
               if ( cur_im[y][x] == BLACK &&
                    count_image_data_points_with_mask(cur_im, mask_size, x, y) / (float)(mask_size*mask_size) > 0.8 ) {
                  int *count_pts = (int *) malloc (sizeof (int));
                  *count_pts = 0;
                  vector<int> *vct_x = new vector<int>();
                  vector<int> *vct_y = new vector<int>();
                  item_seg_vector(y, x, cur_im, seg_lut, count_pts, h, w, vct_x, vct_y);

                  if ( vct_x->size() <= 1 && vct_y->size() <= 1) { //noise case
                     delete vct_x;
                     delete vct_y;
                     free (count_pts);
                     continue;
                  }

                  sort(vct_x->begin(), vct_x->end(), greater<int>());
                  sort(vct_y->begin(), vct_y->end(), greater<int>());
                  int diff_x = abs(vct_x->at(0) - vct_x->at(vct_x->size() - 1));
                  int diff_y = abs(vct_y->at(0) - vct_y->at(vct_y->size() - 1));

                  delete vct_x;
                  delete vct_y;
                  
                  // check whether this is a good candidate for wall image
                  if ( diff_x/(float)w > 0.3 && diff_y/(float)im_y > 0.3 && (*count_pts)/(float)(diff_x*diff_y) > 0.2 ) {
                     printf("Find a wall image at: %d, total: %d, region[%d, %d]\n", i, (*count_pts), diff_x, diff_y);
                     found = true;
                     result_faces_roof[count-1].push_back(i);
                     free (count_pts);
                     break;
                  } else {
                     total_mount_pts_image += *count_pts;
                  }
                  free (count_pts);
               }
            }
            if (found)
               break;
         }

         // for body part wall test
         found = false;
         for (int x = 0; x < w; x += mask_size ) {
            for (int y = im_y + 1; y < h; y += mask_size) {
               // 1. search for big trunk.
               // 2. expand a big trunk.
               // 3. compute the size of big trunk and ratio of the data/region

               if ( seg_lut[y][x] == 1 )
                  continue;
               
               // step 1. let's ignore noise case at this point
               if ( cur_im[y][x] == BLACK &&
                    count_image_data_points_with_mask(cur_im, mask_size, x, y) / (float)(mask_size*mask_size) > 0.8 ) {
                  int *count_pts = (int *) malloc (sizeof (int));
                  *count_pts = 0;
                  vector<int> *vct_x = new vector<int>();
                  vector<int> *vct_y = new vector<int>();
                  item_seg_vector(y, x, cur_im, seg_lut, count_pts, h, w, vct_x, vct_y);
                  
                  if ( vct_x->size() <= 1 && vct_y->size() <= 1) { //noise case
                     delete vct_x;
                     delete vct_y;
                     free (count_pts);
                     continue;
                  }

                  sort(vct_x->begin(), vct_x->end(), greater<int>());
                  sort(vct_y->begin(), vct_y->end(), greater<int>());
                  assert(vct_x->size() > 1 && vct_y->size() > 1);
                  int diff_x = abs(vct_x->at(0) - vct_x->at(vct_x->size() - 1));
                  int diff_y = abs(vct_y->at(0) - vct_y->at(vct_y->size() - 1));

                  delete vct_x;
                  delete vct_y;
                  
                  // check whether this is a good candidate for wall image
                  if ( diff_x/(float)w > 0.3 && diff_y/(float)(h - im_y) > 0.3 && (*count_pts)/(float)(diff_x*diff_y) > 0.2 ) {
                     printf("Find a wall image at: %d, total: %d, region[%d, %d]\n", i, (*count_pts), diff_x, diff_y);
                     found = true;
                     result_faces_body[count-1].push_back(i);
                     free (count_pts);
                     break;
                  } else {
                     total_mount_pts_image += *count_pts;
                  }
                  free (count_pts);
               }
            }
            if (found)
               break;
         }
         
         
         if ( !found ) {  // in case, no image is found
            if (total_mount_pts_image > max_mount_pts ) {
               max_mount_pts = total_mount_pts_image;
               max_mount_index = i;
            }
         }
         
         free_image(cur_im);
         free_image(seg_lut);
      }

      if ( result_faces_roof[count-1].size() == 0 ) { // If no image is found, locate the image with max mount of points
         assert(max_mount_index != -1);
         result_faces_roof[count-1].push_back(max_mount_index);
      }

   }

   if ( !readRunTimeFlag("result_segment_roof_only", &output_fn) )
      output_fn = "result_seg_roof_units.txt";
   output_fd = fopen(output_fn, "a");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   
   for ( int count = 1; count < total_faces; count ++ )
   {
      if ( result_faces_roof[count-1].size() == 0 ) {
         printf("ERROR: no wall detected for this side of roof %d, exit...\n", count);
         exit(0);
      }
      
      for (int i = 0; i < result_faces_roof[count-1].size(); i ++) {
         printf("FACE %d: image %d\n", count, result_faces_roof[count-1][i]);
         fprintf(output_fd, "%d %d 0 0 %d\n", count, result_faces_roof[count-1][i], result_image_width[count-1]);
      }
   }

   fclose( output_fd );

   if ( !readRunTimeFlag("result_segment_body_only", &output_fn) )
      output_fn = "result_seg_body_units.txt";
   output_fd = fopen(output_fn, "a");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   
   for ( int count = 1; has_body && count < total_faces; count ++ )
   {
      if ( result_faces_body[count-1].size() == 0 ) {
         printf("ERROR: no wall detected for this side of body %d, exit...\n", count);
         exit(0);
      }
      
      for (int i = 0; i < result_faces_body[count-1].size(); i ++) {
         printf("FACE %d: image %d\n", count, result_faces_body[count-1][i]);
         fprintf(output_fd, "%d %d 0 0 %d\n", count, result_faces_body[count-1][i], result_image_width[count-1]);
      }
   }

   fclose( output_fd );
   
}

int ca_load_ledger_index(int mode)
{
   char *output_fn = NULL;

   if ( !ca_has_body() ) {
      return 0;
   }
   
   if ( mode == 0 ) { // body
      output_fn = "result_seg_ledger_body.txt";
   } else {
      output_fn = "result_seg_ledger_roof.txt";
   }

   if (!file_exist(output_fn)) {
      output_fn = "result_seg_body_roof.txt";
   }
   
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_str[1000];
   int ledger_index = -1;
   while (fgets(index_str, 1000, output_fd ) ) {
      assert(sscanf(index_str, "%d", &ledger_index ) == 1);
      break;
   }
   fclose(output_fd);

   return ledger_index;
}


void ca_load_roof_seg_regions(char *output_fn, vector<vector<int> * > &vec_regions)
{
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      return;
      //assert(0);
   }
   char index_str[1000];
   int ledger_index = -1;
   int total_region = -1;
   vector<int> *vec_pts = NULL;
   while (fgets(index_str, 1000, output_fd ) ) {
      if ( sscanf(index_str, "Total %d", &total_region) == 1)
         continue;
      if ( sscanf(index_str, "ImageSize %d %d", &image_width, &image_height) == 2)
         continue;
      
      if ( index_str[0] == 'R' ) {
         if (vec_pts )
            vec_regions.push_back(vec_pts);
         vec_pts = new vector<int> ();
         continue;
      }

      int x, y;
      if (sscanf(index_str, "%d %d", &x, &y) == 2) {
         vec_pts->push_back(index(x, y));
      }
   }
   if ( vec_pts ) // push the last one
      vec_regions.push_back(vec_pts);
   
   fclose(output_fd);
}

// FUNTION: ca_dump_segmented_body_roof_roof_part
//
// dump the roof data and split them to different regions.
// this only works for data bottom-up direction is along z axis.
void ca_dump_segmented_body_roof_roof_part()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *prefix_dumping = NULL;
   if ( !readRunTimeFlag("result_segment_roof_prefix", &prefix_dumping) ) {
      prefix_dumping = "point_cloud_region";
   }

   {
      char fn_tmp[1000];
      sprintf(fn_tmp, "%s_0.txt", prefix_dumping);
      if ( file_exist(fn_tmp) )
         return;
   }

   // load roof ledger if any
   int ledger_index = ca_load_ledger_index(1);
   
   // load roof unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag("result_segment_roof_region", &region_fn) )
      region_fn = "result_seg_roof_regions.txt";
   
   vector<vector<int>* > vec_regions;
   ca_load_roof_seg_regions(region_fn, vec_regions);

   // test the loading
#if 0   
   BYTE ***im = new_3D_image(image_height, image_width);
   for (int i = 0; i < vec_regions.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions[i]), all_pts);
      int r = rand() % 255;
      int g = rand() % 255;
      int b = rand() % 255;
      for (int j = 0; j < all_pts.size(); j ++)
         set_color(im, y_axis(all_pts[j]), x_axis(all_pts[j]), r, g, b);
   }
   Save2File("test_loading.png", NULL, NULL, image_width, image_height, 1, im);
   free_image_3D(im);
#endif   

   st_table *st_pts_2_region_id = st_init_table(st_numcmp, st_numhash);
   
   // mark the points inside the region
   char **file_name = (char **)malloc(sizeof(char *)*vec_regions.size());
   FILE **fd_region = (FILE **)malloc(sizeof(FILE *)*vec_regions.size());
      
   for (int i = 0; i < vec_regions.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions[i]), all_pts);
      for (int j = 0; j < all_pts.size(); j ++)
         st_insert(st_pts_2_region_id, (char *)all_pts[j], (char *)i);

      file_name[i] = (char *)malloc(1000);
      sprintf(file_name[i], "%s_%d.txt", prefix_dumping, i);

      if ( file_exist(file_name[i]) )
         return;
      
      fd_region[i] = fopen(file_name[i], "w");
      assert(fd_region[i]);
   }
   
   float ledger_height;
   float x, X, y, Y, z, Z;
   if (ledger_index != -1) {
      ca_load_aux_top_level("bottom_up");
      assert(readRunTimeFlag("box_bottom_up", &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      int total_slices = 1000;
      if (readRunTimeFlag("total_slices", &value) )
         total_slices = atoi(value);
      
      assert(readRunTimeFlag("slices_bottom_up_dimension", &value));
      assert(sscanf(value, "%dx%d", &image_width, &image_height) == 2);
      
      ledger_height = z + (Z - z)*((float)ledger_index/total_slices); // 3D coord of Z.
   }

   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fd = fopen(value, "r");
   assert(fd);

   char x_s[30], y_s[30], z_s[30];
   double x_f, y_f, z_f;
   vector<double> data;
   printf("loading data from file...\n");
   int total_roof = 0, mapping_roof = 0, total_pts = 0;
   float diff_x = X - x;
   float scale = image_width / diff_x;
   char str_line[1000];
   while (fgets(str_line, 1000, fd))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         total_pts ++;
         x_f = atof(x_s);
         y_f = atof(y_s);
         z_f = atof(z_s);
      } else
         continue;

      if ( z_f < ledger_height ) {
         continue;
      }

      total_roof ++;

      int x_i = (int)(((x_f - x)/diff_x)*image_width  + .5); // x
      int y_i = image_height - (int)((y_f - y) * scale + .5) - 1; // y

      int *rid;
      if ( valid_pixel(x_i, y_i) && st_lookup(st_pts_2_region_id, (char *)index(x_i, y_i), (char **)&rid) ) {
         fprintf(fd_region[(int)rid], "%s", str_line);
         mapping_roof ++;
      }
      
   }

   printf("Total: %d, Roof: %d, Mapped Roof: %d\n", total_pts, total_roof, mapping_roof);
   for ( int i = 0; i < vec_regions.size(); i ++) {
      fclose(fd_region[i]);
   }

}


// FUNTION: ca_dump_segmented_body_roof_body_part
//
// dump the body data and split them to different regions.
// this only works for data bottom-up direction is along z axis.
void ca_dump_segmented_body_roof_body_part()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *prefix_dumping = NULL;
   if ( !readRunTimeFlag("result_segment_body_prefix", &prefix_dumping) ) {
      prefix_dumping = "point_cloud_region_body";
   }

   {
      char fn_tmp[1000];
      sprintf(fn_tmp, "%s_0.txt", prefix_dumping);
      if ( file_exist(fn_tmp) )
         return;
   }

   // load roof ledger if any
   int ledger_index = ca_load_ledger_index(0);
   
   // load body unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag("result_segment_body_region", &region_fn) )
      region_fn = "result_seg_body_regions.txt";
   
   vector<vector<int>* > vec_regions;
   FILE *fd_body = NULL;
   FILE **fd_region = (FILE **)malloc(sizeof(FILE *)*vec_regions.size());
   st_table *st_pts_2_region_id = st_init_table(st_numcmp, st_numhash);
   
   if ( !file_exist(region_fn) ) {
      
      char body_fn[1000];
      sprintf(body_fn, "%s_0.txt", prefix_dumping);
      fd_body = fopen(body_fn, "w");
      assert(fd_body);
      
   } else {
   
      ca_load_roof_seg_regions(region_fn, vec_regions);

      // test the loading
#if 0
      BYTE ***im = new_3D_image(image_height, image_width);
      for (int i = 0; i < vec_regions.size(); i ++) {
         vector<int> all_pts;
         fill_polygon(*(vec_regions[i]), all_pts);
         int r = rand() % 255;
         int g = rand() % 255;
         int b = rand() % 255;
         for (int j = 0; j < all_pts.size(); j ++)
            set_color(im, y_axis(all_pts[j]), x_axis(all_pts[j]), r, g, b);
      }
      Save2File("test_loading.png", NULL, NULL, image_width, image_height, 1, im);
      free_image_3D(im);
#endif   

      // mark the points inside the region
      char **file_name = (char **)malloc(sizeof(char *)*vec_regions.size());
      
      for (int i = 0; i < vec_regions.size(); i ++) {
         vector<int> all_pts;
         fill_polygon(*(vec_regions[i]), all_pts);
         for (int j = 0; j < all_pts.size(); j ++)
            st_insert(st_pts_2_region_id, (char *)all_pts[j], (char *)i);

         file_name[i] = (char *)malloc(1000);
         sprintf(file_name[i], "%s_%d.txt", prefix_dumping, i);

         if ( file_exist(file_name[i]) )
            return;
      
         fd_region[i] = fopen(file_name[i], "w");
         assert(fd_region[i]);
      }

   }
   
   float ledger_height;
   float x, X, y, Y, z, Z;
   if (ledger_index != -1) {
      ca_load_aux_top_level("bottom_up");
      assert(readRunTimeFlag("box_bottom_up", &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      int total_slices = 1000;
      if (readRunTimeFlag("total_slices", &value) )
         total_slices = atoi(value);

      assert(readRunTimeFlag("slices_bottom_up_dimension", &value));
      assert(sscanf(value, "%dx%d", &image_width, &image_height) == 2);
      
      ledger_height = z + (Z - z)*((float)ledger_index/total_slices); // 3D coord of Z.
   }

   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fd = fopen(value, "r");
   assert(fd);

   char x_s[30], y_s[30], z_s[30];
   double x_f, y_f, z_f;
   vector<double> data;
   printf("loading data from file...\n");
   int total_roof = 0, mapping_roof = 0, total_pts = 0;
   float diff_x = X - x;
   float scale = image_width / diff_x;
   char str_line[1000];
   while (fgets(str_line, 1000, fd))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         total_pts ++;
         x_f = atof(x_s);
         y_f = atof(y_s);
         z_f = atof(z_s);
      } else
         continue;

      if ( z_f >= ledger_height ) {
         continue;
      }

      total_roof ++;

      if ( !fd_body ) {

         int x_i = (int)(((x_f - x)/diff_x)*image_width  + .5); // x
         int y_i = image_height - (int)((y_f - y) * scale + .5) - 1; // y
         
         int *rid;
         if ( valid_pixel(x_i, y_i) && st_lookup(st_pts_2_region_id, (char *)index(x_i, y_i), (char **)&rid) ) {
            fprintf(fd_region[(int)rid], "%s", str_line);
            mapping_roof ++;
         }
      } else {
         fprintf(fd_body, "%s", str_line);
         mapping_roof ++;
      }
      
   }

   printf("Total: %d, Body: %d, Mapped Body: %d\n", total_pts, total_roof, mapping_roof);

   for ( int i = 0; i < vec_regions.size(); i ++) {
      fclose(fd_region[i]);
   }

   if (fd_body)
      fclose(fd_body);

}

// FUNTION: ca_dump_segmented_body_roof_ledger_part
//
// dump the body data and split them to different regions.
// this only works for data bottom-up direction is along z axis.
void ca_dump_segmented_body_roof_ledger_part()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *prefix_dumping = "point_cloud_ledger_region";

   {
      char fn_tmp[1000];
      sprintf(fn_tmp, "%s_0.txt", prefix_dumping);
      if ( file_exist(fn_tmp) )
         return;
   }

   // load roof ledger if any
   char *ledger_fn = "result_seg_ledger.txt";
   if ( !file_exist(ledger_fn) )
      return;
   
   vector<int>* vec_regions = ca_load_simple_vector(ledger_fn);

   st_table *st_pts_2_region_id = st_init_table(st_numcmp, st_numhash);
   
   int total_slices = 1000;
   float x, X, y, Y, z, Z;
   {
      ca_load_aux_top_level("bottom_up");
      assert(readRunTimeFlag("box_bottom_up", &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      if (readRunTimeFlag("total_slices", &value) )
         total_slices = atoi(value);
   }

   // mark the points inside the region
   assert(vec_regions->size() % 2 == 0 );
   char **file_name = (char **)malloc(sizeof(char *)*(vec_regions->size() / 2));
   FILE **fd_region = (FILE **)malloc(sizeof(FILE *)*(vec_regions->size() / 2));
      
   vector<vector<float> *> vec_ledger_regions;
   for (int i = 0; i < vec_regions->size(); i +=2 ) {
      vector<float> *vec_reg = new vector<float> ();
      
      float ledger_lo = z + (Z - z)*((float)(vec_regions->at(i))/total_slices);
      float ledger_hi = z + (Z - z)*((float)(vec_regions->at(i+1))/total_slices);

      vec_reg->push_back(ledger_lo);
      vec_reg->push_back(ledger_hi);
      vec_ledger_regions.push_back(vec_reg);

      file_name[i] = (char *)malloc(1000);
      sprintf(file_name[i], "%s_%d.txt", prefix_dumping, i);

      if ( file_exist(file_name[i]) )
         return;
      
      fd_region[i] = fopen(file_name[i], "w");
      assert(fd_region[i]);
      
   }
   

   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fd = fopen(value, "r");
   assert(fd);

   char x_s[30], y_s[30], z_s[30];
   double x_f, y_f, z_f;
   vector<double> data;
   printf("loading data from file...\n");
   int mapping_roof = 0, total_pts = 0;
   float diff_x = X - x;
   float scale = image_width / diff_x;
   char str_line[1000];
   while (fgets(str_line, 1000, fd))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         total_pts ++;
         x_f = atof(x_s);
         y_f = atof(y_s);
         z_f = atof(z_s);
      } else
         continue;

      int rid = -1;

      for (int i = 0; i < vec_ledger_regions.size(); i ++) {
         float le_lo = vec_ledger_regions[i]->at(0);
         float le_hi = vec_ledger_regions[i]->at(1);
         if ( z_f >= le_lo && z_f <= le_hi ) {
            rid = i;
            break;
         }
      }
      
      if ( rid == -1 ) {
         continue;
      }

      {
         fprintf(fd_region[rid], "%s", str_line);
         mapping_roof ++;
      }
      
   }

   printf("Total: %d, Mapped Body: %d\n", total_pts,  mapping_roof);
   for ( int i = 0; i < vec_ledger_regions.size(); i ++) {
      fclose(fd_region[i]);
   }

}

// FUNTION: ca_dump_segmented_body_roof
//
// dump the roof data and split them to different regions.
// this only works for data bottom-up direction is along z axis.
void ca_dump_segmented_body_roof()
{
   printf("\n\nMODULE - ca_dump_segmented_body_roof(): \n\n");
   
   ca_dump_segmented_body_roof_roof_part();
   ca_dump_segmented_body_roof_body_part();
   ca_dump_segmented_body_roof_ledger_part();
}


bool ca_has_significant_change(BYTE **ref_im, BYTE **cur_im,
                               int h, int w,
                               int matching_approach,
                               float hd_thresh, float per_thres,
                               int mode = 1)
{
   if (ref_im == cur_im)
      return false;

   if (matching_approach == 0)  // Hausdorff distance approach
   {
      // compute the Hausdorff distance between the images
      vector<int> *v1 = compute_Hausdorff(ref_im, cur_im, h, w);
      vector<int> *v2 = compute_Hausdorff(cur_im, ref_im, h, w);

      sort(v1->begin(), v1->end(), greater<int>());
      sort(v2->begin(), v2->end(), greater<int>());      

      // for testing - compare the hausdorff distance - better use emacs.
      //for (int i = 0; i < v1->size(); i ++)
      // fprintf(comp_res, "%3d",  (*v1)[i]);

      // based on observation, 10% is the best ratio for comparison.
      // compute the average value for the 10% biggest distance.
      // e.g., use 83 as reference image, the average value until 92 is 1.2-1.5,
      // starting from 93, it is 5.x - 6.x.. If use 93 as reference, the average
      // value until 115 around 3.x. so use the middle vale 4-4.5 as the threshold.
      
      // 2.0 - KEY THRESHOLD ...
      char *value;
      float HD_THRESH = hd_thresh;

      // 0.1 - KEY THRESHOLD ...
      double data_per = per_thres;
      double average_dis  = average_HD(v1, data_per);
      double average_dis2 = average_HD(v2, data_per);

      delete v1;
      delete v2;
      

      float overall_distance = 0.0;

      switch (mode) {
         case 0: 
            overall_distance =  min(average_dis, average_dis2);
            break;
         case 1:
            overall_distance =  max(average_dis, average_dis2);
            break;
         case 2:
            overall_distance =  (average_dis + average_dis2)/2;
            break;
         default:
            printf("ERROR: you have to specify mode between 0 and 2.");
            exit(0);
      }

      printf("OVERALL distance is %.3f.\n", overall_distance);

      if ( overall_distance > HD_THRESH )
         return true;

      return false;
      
   }
}

/*
  FUNCTION: ca_compute_shape_type_slices

  
  compute the segment unit to locate those extrusion ones and tapered ones.
  compute the similarity among slices. for d_HD_ref and d_HD_new, pick up
  the smaller one as the distance. and update the reference image as the one
  with more pixels.
  this will guarantee that if new parts are added, the distance is small.
  the output is a text file containing the shape(extrusion/taper).

  Threshold:
  0. HD_THRESH - 5.0 in ca_has_significant_change(); 1.0 - percentage considered in the comparison.
  1. reference image update [0.9, 2.0]
  
*/
int ca_compute_shape_type_slices(int type_slice, char *sub_folder)
{
   int padding = (int) (type_slice * 0.1);
   BYTE **ref_im = NULL;
   int shape_type = 0; // extrusion
   int step = 5;
   for (int slice_id = padding; slice_id < type_slice - padding; slice_id += step ) {
      char *ds = digit_string(4, slice_id);
      char fn[1000];
      sprintf(fn, "%s/image_slice_%s.png", sub_folder, ds);
      int h, w;
      BYTE **im = load_image_array(fn, h, w);
      if ( ref_im == NULL ) {
         ref_im = im;
         continue;
      }

      printf("image %s with ", fn);
      float HD_THRESH = 5.0;
      char *value;
      if ( readRunTimeFlag("segment_shape_HD_similiar", &value) ) {
         HD_THRESH = atof(value);
      }
      
      if ( ca_has_significant_change (ref_im, im, h, w, 0, HD_THRESH, 1.0) ) {
         printf("Found a significant change at %s\n", fn);
         shape_type = 1;
         free_image(ref_im);
         free_image(im);
         break;
      } else {
         // update ref_im if needed;
         /*
         int new_num = count_image_data_points(im);
         int ref_num = count_image_data_points(ref_im);
         if ( new_num * 0.9 > ref_num ||  // here, if a big trunk is found, use it only once, otherwise, the computation will be very slow.
              new_num * 2.0 < ref_num ) {
            free_image(ref_im);
            ref_im = im;
         } else {
            free_image(im);
         }
         */
         free_image(im);
      }
      printf("\n");
   }

   return shape_type;
}

/*
 FUNCTION: ca_infer_segment_structure

 infer the structure for each sub unit of a roof. and then combine them into a roof
 Algorithm:
     1. locate the units need to be special cared. compute the similarity bottom-up, collect
         all units which have special structure.
     2. for each special unit, figure out whether it is an extrusion from the other side or a tapered
        structure.
     3. for tapered structure, do something special to model it.
     4. merge edges and vertices for adjacent sub-units.
*/
void ca_infer_segment_structure(int mode)
{
   char *value;
   char *result_fn, *result_fn_flag;
   char *result_seg_reg, *result_seg_reg_flag;
   char *result_prev, *result_prev_flag;
   char *result_reg_face_flag, *result_reg_face;
   char *ctrl_dump_flag, *ctrl_infer_flag, *ctrl_infer_taper_flag;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      result_fn             = "result_seg_body_regtypes_2.txt";
      result_fn_flag        = "result_segment_body_reg_types_2";
      result_prev           = "result_seg_body_regtypes.txt";
      result_prev_flag      = "result_segment_body_reg_types";
      result_seg_reg        = "result_seg_body_regions.txt";
      result_seg_reg_flag   = "result_segment_body_region";
      result_reg_face       = "result_seg_body_region_faces.txt";
      result_reg_face_flag  = "result_segment_body_region_faces";
      prefix_dumping        = "point_cloud_body_region";

      ctrl_dump_flag        = "do_body_inference_dump_images";
      ctrl_infer_flag       = "do_body_inference_infer_shape";
      ctrl_infer_taper_flag = "do_body_inference_taper_extrusion";
   }
   else if ( mode == 1 ) {
      result_fn             = "result_seg_roof_regtypes_2.txt";
      result_fn_flag        = "result_segment_roof_reg_types_2";
      result_prev           = "result_seg_roof_regtypes.txt";
      result_prev_flag      = "result_segment_roof_reg_types";
      result_seg_reg        = "result_seg_roof_regions.txt";
      result_seg_reg_flag   = "result_segment_roof_region";
      result_reg_face       = "result_seg_roof_region_faces.txt";
      result_reg_face_flag  = "result_segment_roof_region_faces";
      prefix_dumping        = "point_cloud_roof_region";

      ctrl_dump_flag        = "do_roof_inference_dump_images";
      ctrl_infer_flag       = "do_roof_inference_infer_shape";
      ctrl_infer_taper_flag = "do_roof_inference_taper_extrusion";
         
   }
   else {
      result_fn             = "result_seg_ledger_regtypes_2.txt";
      result_fn_flag        = "result_segment_ledger_reg_types_2";
      result_prev           = "result_seg_ledger_regtypes.txt";
      result_prev_flag      = "result_segment_ledger_reg_types";
      result_seg_reg        = "result_seg_ledger_regions.txt";
      result_seg_reg_flag   = "result_segment_ledger_region";
      result_reg_face       = "result_seg_ledger_region_faces.txt";
      result_reg_face_flag  = "result_segment_ledger_region_faces";
      prefix_dumping        = "point_cloud_ledger_region";

      ctrl_dump_flag        = "do_ledger_inference_dump_images";
      ctrl_infer_flag       = "do_ledger_inference_infer_shape";
      ctrl_infer_taper_flag = "do_ledger_inference_taper_extrusion";
         
   }

   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *reg_type_fn;
   if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
      reg_type_fn = result_fn;

   if ( file_exist(reg_type_fn) )
      return;
      
   int is_onetimeJobEnabled = 0;
   if ( readRunTimeFlag("do_one_time_job", &value ) ) {
      is_onetimeJobEnabled = atoi(value);
   }
   
   // load roof unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag(result_seg_reg_flag, &region_fn) )
      region_fn = result_seg_reg;
   
   vector<vector<int>* > vec_regions;

   int total_regions = 1;
   if ( file_exist(region_fn) ) {
      ca_load_roof_seg_regions(region_fn, vec_regions);
      total_regions = vec_regions.size();
   }

   // compute the underline structure for each unit
   // create folder for each dataset.
   // project the data to image with total 20 to check whether we need further process or not.

   const int type_slice = 100;
   char folder_name[1000], cmd[1000], sub_folder[1000];

   if ( !readRunTimeFlag( ctrl_dump_flag, &value ) || strcmp(value, "1") == 0) {
      
      for ( int region_id = 0; region_id < total_regions; region_id ++ ) {
         sprintf(folder_name, "%s_%d", prefix_dumping, region_id);

         if ( !file_exist(folder_name) ) {
            sprintf(cmd, "mkdir %s", folder_name);
            system(cmd);
         }

#ifndef LINUX               
         sprintf(sub_folder, "%s\\slice_for_type", folder_name);
#else
         sprintf(sub_folder, "%s/slice_for_type", folder_name);
#endif         
         if ( !file_exist(sub_folder) ) {
            sprintf(cmd, "mkdir %s", sub_folder);
            system(cmd);
         } else {
            continue;
         }

         char tmp[1000];
         sprintf(tmp, "%s/image_slice_0000.png", sub_folder);
         if ( file_exist(tmp) )
            continue;
       

         // 1. get the range of [x X], [y Y].
         // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
         // 3. dump the image in folder_name/slice_for_type
         char data_fn[1000];
         sprintf(data_fn, "%s_%d.txt", prefix_dumping, region_id);
         vector<double> data_pts;
         vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
         float x_min = vec_bounding_box->at(0);
         float x_max = vec_bounding_box->at(1);
         float y_min = vec_bounding_box->at(2);
         float y_max = vec_bounding_box->at(3);
         float z_min = vec_bounding_box->at(4);
         float z_max = vec_bounding_box->at(5);
         float diff_x = x_max - x_min;
         float diff_y = y_max - y_min;

         {
            float *params = (float *) malloc (sizeof(float) * 6 );
            params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
            ca_update_aux_for_each_unit(folder_name, "ca_aux_bounding_box", (void *)params, 6);
            free(params);
         }

         int h, w, t;
         const int LARGE = 1024;
         float scale = diff_x /diff_y;
         if ( scale > 1 )
            scale = 1 / scale;
         scale = scale * LARGE;
         t = (int) (scale + .5);
         t += ( 8 - (t % 8));
      
         if ( diff_x > diff_y ) {
            w = LARGE;
            h = t;
         } else {
            w = t;
            h = LARGE;
         }
         printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
         image_width = w;
         image_height = h;

         {
            int *params = (int *) malloc (sizeof(int) * 2 );
            params[0] = w; params[1] = h;
            ca_update_aux_for_each_unit(folder_name, "ca_aux_image_size", (void *)params, 2);

            params[0] = type_slice;
            ca_update_aux_for_each_unit(folder_name, "ca_aux_total_slices", (void *)params, 1);
            free(params);
         }


         // dump the data into image


         // let use 10% for imaging
         x_min -= diff_x * .1;
         x_max += diff_x * .1;
         y_min -= diff_y * .1;
         y_max += diff_y * .1;
      
         project_point_cloud_into_image(data_pts, sub_folder,
                                        1, type_slice,
                                        x_min, x_max, y_min, y_max, z_min, z_max);

      }
   } // end of dumping

   if ( !readRunTimeFlag( ctrl_infer_flag, &value ) || strcmp(value, "1") == 0) {
      
      char *reg_type_fn;
      if ( !readRunTimeFlag(result_prev_flag, &reg_type_fn) )
         reg_type_fn = result_prev;
      FILE *type_fd = fopen(reg_type_fn, "w");
      assert(type_fd);
   
      // load faces for each region
      char *reg_face_fn;
      if ( !readRunTimeFlag(result_reg_face_flag, &reg_face_fn) )
         reg_face_fn = result_reg_face; 
      FILE *face_fd = fopen(reg_face_fn, "r");
      assert(face_fd);
      vector<vector<int> * > vec_seg_faces;
      char str[1000];
      while (fgets(str, 1000, face_fd) ) {
         char *seg_name = strtok(str, " ");
         int seg_id;
         assert(sscanf(seg_name, "region_%d", &seg_id) == 1);
         vector<int> * vec_faces = new vector<int> ();
         vec_seg_faces.push_back(vec_faces);

         char *face_id = strtok(NULL, " ");
         while ( face_id) {
            vec_faces->push_back(atoi(face_id));
            face_id = strtok(NULL, " ");
         }
      }
      fclose(face_fd);


      for ( int region_id = 0; region_id < total_regions; region_id ++ ) 
      {
         sprintf(folder_name, "%s_%d", prefix_dumping, region_id);
#ifndef LINUX               
         sprintf(sub_folder, "%s\\slice_for_type", folder_name);
#else
         sprintf(sub_folder, "%s/slice_for_type", folder_name);
#endif         
         // compute the shape of this segment from bottom-up

         if ( total_regions == 1 && mode == 0) {
            fprintf(type_fd, "segment_0 0\n");
            break;
         }
         
         int shape_type = ca_compute_shape_type_slices(type_slice, sub_folder);
         fprintf(type_fd, "segment_%d %d", region_id, shape_type);
         
         // output the segment units with types, like this:
         // segment_0  0 
         // segment_1  1 x y // 0: extrusion 1: tapered  x, y: the faces this segment touched.

         // compute the faces touched by this segment.
         // we should log this information at the time of segment image computation.
         if ( shape_type != 0 ) {
            vector<int> *vec_faces = vec_seg_faces[region_id];
            for ( int i = 0; i < vec_faces->size(); i ++ )
               fprintf(type_fd, " %d", (*vec_faces)[i]);
         }
        
         fprintf(type_fd, "\n");

      }

      fclose(type_fd);
   }

   // for tapered ones, transform the data into another direction
   if ( !readRunTimeFlag( ctrl_infer_taper_flag, &value ) || strcmp(value, "1") == 0) {
      
      bool has_taper_structure = false;
      
      char *reg_type_fn;
      if ( !readRunTimeFlag(result_prev_flag, &reg_type_fn) )
         reg_type_fn = result_prev;
      FILE *type_fd = fopen(reg_type_fn, "r");
      assert(type_fd);

      // should we do the extrusion computation on extruded segments here?

      // load reg_type_fn;
      vector<vector<int> * > vec_segments;
      char str[1000];
      while (fgets(str, 1000, type_fd) ) {
         char *seg_name = strtok(str, " ");
         int seg_id;
         assert(sscanf(seg_name, "segment_%d", &seg_id) == 1);
         char *shape_type = strtok(NULL, " ");
         vector<int> * vec_faces = new vector<int> ();
         vec_segments.push_back(vec_faces);

         char *face_id = strtok(NULL, " ");
         while ( face_id) {
            vec_faces->push_back(atoi(face_id));
            face_id = strtok(NULL, " ");
         }

         if ( shape_type[0] == '1' ) {

            has_taper_structure = true;
            
            if (vec_faces->size() == 0) {
               printf("ERROR: for non-extrusion type, we should have face side values!!!!\n");
               exit(0);
            }
         }
            
      }
      fclose(type_fd);

      if ( has_taper_structure )
      {

         // transform the "tapered" structures computed at first round to other sides.
         // this is to check whether these structures would turn into extrusion from other sides.
      
         for ( int i = 0; is_onetimeJobEnabled && i < vec_segments.size(); i ++) {
            printf("segment %d: %s \n", i, vec_segments[i]->size() > 0 ? "Taper. " : "Extrusion");

            // get the segment point cloud, and then transform it.
            char seg_fn[1000], data_fn[1000], trans_matrix[1000];
            sprintf(seg_fn, "%s_%d.txt", prefix_dumping, i);
            sprintf(folder_name, "%s_%d", prefix_dumping, i);
            gbl_opts->input_prefix  = seg_fn;

            for (int j = 0; j < vec_segments[i]->size(); j ++ ) {
               int face_id = vec_segments[i]->at(j);

               sprintf(data_fn, "%s/%s_trans_%d.txt", folder_name, prefix_dumping, face_id);
               gbl_opts->output_prefix = data_fn;

               sprintf(trans_matrix, "face%d/trans.txt", face_id+1);

               printf("compute transformation for %s to %s\n", seg_fn, data_fn);
               compute_trans(trans_matrix);

               // now, let's do slicing (copy from above, need a function?)
            
               // create a folder for this face transform
#ifndef LINUX               
               sprintf(sub_folder, "%s\\slice_for_face%d", folder_name, face_id + 1);
#else
               sprintf(sub_folder, "%s/slice_for_face%d", folder_name, face_id + 1);
#endif
               
               if ( !file_exist(sub_folder) ) {
                  sprintf(cmd, "mkdir %s", sub_folder);
                  system(cmd);
               } else {
                  continue;
               }
            
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_type
               vector<double> data_pts;
               vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
               float x_min = vec_bounding_box->at(0);
               float x_max = vec_bounding_box->at(1);
               float y_min = vec_bounding_box->at(2);
               float y_max = vec_bounding_box->at(3);
               float z_min = vec_bounding_box->at(4);
               float z_max = vec_bounding_box->at(5);
               float diff_x = x_max - x_min;
               float diff_y = y_max - y_min;

               int h, w, t;
               const int LARGE = 1024;
               float scale = diff_x /diff_y;
               if ( scale > 1 )
                  scale = 1 / scale;
               scale = scale * LARGE;
               t = (int) (scale + .5);
               t += ( 8 - (t % 8));
      
               if ( diff_x > diff_y ) {
                  w = LARGE;
                  h = t;
               } else {
                  w = t;
                  h = LARGE;
               }
               printf("IMAGE SIZE: w - %d, h - %d  for segment %d of face %d\n", w, h, i, face_id);
               image_width = w;
               image_height = h;

               // dump the data into image


               // let use 10% for imaging
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
      
               project_point_cloud_into_image(data_pts, sub_folder,
                                              1, type_slice,
                                              x_min, x_max, y_min, y_max, z_min, z_max);

            }
         
         }

         // now compute what side may have extrusion operation for these segmented regions.

         if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
            reg_type_fn = result_fn;
         type_fd = fopen(reg_type_fn, "w");
         assert(type_fd);

         int face_id, shape_type;
         for ( int i = 0; is_onetimeJobEnabled && i < vec_segments.size(); i ++) {

            // get the segment point cloud, and then transform it.
            char seg_fn[1000], data_fn[1000], trans_matrix[1000];
            sprintf(folder_name, "%s_%d", prefix_dumping, i);

            face_id = -1;
            shape_type = 0;
            for (int j = 0; j < vec_segments[i]->size(); j ++ ) {
               face_id = vec_segments[i]->at(j);

               // create a folder for this face transform
               sprintf(sub_folder, "%s/slice_for_face%d", folder_name, face_id + 1);
               shape_type = ca_compute_shape_type_slices(type_slice, sub_folder);

               if ( shape_type == 0 ) {
                  break;
               }
      
            }

            if ( shape_type != 0 ) {
               fprintf(type_fd, "segment_%d %d\n", i, shape_type);
            }
            else {
               char face_str[10];
               if ( face_id == -1 )
                  strcpy(face_str, "");
               else
                  sprintf(face_str, " %d", face_id);
               fprintf(type_fd, "segment_%d 0%s\n", i, face_str);
            }
         
            printf("segment %d: %s \n", i, shape_type != 0 ? "Taper. " : "Extrusion.");

         }
         fclose(type_fd);


      } // if has_taper_structure
      else {
         // we have to copy result_seg_body_regtypes.txt to result_seg_body_regtypes_2.txt
         if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
            reg_type_fn = result_fn;
         type_fd = fopen(reg_type_fn, "w");
         assert(type_fd);

         fprintf(type_fd, "segment_0 0\n");
         fclose(type_fd);
      }
   }
}

void ca_infer_body_structure_inference()
{
   printf("\n\nMODULE: ca_infer_body_structure_inference() \n\n");
   
   if ( !ca_has_body() )
      return;
   
   ca_infer_segment_structure(0); // 0 : body 1: roof
}

void ca_infer_roof_structure_inference()
{
   printf("\n\nMODULE: ca_infer_roof_structure_inference() \n\n");
   
   ca_infer_segment_structure(1); // 0 : body 1: roof
}

void ca_infer_ledger_structure_inference()
{
   printf("\n\nMODULE: ca_infer_ledger_structure_inference() \n\n");
   
   if ( !ca_has_body() )
      return;
   
   ca_infer_segment_structure(2); // 0 : body 1: roof
}

/*
 FUNCTION: ca_infer_body_extruded_structure

 infer the structure for each sub unit of a body. and then combine them into a body
 Algorithm:
     1. locate the units need to be special cared. compute the similarity bottom-up, collect
         all units which have special structure.
     2. for each special unit, figure out whether it is an extrusion from the other side or a tapered
        structure.
     3. for tapered structure, do something special to model it.
     4. merge edges and vertices for adjacent sub-units.
*/
#if 0
// to be removed
void ca_infer_body_extruded_structure()
{
   char *value;

   int is_onetimeJobEnabled = 1;
   if (readRunTimeFlag("do_one_time_job", &value ) ) {
      is_onetimeJobEnabled = atoi(value);
      
      if ( is_onetimeJobEnabled == 0 )
         return;
   }

   char *reg_type_fn;
   if ( !readRunTimeFlag("result_segment_body_reg_types_2", &reg_type_fn) )
      reg_type_fn = "result_seg_body_regtypes_2.txt";
   if ( file_exist(reg_type_fn) )
      return;
   
   
   printf("\n\nMODULE: ca_infer_body_extruded_structure() \n\n");

   // load roof ledger if any
   int ledger_index = ca_load_ledger_index();
   
   // load body unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag("result_segment_body_region", &region_fn) )
      region_fn = "result_seg_body_regions.txt";
   
   vector<vector<int>* > vec_regions;
   ca_load_roof_seg_regions(region_fn, vec_regions);

   // compute the underline structure for each unit
   // create folder for each dataset.
   // project the data to image with total 20 to check whether we need further process or not.
   int total_regions = vec_regions.size();
   char *prefix_dumping = NULL;
   if ( !readRunTimeFlag("result_segment_body_prefix", &prefix_dumping) ) {
      prefix_dumping = "point_cloud_body_region";
   }

   const int type_slice = 100;
   char folder_name[1000], cmd[1000], sub_folder[1000];

   if ( !readRunTimeFlag( "do_body_inference_dump_images", &value ) || strcmp(value, "1") == 0) {
      
      for ( int region_id = 0; region_id < total_regions; region_id ++ ) {
         sprintf(folder_name, "%s_%d", prefix_dumping, region_id);
         if ( !file_exist(folder_name) ) {
            sprintf(cmd, "mkdir %s", folder_name);
            system(cmd);
         }

#ifndef LINUX
         sprintf(sub_folder, "%s\\slice_for_type", folder_name);
#else
         sprintf(sub_folder, "%s/slice_for_type", folder_name);
#endif
         if ( !file_exist(sub_folder) ) {
            sprintf(cmd, "mkdir %s", sub_folder);
            system(cmd);
         } else {
            continue;
         }

         // 1. get the range of [x X], [y Y].
         // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
         // 3. dump the image in folder_name/slice_for_type
         char data_fn[1000];
         sprintf(data_fn, "%s_%d.txt", prefix_dumping, region_id);
         vector<double> data_pts;
         vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
         float x_min = vec_bounding_box->at(0);
         float x_max = vec_bounding_box->at(1);
         float y_min = vec_bounding_box->at(2);
         float y_max = vec_bounding_box->at(3);
         float z_min = vec_bounding_box->at(4);
         float z_max = vec_bounding_box->at(5);
         float diff_x = x_max - x_min;
         float diff_y = y_max - y_min;

         {
            float *params = (float *) malloc (sizeof(float) * 6 );
            params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
            ca_update_aux_for_each_unit(folder_name, "ca_aux_bounding_box", (void *)params, 6);
            free(params);
         }

         int h, w, t;
         const int LARGE = 1024;
         float scale = diff_x /diff_y;
         if ( scale > 1 )
            scale = 1 / scale;
         scale = scale * LARGE;
         t = (int) (scale + .5);
         t += ( 8 - (t % 8));
      
         if ( diff_x > diff_y ) {
            w = LARGE;
            h = t;
         } else {
            w = t;
            h = LARGE;
         }
         printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
         image_width = w;
         image_height = h;

         {
            int *params = (int *) malloc (sizeof(int) * 2 );
            params[0] = w; params[1] = h;
            ca_update_aux_for_each_unit(folder_name, "ca_aux_image_size", (void *)params, 2);

            params[0] = type_slice;
            ca_update_aux_for_each_unit(folder_name, "ca_aux_total_slices", (void *)params, 1);
            free(params);
         }

         // dump the data into image


         // let use 10% for imaging
         x_min -= diff_x * .1;
         x_max += diff_x * .1;
         y_min -= diff_y * .1;
         y_max += diff_y * .1;
      
         project_point_cloud_into_image(data_pts, sub_folder,
                                        1, type_slice,
                                        x_min, x_max, y_min, y_max, z_min, z_max);

      }
   } // end of dumping

   if ( !readRunTimeFlag( "do_body_inference_infer_shape", &value ) || strcmp(value, "1") == 0) {
      
      char *reg_type_fn;
      if ( !readRunTimeFlag("result_segment_body_reg_types", &reg_type_fn) )
         reg_type_fn = "result_seg_body_regtypes.txt";
      FILE *type_fd = fopen(reg_type_fn, "w");
      assert(type_fd);

      // load faces for each region
      char *reg_face_fn;
      if ( !readRunTimeFlag("result_segment_body_region_faces", &reg_face_fn) )
         reg_face_fn = "result_seg_body_region_faces.txt";
      FILE *face_fd = fopen(reg_face_fn, "r");
      assert(face_fd);
      vector<vector<int> * > vec_seg_faces;
      char str[1000];
      while (fgets(str, 1000, face_fd) ) {
         char *seg_name = strtok(str, " ");
         int seg_id;
         assert(sscanf(seg_name, "region_%d", &seg_id) == 1);
         vector<int> * vec_faces = new vector<int> ();
         vec_seg_faces.push_back(vec_faces);

         char *face_id = strtok(NULL, " ");
         while ( face_id) {
            vec_faces->push_back(atoi(face_id));
            face_id = strtok(NULL, " ");
         }
      }
      fclose(face_fd);
      
   
      for ( int region_id = 0; region_id < total_regions; region_id ++ ) 
      {
         sprintf(folder_name, "%s_%d", prefix_dumping, region_id);
#ifndef LINUX
         sprintf(sub_folder, "%s\\slice_for_type", folder_name);
#else         
         sprintf(sub_folder, "%s/slice_for_type", folder_name);
#endif
         // compute the shape of this segment from bottom-up
         
         int shape_type = ca_compute_shape_type_slices(type_slice, sub_folder);
         fprintf(type_fd, "segment_%d %d", region_id, shape_type);
         
         // output the segment units with types, like this:
         // segment_0  0 
         // segment_1  1 x y // 0: extrusion 1: tapered  x, y: the faces this segment touched.

         // compute the faces touched by this segment. LOAD from log file
         // we should log this information at the time of segment image computation.
         if ( shape_type != 0 ) {
            vector<int> *vec_faces = vec_seg_faces[region_id];
            for ( int i = 0; i < vec_faces->size(); i ++ )
               fprintf(type_fd, " %d", (*vec_faces)[i]);
         }
        
         fprintf(type_fd, "\n");
      }

      fclose(type_fd);
   }

   // for extrusion ones, compute the key slices
   // for tapered ones, transform the data into another direction
   if ( !readRunTimeFlag( "do_body_inference_taper_extrusion", &value ) || strcmp(value, "1") == 0) {

      bool has_taper_structure = false;
      
      char *reg_type_fn;
      if ( !readRunTimeFlag("result_segment_body_reg_types", &reg_type_fn) )
         reg_type_fn = "result_seg_body_regtypes.txt";
      FILE *type_fd = fopen(reg_type_fn, "r");
      assert(type_fd);

      // should we do the extrusion computation on extruded segments here?

      // load reg_type_fn;
      vector<vector<int> * > vec_segments;
      char str[1000];
      while (fgets(str, 1000, type_fd) ) {
         char *seg_name = strtok(str, " ");
         int seg_id;
         assert(sscanf(seg_name, "segment_%d", &seg_id) == 1);
         char *shape_type = strtok(NULL, " ");
         vector<int> * vec_faces = new vector<int> ();
         vec_segments.push_back(vec_faces);

         char *face_id = strtok(NULL, " ");
         while ( face_id) {
            vec_faces->push_back(atoi(face_id));
            face_id = strtok(NULL, " ");
         }

         if ( shape_type[0] == '1' ) {

            has_taper_structure = true;
            
            if (vec_faces->size() == 0) {
               printf("ERROR: for non-extrusion type, we should have face side values!!!!\n");
               exit(0);
            }
         }
            
      }
      fclose(type_fd);

      if ( has_taper_structure )
      {

         // transform the "tapered" structures computed at first round to other sides.
         // this is to check whether these structures would turn into extrusion from other sides.
      
         for ( int i = 0; is_onetimeJobEnabled && has_taper_structure && i < vec_segments.size(); i ++) {
            printf("segment %d: %s \n", i, vec_segments[i]->size() > 0 ? "Taper. " : "Extrusion");

            // get the segment point cloud, and then transform it.
            char seg_fn[1000], data_fn[1000], trans_matrix[1000];
            sprintf(seg_fn, "%s_%d.txt", prefix_dumping, i);
            sprintf(folder_name, "%s_%d", prefix_dumping, i);
            gbl_opts->input_prefix  = seg_fn;

            for (int j = 0; j < vec_segments[i]->size(); j ++ ) {
               int face_id = vec_segments[i]->at(j);

               sprintf(data_fn, "%s/%s_trans_%d.txt", folder_name, prefix_dumping, face_id);
               gbl_opts->output_prefix = data_fn;

               sprintf(trans_matrix, "face%d/trans.txt", face_id+1);

               printf("compute transformation for %s to %s\n", seg_fn, data_fn);
               compute_trans(trans_matrix);

               // now, let's do slicing (copy from above, need a function?)
            
               // create a folder for this face transform
#ifndef LINUX
               sprintf(sub_folder, "%s\\slice_for_face%d", folder_name, face_id + 1);
#else
               sprintf(sub_folder, "%s/slice_for_face%d", folder_name, face_id + 1);
#endif               

               if ( !file_exist(sub_folder) ) {
                  sprintf(cmd, "mkdir %s", sub_folder);
                  system(cmd);
               } else {
                  continue;
               }
            
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_type
               vector<double> data_pts;
               vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
               float x_min = vec_bounding_box->at(0);
               float x_max = vec_bounding_box->at(1);
               float y_min = vec_bounding_box->at(2);
               float y_max = vec_bounding_box->at(3);
               float z_min = vec_bounding_box->at(4);
               float z_max = vec_bounding_box->at(5);
               float diff_x = x_max - x_min;
               float diff_y = y_max - y_min;

               int h, w, t;
               const int LARGE = 1024;
               float scale = diff_x /diff_y;
               if ( scale > 1 )
                  scale = 1 / scale;
               scale = scale * LARGE;
               t = (int) (scale + .5);
               t += ( 8 - (t % 8));
      
               if ( diff_x > diff_y ) {
                  w = LARGE;
                  h = t;
               } else {
                  w = t;
                  h = LARGE;
               }
               printf("IMAGE SIZE: w - %d, h - %d  for segment %d of face %d\n", w, h, i, face_id);
               image_width = w;
               image_height = h;

               // dump the data into image


               // let use 10% for imaging
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
      
               project_point_cloud_into_image(data_pts, sub_folder,
                                              1, type_slice,
                                              x_min, x_max, y_min, y_max, z_min, z_max);

            }
         
         }

         // now compute what side may have extrusion operation for these segmented regions.

         if ( !readRunTimeFlag("result_segment_body_reg_types_2", &reg_type_fn) )
            reg_type_fn = "result_seg_body_regtypes_2.txt";
         type_fd = fopen(reg_type_fn, "a");
         assert(type_fd);

         int face_id, shape_type;
         for ( int i = 0; is_onetimeJobEnabled && i < vec_segments.size(); i ++) {

            // get the segment point cloud, and then transform it.
            char seg_fn[1000], data_fn[1000], trans_matrix[1000];
            sprintf(folder_name, "%s_%d", prefix_dumping, i);

            face_id = -1;
            shape_type = 0;
            for (int j = 0; j < vec_segments[i]->size(); j ++ ) {
               face_id = vec_segments[i]->at(j);

               // create a folder for this face transform
               sprintf(sub_folder, "%s/slice_for_face%d", folder_name, face_id + 1);
               shape_type = ca_compute_shape_type_slices(type_slice, sub_folder);

               if ( shape_type == 0 ) {
                  break;
               }
      
            }

            if ( shape_type != 0 ) {
               fprintf(type_fd, "segment_%d %d\n", i, shape_type);
            }
            else {
               char face_str[10];
               if ( face_id == -1 )
                  strcpy(face_str, "");
               else
                  sprintf(face_str, " %d", face_id);
               fprintf(type_fd, "segment_%d 0%s\n", i, face_str);
            }
         
            printf("segment %d: %s \n", i, shape_type != 0 ? "Taper. " : "Extrusion.");

         }
         fclose(type_fd);


#if 0  // do not do this until windows mask images have been computed.

         // load from the above file
         if ( is_onetimeJobEnabled )
         {
            type_fd = fopen(reg_type_fn, "r");
            assert(type_fd);
         
            vec_segments.clear();
            char str[1000];
            while (fgets(str, 1000, type_fd) ) {
               char *seg_name = strtok(str, " ");
               int seg_id;
               assert(sscanf(seg_name, "segment_%d", &seg_id) == 1);
               char *shape_type_str = strtok(NULL, " ");
               vector<int> * vec_faces = new vector<int> ();
               vec_segments.push_back(vec_faces);
               vec_faces->push_back(atoi(shape_type_str));
            
               char *face_id = strtok(NULL, " ");
               while ( face_id) {
                  vec_faces->push_back(atoi(face_id));
                  face_id = strtok(NULL, " ");
               }
            }
         
            int key_slice_id = type_slice / 2;
            char key_slice_fn[1000];
            char key_slice_vector_fn[1000];
            char *ds;
            BYTE **key_im;
         
            // compute the key slice for extrusion
            for ( int i = 0; i < vec_segments.size(); i ++) {
            
               sprintf(folder_name, "%s_%d", prefix_dumping, i);
               vector<int> *vec_face = vec_segments[i];
               shape_type = vec_face->at(0);
               face_id = -1;
               if ( vec_face->size() > 1 )
                  face_id = vec_face->at(1);

               printf("Segment %d, shape_type: %d, face_id %d\n", i, shape_type, face_id);

            
               if ( shape_type == 0 ) { // this is an extrusion from bottom-up or other sides

                  ds = digit_string(4, key_slice_id);
                  sprintf(key_slice_fn, "%s/image_slice_%s.png", folder_name, ds);
                  sprintf(key_slice_vector_fn, "%s/image_slice_%s.png", folder_name, ds);

                  // DO BPA
            
                  int h, w;
                  key_im = load_image_array(key_slice_fn, h, w);
                  //Save2File(key_slice_vector_fn, key_im, NULL, w, h, 0, NULL);
                  sprintf(key_slice_vector_fn, "%s/vec_image_slice_%s.png", folder_name, ds);
            
                  // set the parameters for BPA
                  {
                     //gbl_opts->BPA_parameter_file = NULL;
                     gbl_opts->BPA_need_do_refinement = 1;
                     gbl_opts->BPA_need_do_HT_BPA_combination = 0;
                     gbl_opts->radius = 32;
                     gbl_opts->radius_min = 4;
                     //gbl_opts->BPA_debug_mode = 0;
                     //gbl_opts->BPA_debug_image_interval = 100;
                     gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
                     //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
                     gbl_opts->BPA_do_not_check_turning_around = 1;
                     gbl_opts->BPA_starting_point_sweeping_dir = 1;
                     //gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
                     gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
                     gbl_opts->BPA_dump_the_vectors = 1;
                     gbl_opts->BPA_turning_around_angle = 50;
                     gbl_opts->BPA_merge_boundary_points = 1;
                     output_fn = key_slice_vector_fn;
                  }
            
                  array_t *boundary_array = array_alloc(deque<int> *, 0);
                  BPA_boundary_image(key_im, boundary_array);
                  draw_boundary_image(boundary_array, NULL, gbl_opts->radius, key_slice_vector_fn);
                  free_image(key_im);

                  printf("Key image %s saved!\n", key_slice_vector_fn);

               }
            }

            fclose(type_fd);
         }

#endif


      } // if has_taper_structure
      
   }

}
#endif


/*
  FUNCTION: ca_compute_keyslices

  
  compute the segment unit to locate those extrusion ones and tapered ones.
  compute the similarity among slices. for d_HD_ref and d_HD_new, pick up
  the smaller one as the distance. and update the reference image as the one
  with more pixels.
  this will guarantee that if new parts are added, the distance is small.
  the output is a text file containing the shape(extrusion/taper).

  Threshold:
  0. HD_THRESH - 5.0 in ca_has_significant_change()
  1. reference image update [0.9, 2.0]
  
*/
vector<int> *ca_compute_keyslices(int type_slice, char *sub_folder)
{
   // load configuration if existing.
   float hd_thresh = 8.0;
   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s/../", sub_folder);
      ca_load_aux_for_each_unit(tmp);
      if ( readRunTimeFlag("ca_aux_HD_threshold", &tmp_value) && !strcmp(tmp_value, "") == 0) {
         hd_thresh = atof(tmp_value);
      }
   }

   vector<int> *vec_result = new vector<int> ();
   
   //int padding = (int) (type_slice * 0.1);
   int padding = 0;
   BYTE **ref_im = NULL;
   int shape_type = 0; // extrusion
   for (int slice_id = 2 + padding; slice_id < type_slice - padding; slice_id ++ ) {
      char *ds = digit_string(4, slice_id);
      char fn[1000];
      sprintf(fn, "%s/image_slice_%s.png", sub_folder, ds);
      int h, w;
      BYTE **im = load_image_array(fn, h, w);
      if ( ref_im == NULL ) {
         ref_im = im;
         continue;
      }

      printf("image %s with ", fn);
      if ( ca_has_significant_change (ref_im, im, h, w, 0, hd_thresh, 1.0) ) {
         printf("\n\nFound a significant change [%.3f] at %s\n\n", hd_thresh, fn);
         vec_result->push_back(slice_id);
         free_image(ref_im);
         ref_im = im;
      } else {
         free_image(im);
         
         /*  we need not consider the big trunk for similarity of extrusion
             
         // update ref_im if needed;
         int new_num = count_image_data_points(im);
         int ref_num = count_image_data_points(ref_im);
         if ( new_num * 0.9 > ref_num ||  // here, if a big trunk is found, use it only once, otherwise, the computation will be very slow.
              new_num * 2.0 < ref_num ) {
            free_image(ref_im);
            ref_im = im;
            printf("\nEntering/Existing image with big trunk at %s\n", fn);
            
         } else {
            free_image(im);
         }
         */
      }
   }
   free_image(ref_im);

   if ( vec_result->size() == 0 || vec_result->at(vec_result->size() - 1) != type_slice - 1) {
      vec_result->push_back(type_slice - 1);
   }

   for (int i = 0; i < vec_result->size(); i ++ )
      printf("KEY : %d\n", (*vec_result)[i]);
   
   return vec_result;
}

// assumption:
//
// Only one taper structure existed.
//
vector<int> *ca_taper_infer_location(vector<int> *vec_keys)
{
   vector<int> *return_vec = new vector<int> ();

   printf(" entering ca_taper_infer_location\n");
   
   int num_saw =  0;
   int min_num =  4;
   int max_dis = 10;
   int started = -1, ended = -1;
   int ave_dif =  4;  // this is the threshold.
   int started_dis = -1;
   for (int i = 0; i < vec_keys->size() - 1; i ++ ) {
      int next_dis = (*vec_keys)[i+1] - (*vec_keys)[i];
      if ( next_dis > max_dis ) {
         if ( num_saw > min_num ) {
            break;
         } else {
            num_saw = 0;
            started = -1;
         }
         continue;
      }

      if ( started == -1 ) {
         started = i;
         started_dis = next_dis;
         num_saw ++;
         ended = i + 1;
         continue;
      }
         
      if ( abs((float)(started_dis - next_dis)) > ave_dif ) {
         num_saw = 0;
         started = -1;
      } else {
         num_saw ++;
         ended = i + 1;
      }

   }

   if ( num_saw > min_num ) {
      printf("Found a taper structure with %d keyslices: ", num_saw+1);
      for ( int k = started; k <= ended ; k ++ )
      {
         /*
         if ( k == 0 ) // let's ignore the first one.
            continue;
         */
         
         return_vec->push_back((*vec_keys)[k]);
         printf("%d ", (*vec_keys)[k]);
      }
      printf("\n");
   } else {

      printf("WARNING: No taper list found, how come?!!!\n");

   }
   
   return return_vec;
}


int ca_taper_infer_ttl_or_ttp(char *folder, vector<int> *vec_keys)
{
   char *value;
   int return_type = 0;  // 0: TTP, 1: TTL
   
   // compute the BPA for tapered keyslices.

   // create a folder if needed
   char bpa_folder[1000], cmd[1000];
#ifndef LINUX
   sprintf(bpa_folder, "%s\\..\\bpa_keyslices", folder);
#else
   sprintf(bpa_folder, "%s/../bpa_keyslices", folder);
#endif   
   if ( !file_exist( bpa_folder ) ) {
      printf("Creating folder %s...\n", bpa_folder);
      sprintf(cmd, "mkdir %s", bpa_folder);
      system(cmd);
   }

   int pre_key = vec_keys->at(0);
   int do_integration = 1;
   int radius_im = -1;
   int need_do_bpa = 1;
   for (int i_key = 0; need_do_bpa && i_key < vec_keys->size(); i_key ++ )
   {
      int cur_key = vec_keys->at(i_key);
      char *ds = digit_string(4, cur_key);
      char im_fn[1000], bpa_result_fn[1000], bpa_fn[1000], bpa_ht_fn[1000], bpa_ht_result_fn[1000];
      sprintf(im_fn, "%s/image_slice_%s.png", folder, ds);
      sprintf(bpa_result_fn, "%s/../bpa_keyslices/bpa_image_slice_%s.png", folder, ds);
      sprintf(bpa_ht_fn, "%s/../bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
      sprintf(bpa_ht_result_fn, "%s/../bpa_keyslices/HT_BPA_image_slice_%s_dumped_0.txt", folder, ds);
      sprintf(bpa_fn, "%s/../bpa_keyslices/image_slice_%s.png", folder, ds);

      if ( file_exist(bpa_result_fn) )
         continue;
      
      int h, w;
      BYTE **bpa_im;

      if ( readRunTimeFlag("do_not_dump_images_from_point_cloud", &value ) && strcmp(value, "1") == 0 || file_exist (bpa_fn)) {

         bpa_im = load_image_array(bpa_fn, h, w);

      } else {

         bpa_im = load_image_array(im_fn, h, w);
         
         if ( do_integration ) {
            while ( pre_key < cur_key ) {
               free(ds);
               ds = digit_string(4, pre_key);
               sprintf(im_fn, "%s/image_slice_%s.png", folder, ds);
               BYTE **tmp_im = load_image_array(im_fn, h, w);
               for ( int i = 0; i < h * w; i ++ )
                  bpa_im[0][i] |= tmp_im[0][i];
               free_image(tmp_im);
               pre_key ++;
            }
         }

         Save2File(bpa_fn, bpa_im, NULL, w, h, 0, NULL);
      }

      // This following worked great for CU data tapers.
      if ( radius_im == -1 ) {
         int cent = image_centroid(bpa_im);
         float dis = 0;
         int num_pts = 0;
         for (int i = 0; i < h*w; i ++ ) {
            if ( bpa_im[0][i] == BLACK ) {
               num_pts ++;
               float x = x_axis(i) - x_axis(cent);
               float y = y_axis(i) - y_axis(cent);
               dis += sqrt(x*x + y*y);
            }
         }

         radius_im = (int)(dis/num_pts);
         printf("Good radius would be: %d\n", radius_im);
      }
      assert(radius_im != -1 );
      
      // set the parameters for BPA
      {
         gbl_opts->BPA_need_do_refinement = 0;
         gbl_opts->BPA_need_do_HT_BPA_combination = 0;
         gbl_opts->radius = radius_im;
         gbl_opts->radius_min = 4;
         //gbl_opts->BPA_debug_mode = 0;
         //gbl_opts->BPA_debug_image_interval = 100;
         gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
         //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
         gbl_opts->BPA_do_not_check_turning_around = 1;
         gbl_opts->BPA_starting_point_sweeping_dir = 1;  // 2 from top, 1 from left
         //gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
         gbl_opts->BPA_simple_starting_point = 1;       // this is to assume a simple case.
         gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
         gbl_opts->BPA_dump_the_vectors = 1;
         //gbl_opts->BPA_turning_around_angle = 50;
         //gbl_opts->BPA_merge_boundary_points = 1;
         output_fn = strdup(bpa_result_fn); // for generating vector file

      }

      array_t *boundary_array = array_alloc(deque<int> *, 0);
      printf("Applying BPA on %s...\n", im_fn);
      BPA_boundary_image(bpa_im, boundary_array);
      draw_boundary_image(boundary_array, NULL, gbl_opts->radius, bpa_result_fn);
      ca_compute_merge_HT_on_BPA_result(bpa_ht_fn, bpa_ht_result_fn);
      
   }

   // load those IR to images and check TTL or TTP
   int test_num = 4;
   BYTE **pre_im = NULL;
   int start_num = 1; // sometimes, 0 and 1 have the same boundary.
   
   for (int i_key = 1; i_key < test_num && i_key < vec_keys->size(); i_key ++ )
   {
      int cur_key = vec_keys->at(i_key);
      char *ds = digit_string(4, cur_key);
      char im_fn[1000], bpa_result_fn[1000], bpa_ir_fn[1000];;
      sprintf(bpa_ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
      vector<int> all_lines;
      load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
      BYTE **im = get_image_from_vec_lines(all_lines, image_height, image_width);
      image_dilation(im);

      if ( i_key == start_num ) {
         pre_im = im;
         continue;
      }

      int match_pts = count_image_data_points(im, pre_im);
      int total_pts = count_image_data_points(im);

      free_image(pre_im);
      pre_im = im;
      
      if ( (float)match_pts/(float)total_pts > 0.1 ) {
         printf("Matching TTL on image %s to previous image.\n", bpa_ir_fn);
         return_type = 1;
         break;
      }

   }

   free_image(pre_im);

   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s/../", folder);
      ca_load_aux_for_each_unit(tmp);
      if ( readRunTimeFlag("ca_aux_taper_type", &tmp_value) ) {
         return_type = atoi(tmp_value);
         return return_type;
      }
   }
   
   printf("This taper structure is of \"%s\".\n", return_type ? "taper-to-line" : "taper-to_point");
   return return_type;
}


vector<int> * ca_taper_compute_ttp(char *folder, vector<int> *vec_keys, vector<float> *vec_height)
{
   vector<int> *return_vec = new vector<int> ();

   int load_center = -1;
   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s/../", folder);
      ca_load_aux_for_each_unit(tmp);

      int a, b;
      if ( readRunTimeFlag("ca_aux_taper_center", &tmp_value) ) {
         assert( sscanf(tmp_value, "%dx%d", &a, &b) == 2 );
         load_center = index(a, b);
      }
   }
   
   // load those IR to images and check TTL or TTP
   int test_num = 8;
   int base_key = -1;
   int base_cent = -1;
   float base_dist = -1.0;
   vector<float> vec_conv_height;
   vector<int> vec_base_ir;
   for (int i_key = 0; i_key < test_num && i_key < vec_keys->size(); i_key ++ )
   {
      int cur_key = vec_keys->at(i_key);
      char *ds = digit_string(4, cur_key);
      char im_fn[1000], bpa_result_fn[1000], bpa_ir_fn[1000];;
      sprintf(bpa_ir_fn, "%s/../bpa_keyslices/HT_BPA_image_slice_%s_dumped_0.txt", folder, ds);
      if ( !file_exist(bpa_ir_fn) ) {
         sprintf(bpa_ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
         assert( file_exist(bpa_ir_fn));
      }
      vector<int> all_lines;
      load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
      BYTE **im = get_image_from_vec_lines(all_lines, image_height, image_width);

      int cent = image_centroid(im);
      float dis = 0;
      int num_pts = 0;
      for (int i = 0; i < image_width * image_height; i ++ ) {
         if ( im[0][i] == BLACK ) {
            num_pts ++;
            float x = x_axis(i) - x_axis(cent);
            float y = y_axis(i) - y_axis(cent);
            dis += sqrt(x*x + y*y);
         }
      }
      float ave_dis = dis/num_pts;
      free_image(im);
      
      printf("Current center: %d, %d\n", x_axis(cent), y_axis(cent));
      if ( i_key == 0 ) {
         base_key = cur_key;
         base_cent = load_center == -1 ? cent : load_center;
         base_dist = ave_dis;
         vec_base_ir = all_lines;
         continue;
      }

      // the height is like this: h/H = 1 - d1/d2 <=> H-h/H = d1/d2  : h = cur_key - base_key
      // float converging_height = (cur_key - base_key)/(1 - ave_dis/base_dist);
      float converging_height = (vec_keys->at(i_key-1) - base_key)/(1 - ave_dis/base_dist);
      printf("The converging point height is : %f\n", converging_height);
      vec_conv_height.clear();
      vec_conv_height.push_back(converging_height);

   }

   // dump the boundary of the base image
   for (int i = 0; i < vec_base_ir.size(); i += 4) {
      int x0 = vec_base_ir[i];
      int y0 = vec_base_ir[i+1];
      int x1 = vec_base_ir[i+2];
      int y1 = vec_base_ir[i+3];
      if ( i == 0 ) {
         return_vec->push_back(index(x0, y0));
         return_vec->push_back(base_cent);
      }
      return_vec->push_back(index(x1, y1));
      return_vec->push_back(base_cent);
   }

   // update vec_height
   // let's just pick up the last one, to make things simple.
   // sort(vec_conv_height.begin(), vec_conv_height.end(), greater<float>());
   vec_height->push_back(1.0); // 1.0: taper
   vec_height->push_back(vec_keys->at(0)); 
   vec_height->push_back(vec_keys->at(0) + vec_conv_height[0]); // converging height

   float act_h = vec_keys->at(0) + vec_conv_height[0];
   if ( vec_keys->at(0) + vec_conv_height[0] > vec_keys->at(vec_keys->size() - 1) + 2.0)
      act_h = vec_keys->at(vec_keys->size() - 1) + 2.0;
   
   vec_height->push_back(act_h); // actual height

   if ( load_center != - 1 ) {
      int index_ca = vec_height->size() - 2;
      (*vec_height)[index_ca] = vec_keys->at(vec_keys->size() - 1);
      (*vec_height)[index_ca+1] = vec_keys->at(vec_keys->size() - 1);
   }
   
   printf("TTP Taper info: base height: %.3f, converging height: %.3f, actual: %.3f\n", (*vec_height)[1], (*vec_height)[2], (*vec_height)[3]);
   
   return return_vec;
}

vector<int> * ca_taper_compute_ttl(char *folder, vector<int> *vec_keys, vector<float> *vec_height)
{
   vector<int> *return_vec = new vector<int> ();

   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s/../", folder);
      ca_load_aux_for_each_unit(tmp);

      int x0, y0, x1, y1;
      if ( readRunTimeFlag("ca_aux_taper_center", &tmp_value) ) {
         assert( sscanf(tmp_value, "%dx%d_%dx%d", &x0, &y0, &x1, &y1) == 4 );

         // fill up the returning structure
         // load the BPA points
         // make sure:
         // 1. the 1st and 2nd vertex do not share the same converging point.
         // 2. the first pushed converging point is associated with the 1st base vertex.
         
         char *ds = digit_string(4, vec_keys->at(0));
         char bpa_ir_fn[1024];
         sprintf(bpa_ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
         vector<int> all_lines;
         load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
         printf("The base Taper file is %s, with vector len: %d, converting to [%d, %d] & [%d, %d]\n", bpa_ir_fn, all_lines.size(), x0, y0, x1, y1);
         int p_index = 0;
         bool need_second = false;
         for ( int i = 0; i < all_lines.size(); i +=4 ) {
            int x = all_lines[i];
            int y = all_lines[i+1];
            float d1 = sqrt((float) ( x-x0 )*(x-x0) + (y-y0)*(y-y0) );
            float d2 = sqrt((float) ( x-x1 )*(x-x1) + (y-y1)*(y-y1) );
            if ( i == 0 ) {
               p_index = ( d1 > d2 ) ? 1 : 0;
               continue;
            }
            
            int p_temp = ( d1 > d2 ) ? 1 : 0;
            if ( i == 4 && p_index != p_temp ) {
               need_second = false;
               return_vec->push_back(index(all_lines[0], all_lines[1]));
               return_vec->push_back(index(all_lines[0], all_lines[1])); // just a dummy push for i_pts ++.
            } else if ( i == 4 && p_index == p_temp ) {
               need_second = true;
            }
            return_vec->push_back(index(x, y));
            return_vec->push_back(index(x, y));
               
         }
         int len = all_lines.size();
         return_vec->push_back(index(all_lines[len-2], all_lines[len-1]));
         return_vec->push_back(index(all_lines[len-2], all_lines[len-1]));
         
         if ( need_second ) {
            return_vec->push_back(index(all_lines[2], all_lines[3]));
            return_vec->push_back(index(all_lines[2], all_lines[3]));
         }
         if ( p_index ) {
            return_vec->push_back(index(x1, y1));
            return_vec->push_back(index(x1, y1));
            return_vec->push_back(index(x0, y0));
            return_vec->push_back(index(x0, y0));
         } else {
            return_vec->push_back(index(x0, y0));
            return_vec->push_back(index(x0, y0));
            return_vec->push_back(index(x1, y1));
            return_vec->push_back(index(x1, y1));
         }
         if ( return_vec->size() != 14 ) {
            printf("WRONG: return_vec is of length %d. suppose to be 14\n", return_vec->size());
            assert(0);
         }

         // fill up vec_height
         vec_height->push_back(2.0); // 1.0: taper - TTP 2.0: taper - TTL
         vec_height->push_back(vec_keys->at(0)); 
         vec_height->push_back(vec_keys->at(vec_keys->size()-1)); // converging height
         vec_height->push_back(vec_keys->at(vec_keys->size()-1)); // actual height

         return return_vec;
      }
   }

   // load those IR to images and check TTL or TTP
   int test_num = 4;
   int base_key = -1;
   float base_dist, ave_dis;
   vector<int> vec_mp_base;            /* the mid-points of the base quadrangle */
   vector<int> vec_mp_index;           /* the indices of the base vertices for the corresponding mid-points */
   vector<int> vec_intersect_pts_base; /* the base vertices */
   vector<int> vec_base_order;         /* the order of the base vertics for the contour */
   vector<int> vec_base_converge;      /* the matched mid-point index for the base */
   vector<float> vec_conv_height;      /* the height array */
   int start_num = 1;
   for (int i_key = start_num; i_key < test_num && i_key < vec_keys->size(); i_key ++ )
   {
      int cur_key = vec_keys->at(i_key);
      char *ds = digit_string(4, cur_key);
      char im_fn[1000], bpa_result_fn[1000], bpa_ir_fn[1000];;
      sprintf(bpa_ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
      vector<int> all_lines;
      load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
      BYTE **orig_im = get_image_from_vec_lines(all_lines, image_height, image_width);

      int w = image_width;
      int h = image_height;
      int line_num = 0;
      int pdetect;
      int tetadetect;
      vector<int> temp;      
      vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
      BYTE **Imbinary = copy_image(orig_im, h, w);
      gbl_opts->BPA_clear_data_mask = 4;
      while (true)
      {
         my_HT(Imbinary, h, w, pdetect, tetadetect);
         
         // draw line on the image
         HT_get_two_points(pdetect, tetadetect, h, w, Imbinary, line_set);
         // printf("line_set.size() at iteration %d: %d\n", line_num, line_set.size());
         
         temp = find(*Imbinary,h*w, BLACK);
         if (temp.size() == 0) break;

         if ( ++ line_num >= 4 ) break;
      }

      if ( 1 ) // debug - print out HT images.
      {
         sprintf(bpa_result_fn, "%s/../bpa_keyslices/HT_image_slice_%s_dumped_0.png", folder, ds);
         write_lines_to_image(bpa_result_fn, line_set, h, w);
      }

      // compute the 4 points and 4 mid-points.
      assert(line_set.size() == 16);
      int total_intersect_pts = 0;
      vector<int> vec_intersect_pts;      /* the new intersection points */
      vector<int> vec_intersect_lines;    /* the line # intersected at the corresponding intersection point */
      for ( int i_line = 0; i_line < line_set.size() - 4; i_line += 4) {
         vector<int> *vec_l1 = new vector<int>();
         vector<int> *vec_l2 = new vector<int>();
         for (int k = 0; k < 4; k ++ )
            vec_l1->push_back(line_set[i_line+k]);

         for ( int sec_line = i_line + 4; sec_line < line_set.size(); sec_line += 4 ) {
            vec_l2->clear();
            for (int k = 0; k < 4; k ++ )
               vec_l2->push_back(line_set[sec_line+k]);

            vector<int> *share_pt = ca_compute_intersection_point(vec_l1, vec_l2);
            if ( share_pt && valid_pixel((*share_pt)[0], (*share_pt)[1]) ) {
               int x = (*share_pt)[0];
               int y = (*share_pt)[1];
               int pt = index(x, y);

               printf("The %dth intersection point: LINE %d|%d is: %d, %d.\n", total_intersect_pts, i_line/4, sec_line/4, x, y );
               vec_intersect_pts.push_back(pt);
               vec_intersect_lines.push_back(i_line/4);
               vec_intersect_lines.push_back(sec_line/4);
               total_intersect_pts ++;
            }
         }

         // printf("Total %d intersection points found for LINE %d.\n", total_intersect_pts, i_line/4);

         delete vec_l1;
         delete vec_l2;
      }

      // compute the mid-point
      assert(vec_intersect_pts.size() == 4);
      assert(vec_intersect_lines.size() == 8);
      int num_mp = 0;
      vector<int> vec_pts_order;     /* the order for boundary generation (only 4 points ) */
      vector<int> vec_converge;      /* the matched mid-point index for the base */
      int found_num = 0;
      for (int i_pts = 0; i_pts < vec_intersect_pts.size(); i_pts ++ ) {
         int line1 = vec_intersect_lines[i_pts*2];
         int line2 = vec_intersect_lines[i_pts*2+1];
         int x = x_axis(vec_intersect_pts[i_pts]);
         int y = y_axis(vec_intersect_pts[i_pts]);
         for (int k = i_pts + 1; k < vec_intersect_pts.size(); k ++ ) {
            int nl1 = vec_intersect_lines[k*2];
            int nl2 = vec_intersect_lines[k*2+1];
            if ( nl1 == line1 || nl1 == line2 || nl2 == line1 || nl2 == line2 ) {
               int nx = x_axis(vec_intersect_pts[k]);
               int ny = y_axis(vec_intersect_pts[k]);
               int mp_x = (int) ( (nx + x) / 2 + .5 ); 
               int mp_y = (int) ( (ny + y) / 2 + .5 );
               printf("Found %dth mid-point : %d, %d\n", num_mp, mp_x, mp_y);
               num_mp ++;
               vec_pts_order.push_back(k);
               if ( vec_pts_order.size() == 1)
                  vec_pts_order.push_back(0);

               if ( i_key == start_num ) { // log down info for base
                  vec_mp_base.push_back(mp_x);
                  vec_mp_base.push_back(mp_y);
                  vec_mp_index.push_back(i_pts);
                  vec_mp_index.push_back(k);
               } else {
                  // match the mid-point for unchanged sides
                  const int SIM_DIS = 4;
                  for ( int i = 0; i < vec_mp_base.size(); i += 2) {
                     int base_mp_x = vec_mp_base[i];
                     int base_mp_y = vec_mp_base[i+1];
                     if ( abs((float)mp_x - base_mp_x) < SIM_DIS &&
                          abs((float)mp_y - base_mp_y) < SIM_DIS ) {
                        vec_converge.push_back(i);
                        found_num ++;
                        printf("Matched with base (%d, %d)\n", base_mp_x, base_mp_y);
                        
                        ave_dis = sqrt((float)(x-nx)*(x-nx) + (y-ny)*(y-ny));
                        break;
                     }
                  }
               } // end of non-base
            } // end of if
         } // end of for

         if ( found_num == 2 )
            break;
         
      }

      assert( vec_pts_order.size() >= 4 );
      printf("Boundary of this quadrangle is:");
      for (int i = 0; i <= 4; i ++ ) {
         int x = x_axis(vec_intersect_pts[vec_pts_order[i%4]]);
         int y = y_axis(vec_intersect_pts[vec_pts_order[i%4]]);

         printf("P%d: (%d, %d), ", i, x, y);
      }
      printf("\n");

      if ( i_key == start_num ) {
         
         vec_intersect_pts_base = vec_intersect_pts; // back up base points
         vec_base_order = vec_pts_order;  // back up the order
         
      } else {

         if ( vec_converge.size() != 2 ) {
            printf("Wrong with %s, converging size is %d.\n", bpa_ir_fn, vec_converge.size());
            assert( 0 ) ;
         }

         if ( vec_base_converge.size() == 0) {
            vec_base_converge = vec_converge;
         }

         printf("Found the points for mid-point:");
         for ( int i = 0; i < vec_converge.size(); i ++ ) {
            int index_line = vec_converge[i];
            int index_1 = vec_mp_index[index_line];
            int index_2 = vec_mp_index[index_line+1];
            int x = x_axis(vec_intersect_pts_base[index_1]);
            int y = y_axis(vec_intersect_pts_base[index_1]);
            int nx = x_axis(vec_intersect_pts_base[index_2]);
            int ny = y_axis(vec_intersect_pts_base[index_2]);
            base_dist = sqrt((float)(x-nx)*(x-nx) + (y-ny)*(y-ny));
            printf(" set %d: [%d, %d]. ", i, index_1, index_2);
         }
         printf("\n");

         // the height is like this: h/H = 1 - d1/d2 <=> H-h/H = d1/d2  : h = cur_key - base_key
         int base_key = vec_keys->at(0);
         // float converging_height = (cur_key - base_key)/(1 - ave_dis/base_dist);
         float converging_height = (vec_keys->at(i_key-1) - base_key)/(1 - ave_dis/base_dist);
         printf("The converging point height is : %f\n", converging_height);
         vec_conv_height.clear();
         vec_conv_height.push_back(converging_height);
      }
      
   }

   // dump the boundary of the base image in order
   // let's make sure the point 0 and point 1 are not sharing the same converging point

   int pt_0, pt_0_mp;
   int mid_point_index = -1;
   bool delay_first_point = false;
   for (int i = 0; i <= 4; i ++ ) {
      int i_pt = vec_base_order[i%4];
      int x = x_axis(vec_intersect_pts_base[i_pt]);
      int y = y_axis(vec_intersect_pts_base[i_pt]);

      bool found = false;
      int x_mp, y_mp, k;
      for ( k = 0; k < vec_base_converge.size(); k ++ ) {
         int index_line = vec_base_converge[k];
         int index_1 = vec_mp_index[index_line];
         int index_2 = vec_mp_index[index_line+1];
         if ( index_1 == i%4 || index_2 == i%4 ) {
            found = true;
            x_mp = vec_mp_base[index_line];
            y_mp = vec_mp_base[index_line+1];
            break;
         }
      }

      assert(found);

      if ( mid_point_index == -1 ) {
         mid_point_index = k;
         pt_0 = index(x, y);
         pt_0_mp = index(x_mp, y_mp);
         continue;
      }

      if ( return_vec->size() == 0 && mid_point_index == k ) {
         delay_first_point = true;
         pt_0 = index(x, y);
         pt_0_mp = index(x_mp, y_mp);
      }
   
      if ( return_vec->size() == 0 && mid_point_index != k ) {
         return_vec->push_back(pt_0);
         return_vec->push_back(pt_0_mp);
      }
      
      return_vec->push_back(index(x, y));
      return_vec->push_back(index(x_mp, y_mp));
      

      printf("P%d: (%d, %d), P': (%d, %d)\n", i, x, y, x_mp, y_mp);
   }

   if ( delay_first_point ) {
      return_vec->push_back(pt_0);
      return_vec->push_back(pt_0_mp);
   }

   assert(return_vec->size() == 10 );

   
   // update vec_height
   // sort(vec_conv_height.begin(), vec_conv_height.end(), greater<float>());
   vec_height->push_back(2.0); // 1.0: taper - TTP 2.0: taper - TTL
   vec_height->push_back(vec_keys->at(0)); 
   vec_height->push_back(vec_keys->at(0) + vec_conv_height[0]); // converging height

   float act_h = vec_keys->at(0) + vec_conv_height[0];
   if ( vec_keys->at(0) + vec_conv_height[0] > vec_keys->at(vec_keys->size() - 1) + 2.0)
      act_h = vec_keys->at(vec_keys->size() - 1);
   
   vec_height->push_back(act_h); // actual height

   printf("TTL Taper info: base height: %.3f, converging height: %.3f, actual: %.3f\n", (*vec_height)[1], (*vec_height)[2], (*vec_height)[3]);
   
   return return_vec;
}


vector<vector<int> *> *ca_taper_compute_contour_for_segments(char *folder, char *prefix_dumping,  vector<int> &vec_keys, int total_slices, int i_seg, vector<vector<float> *> &z_arr, int trans_id = 0, int is_quadrangle = 0)
{
   vector<BYTE **> vec_ims;
   vector<char *>  vec_fns;
   vector<char *>  vec_fns_bpa;
   vector<vector<int> *> *return_vec = new vector<vector<int> *> ();

   int pre_int = 0;
   {
      // contruct image array;
      int h, w;
      for (int i = 0; i < vec_keys.size(); i ++ ) {
         BYTE **im = new_image(image_height, image_width);
         vec_ims.push_back(im);
         
         char *fn = (char *) malloc(1000);
         sprintf(fn, "%s/../bpa_keyslices/image_slice_%d_%d.png", folder, pre_int, vec_keys[i]);
         vec_fns.push_back(fn);

         fn = (char *) malloc(1000);
         sprintf(fn, "%s/../bpa_keyslices/bpa_image_slice_%d_%d.png", folder, pre_int, vec_keys[i]);
         vec_fns_bpa.push_back(fn);

         pre_int = vec_keys[i];
         
      }
      assert(vec_fns.size() == vec_ims.size());
   }


   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
      ca_load_aux_for_each_unit(tmp);
      if ( readRunTimeFlag("ca_aux_is_quadrangle", &tmp_value) ) {
         is_quadrangle = atoi(tmp_value);
      }
   }

   
   // project the data into image
   char *value;
   int h, w;
   if ( !readRunTimeFlag("do_not_dump_images_from_point_cloud", &value ) || strcmp(value, "0") == 0 ) 
   {
      float x_min, x_max, y_min, y_max, z_min, z_max;
      vector<double> data_pts;
      {
         {
            // 1. get the range of [x X], [y Y].
            // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
            // 3. dump the image in folder_name/slice_for_type
            char data_fn[1000];

            if ( trans_id == 0 ) 
               sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
            else
               sprintf(data_fn, "%s/../%s_trans_%d.txt", folder, prefix_dumping, trans_id);
            
            vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
            x_min = vec_bounding_box->at(0);
            x_max = vec_bounding_box->at(1);
            y_min = vec_bounding_box->at(2);
            y_max = vec_bounding_box->at(3);
            z_min = vec_bounding_box->at(4);
            z_max = vec_bounding_box->at(5);
            float diff_x = x_max - x_min;
            float diff_y = y_max - y_min;

            int h, w, t;
            const int LARGE = 1024;
            float scale = diff_x /diff_y;
            if ( scale > 1 )
               scale = 1 / scale;
            scale = scale * LARGE;
            t = (int) (scale + .5);
            t += ( 8 - (t % 8));
      
            if ( diff_x > diff_y ) {
               w = LARGE;
               h = t;
            } else {
               w = t;
               h = LARGE;
            }
            image_width = w;
            image_height = h;

            // let use 10% for imaging
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;

         }
      }
      
      // dump the data into image
      {
         printf("dumping data...with total slices [%d]\n", total_slices);
         int direction = 1;
         
         float diff_x = x_max - x_min;
         float diff_y = y_max - y_min;
         float diff_z = z_max - z_min;
         float BOX_MIN = (direction == 0) ? y_min : (direction == 1) ? z_min : x_min;
         float dir_diff = (direction == 0) ? diff_y : (direction == 1) ? diff_z : diff_x;
         for (int i_pts = 0; i_pts < data_pts.size(); i_pts += 3)
         {
            // CHANGE: i_pts
            int index_ = (direction == 0) ? i_pts : (direction == 1) ? i_pts+2 : i_pts+1;
            int group_index = (int) (((data_pts[index_] - BOX_MIN)/dir_diff)*total_slices);

            if ( group_index > pre_int )
               continue;

            BYTE **im = NULL;
            for ( int i = 0; i < vec_keys.size(); i ++ )
               if ( group_index <= vec_keys[i] ) {
                  im = vec_ims[i];
                  break;
               }

            assert(im);

            // CHANGE: BOX_MIN_Z
            float dir_scale_diff = (direction == 2) ? diff_z : diff_x;
            float scale = (double)image_width / dir_scale_diff;
            int z_i;
            if (direction == 0)
               z_i = image_height - (int)((data_pts[i_pts+2] - z_min) * scale + .5) - 1; // z
            else
               z_i = image_height - (int)((data_pts[i_pts]   - y_min) * scale + .5) - 1; // y

            int x_i;
            if (direction == 2)
               x_i = (int)(((data_pts[i_pts+2] - z_min)/diff_z)*image_width  + .5); // z
            else
               x_i = (int)(((data_pts[i_pts+1] - x_min)/diff_x)*image_width  + .5); // x
            if (x_i == image_width)
               x_i -= 1;

            if ( valid_pixel(x_i, z_i) ) 
               im[z_i][x_i] = BLACK;
            
         }
      }

      for (int i = 0; i < vec_keys.size(); i ++ ) {
         char *fn = vec_fns[i];
         BYTE **im = vec_ims[i];
         if ( !file_exist(fn) ) {
            printf("Saving the file %s\n", fn);
            Save2File(fn, im, NULL, image_width, image_height, 0, NULL);
         } else {
            free_image(im);
            vec_ims[i] = load_image_array(fn, h, w);
         }
      }
   } else {
      for (int i = 0; i < vec_keys.size(); i ++ ) {
         vec_ims[i] = load_image_array(vec_fns[i], h, w);
      }
   }

   // apply BPA on generated image
   {
      int h = image_height;
      int w = image_width;
      for (int i = 0; i < vec_keys.size(); i ++ )
      {
         char *fn  = vec_fns[i];
         BYTE **im = vec_ims[i];
         image_height = h;
         image_width = w;

         if ( !file_exist( vec_fns_bpa[i] ) )
         {

            // set the parameters for BPA
            {
               if ( !is_quadrangle ) 
                  gbl_opts->BPA_need_do_refinement = 1;
               else 
                  gbl_opts->BPA_need_do_refinement = 0;
               
               gbl_opts->BPA_need_do_HT_BPA_combination = 1;
               // gbl_opts->radius = radius_im;
               gbl_opts->radius = 64;
               gbl_opts->radius_min = 4;
               //gbl_opts->BPA_debug_mode = 0;
               //gbl_opts->BPA_debug_image_interval = 100;
               gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
               //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
               gbl_opts->BPA_do_not_check_turning_around = 1;
               gbl_opts->BPA_starting_point_sweeping_dir = 1;  // 2 from top, 1 from left
               //gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
               gbl_opts->BPA_simple_starting_point = 1;       // this is to assume a simple case.
               gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
               gbl_opts->BPA_dump_the_vectors = 1;
               //gbl_opts->BPA_turning_around_angle = 50;
               //gbl_opts->BPA_merge_boundary_points = 1;
               output_fn = strdup(fn); // for generating vector file

            }

            array_t *boundary_array = array_alloc(deque<int> *, 0);
            printf("Applying BPA on %s...\n", output_fn);
            BPA_boundary_image(im, boundary_array);

            char *fn_bpa = vec_fns_bpa[i];
            draw_boundary_image(boundary_array, NULL, gbl_opts->radius, fn_bpa);
            
         }

         free_image(im);
         free(vec_fns[i]);
         free(vec_fns_bpa[i]);
      }
   }

   // Load IR to image, and apply BPA on this IR image to get straight lines.
   int previous_one = 0;
   for (int i = 0; i < vec_keys.size(); i ++ )
   {
      int cur_one = vec_keys[i];
      
      vector<int> *base_ir = new vector<int>();

      if ( is_quadrangle == 1)
      {
         char bpa_ir_fn[1000], ir_fn[1000], fn[1000];
         sprintf(fn, "%s/../bpa_keyslices/bpa_image_slice_%d_%d_dumped_0.png", folder, previous_one, cur_one);
         sprintf(bpa_ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%d_%d_dumped_0.txt", folder, previous_one, cur_one);
         sprintf(ir_fn, "%s/../bpa_keyslices/image_slice_%d_%d_dumped_0.txt", folder, previous_one, cur_one);
         vector<int> all_lines;
         load_lines_from_BPA_dump(all_lines, ir_fn, image_height, image_width);
         BYTE **orig_im = get_image_from_vec_lines(all_lines, image_height, image_width);

         // BPA to get 4 lines
         int w = image_width;
         int h = image_height;
         int line_num = 0;
         int pdetect;
         int tetadetect;
         vector<int> temp;      
         vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
         BYTE **Imbinary = copy_image(orig_im, h, w);
         gbl_opts->BPA_clear_data_mask = 4;
         while (true)
         {
            my_HT(Imbinary, h, w, pdetect, tetadetect);
         
            // draw line on the image
            HT_get_two_points(pdetect, tetadetect, h, w, Imbinary, line_set);
            // printf("line_set.size() at iteration %d: %d\n", line_num, line_set.size());
         
            temp = find(*Imbinary,h*w, BLACK);
            if (temp.size() == 0) break;

            if ( ++ line_num >= 4 ) break;
         }

         // compute the 4 intersection points 
         assert(line_set.size() == 16);
         int total_intersect_pts = 0;
         vector<int> vec_intersect_pts;      /* the new intersection points */
         vector<int> vec_intersect_lines;    /* the line # intersected at the corresponding intersection point */
         for ( int i_line = 0; i_line < line_set.size() - 4; i_line += 4) {
            vector<int> *vec_l1 = new vector<int>();
            vector<int> *vec_l2 = new vector<int>();
            for (int k = 0; k < 4; k ++ )
               vec_l1->push_back(line_set[i_line+k]);

            for ( int sec_line = i_line + 4; sec_line < line_set.size(); sec_line += 4 ) {
               vec_l2->clear();
               for (int k = 0; k < 4; k ++ )
                  vec_l2->push_back(line_set[sec_line+k]);

               vector<int> *share_pt = ca_compute_intersection_point(vec_l1, vec_l2);
               if ( share_pt && valid_pixel((*share_pt)[0], (*share_pt)[1]) ) {
                  int x = (*share_pt)[0];
                  int y = (*share_pt)[1];
                  int pt = index(x, y);

                  printf("The %dth intersection point: LINE %d|%d is: %d, %d.\n", total_intersect_pts, i_line/4, sec_line/4, x, y );
                  vec_intersect_pts.push_back(pt);
                  vec_intersect_lines.push_back(i_line/4);
                  vec_intersect_lines.push_back(sec_line/4);
                  total_intersect_pts ++;
               }
            }

            // printf("Total %d intersection points found for LINE %d.\n", total_intersect_pts, i_line/4);

            delete vec_l1;
            delete vec_l2;
         }
      
         // compute the order of the intersection point
         assert(vec_intersect_pts.size() == 4);
         assert(vec_intersect_lines.size() == 8);
         vector<int> vec_pts_order;     /* the order for boundary generation (only 4 points ) */
         for (int i_pts = 0; i_pts < vec_intersect_pts.size(); i_pts ++ ) {
            int line1 = vec_intersect_lines[i_pts*2];
            int line2 = vec_intersect_lines[i_pts*2+1];
            for (int k = i_pts + 1; k < vec_intersect_pts.size(); k ++ ) {
               int nl1 = vec_intersect_lines[k*2];
               int nl2 = vec_intersect_lines[k*2+1];
               if ( nl1 == line1 || nl1 == line2 || nl2 == line1 || nl2 == line2 ) {
                  vec_pts_order.push_back(k);
                  if ( vec_pts_order.size() == 1)
                     vec_pts_order.push_back(0);

               } // end of if

               if ( vec_pts_order.size() == 4 )
                  break;
            
            } // end of for

            if ( vec_pts_order.size() == 4 )
               break;
         }

         assert( vec_pts_order.size() >= 4 );

         FILE *fd = fopen(bpa_ir_fn, "w");
         assert(fd);

         fprintf(fd, "ImageSize %dx%d\nBEGIN POLYGON\n", image_width, image_height);
         printf("Boundary of this quadrangle is:");
         for (int i = 0; i <= 4; i ++ ) {
            int x = x_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            int y = y_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            base_ir->push_back(index(x, y));
            printf("P%d: (%d, %d), ", i, x, y );
            fprintf(fd, "%d %d\n", x, y );
         }
         printf("\n");      

         fprintf(fd, "END POLYGON\n");
         fclose(fd);

         all_lines.clear();
         load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
         write_lines_to_bw_image(fn, all_lines,  image_height, image_width);
      } else {

         vector<int> all_lines;
         char bpa_ir_fn[1000], ht_bpa_fn[1000];
         sprintf(bpa_ir_fn, "%s/../bpa_keyslices/image_slice_%d_%d_dumped_0.txt", folder, previous_one, cur_one);
         sprintf(ht_bpa_fn, "%s/../bpa_keyslices/HT_BPA_image_slice_%d_%d_dumped_0.txt", folder, previous_one, cur_one);
         ca_compute_merge_HT_on_BPA_result(bpa_ir_fn, ht_bpa_fn);
      }

      previous_one = cur_one;

   }

   // fill up the points and height for the extruded keyslices
   {
      int pre_h = 0;
      for ( int i = 0; i < vec_keys.size(); i ++ ) {

         vector<float> *vec_h = new vector<float> ();
         vec_h->push_back(0); // 0: extruded 1: tapered
         vec_h->push_back(pre_h);
         vec_h->push_back(vec_keys[i]); // c: converge height; d. actual top height.
         vec_h->push_back(vec_keys[i]);
         z_arr.push_back(vec_h);

         {
            // load from IR file
            char ir_fn[1000];
            sprintf(ir_fn, "%s/../bpa_keyslices/bpa_image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);
            if ( !file_exist(ir_fn)) {
               sprintf(ir_fn, "%s/../bpa_keyslices/HT_BPA_image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);
               if ( !file_exist(ir_fn)) {
                  sprintf(ir_fn, "%s/../bpa_keyslices/image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);
                  assert( file_exist(ir_fn));
               }
            }

            vector<int> all_lines;
            vector<int> *regular_ir = new vector<int> ();
            load_lines_from_BPA_dump(all_lines, ir_fn, image_height, image_width);
            for (int j = 0; j < all_lines.size(); j += 4 ) {
               int x0 = all_lines[j];
               int y0 = all_lines[j+1];
               int x1 = all_lines[j+2];
               int y1 = all_lines[j+3];

               if ( j == 0 )
                  regular_ir->push_back(index(x0, y0));
               regular_ir->push_back(index(x1, y1));
            }
            return_vec->push_back(regular_ir);

         }

         pre_h = vec_keys[i];
         
      }
   }

   return return_vec;
}


void ca_project_keyslices_into_images(char *folder, char *prefix_dumping,  vector<int> &vec_keys, int total_slices, int i_seg, int trans_id = -1)
{
   vector<BYTE **> vec_ims;
   vector<char *>  vec_fns;
   vector<char *>  vec_fns_bpa;
   vector<vector<int> *> *return_vec = new vector<vector<int> *> ();

   char bpa_folder[1000], cmd[1000];
   {
#ifndef LINUX
      sprintf(bpa_folder, "%s_%d\\bpa_keyslices", prefix_dumping, i_seg);
#else
      sprintf(bpa_folder, "%s_%d/bpa_keyslices", prefix_dumping, i_seg);
#endif   
      if ( !file_exist( bpa_folder ) ) {
         printf("Creating folder %s...\n", bpa_folder);
         sprintf(cmd, "mkdir %s", bpa_folder);
         system(cmd);
      }
   }

   int pre_int = 0;
   {
      // contruct image array;
      int h, w;
      for (int i = 0; i < vec_keys.size(); i ++ ) {
         BYTE **im = new_image(image_height, image_width);
         vec_ims.push_back(im);
         
         char *fn = (char *) malloc(1000);
         sprintf(fn, "%s/image_slice_%d_%d.png", bpa_folder, pre_int, vec_keys[i]);
         vec_fns.push_back(fn);

         pre_int = vec_keys[i];

         if ( file_exist(fn) ) {
            free_image(im);
            free(fn);
            printf("BPA Keyslices have already been generated!\n");
            return;
         }
         
      }
      assert(vec_fns.size() == vec_ims.size());
   }

   
   // project the data into image
   char *value;
   int h, w;
   if ( !readRunTimeFlag("do_not_dump_images_from_point_cloud", &value ) || strcmp(value, "0") == 0 ) 
   {
      float x_min, x_max, y_min, y_max, z_min, z_max;
      vector<double> data_pts;
      {
         {
            // 1. get the range of [x X], [y Y].
            // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
            // 3. dump the image in folder_name/slice_for_type
            char data_fn[1000];

            if ( trans_id == -1 ) 
               sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
            else
               sprintf(data_fn, "%s/../%s_trans_%d.txt", folder, prefix_dumping, trans_id);
            
            vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
                  
               assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
            }
            float diff_x = x_max - x_min;
            float diff_y = y_max - y_min;

            // let use 10% for imaging
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;

         }
      }
      
      // dump the data into image
      {
         printf("dumping data...\n");
         int direction = 1;
         
         float diff_x = x_max - x_min;
         float diff_y = y_max - y_min;
         float diff_z = z_max - z_min;
         float BOX_MIN = (direction == 0) ? y_min : (direction == 1) ? z_min : x_min;
         float dir_diff = (direction == 0) ? diff_y : (direction == 1) ? diff_z : diff_x;
         for (int i_pts = 0; i_pts < data_pts.size(); i_pts += 3)
         {
            // CHANGE: i_pts
            int index_ = (direction == 0) ? i_pts : (direction == 1) ? i_pts+2 : i_pts+1;
            int group_index = (int) (((data_pts[index_] - BOX_MIN)/dir_diff)*total_slices);

            if ( group_index > pre_int )
               continue;

            BYTE **im = NULL;
            for ( int i = 0; i < vec_keys.size(); i ++ )
               if ( group_index <= vec_keys[i] ) {
                  im = vec_ims[i];
                  break;
               }

            assert(im);

            // CHANGE: BOX_MIN_Z
            float dir_scale_diff = (direction == 2) ? diff_z : diff_x;
            float scale = (double)image_width / dir_scale_diff;
            int z_i;
            if (direction == 0)
               z_i = image_height - (int)((data_pts[i_pts+2] - z_min) * scale + .5) - 1; // z
            else
               z_i = image_height - (int)((data_pts[i_pts]   - y_min) * scale + .5) - 1; // y

            int x_i;
            if (direction == 2)
               x_i = (int)(((data_pts[i_pts+2] - z_min)/diff_z)*image_width  + .5); // z
            else
               x_i = (int)(((data_pts[i_pts+1] - x_min)/diff_x)*image_width  + .5); // x
            if (x_i == image_width)
               x_i -= 1;

            if ( valid_pixel(x_i, z_i) ) 
               im[z_i][x_i] = BLACK;
            
         }
      }

      for (int i = 0; i < vec_keys.size(); i ++ ) {
         char *fn = vec_fns[i];
         BYTE **im = vec_ims[i];
         if ( !file_exist(fn) ) {
            printf("Saving the file %s\n", fn);
            Save2File(fn, im, NULL, image_width, image_height, 0, NULL);
         } 

         free_image(im);
         free(fn);
      }
   }

}

void ca_dump_IR_keyslices(char *fn, vector<vector<float> *> &z_arr)
{
   FILE *fd = fopen(fn, "w");
   if ( !fd ) {
      printf("ERROR: could not open file %s for writing!\n", fn);
      exit(0);
   }

   for (int i = 0; i < z_arr.size(); i ++ ) {
      vector<float> *vec_h = z_arr[i];
      fprintf(fd, "%f %f %f %f\n", vec_h->at(0), vec_h->at(1), vec_h->at(2), vec_h->at(3));
   }
   
   fclose(fd);
   
}

vector<vector<int> *> *ca_load_IR_keyslices(char *fn, vector<int> &vec_keys, vector<vector<float> *> &z_arr)
{

   vector<vector<int> *> *return_vec = new vector<vector<int> *> ();

   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("ERROR: could not open file %s for reading in ca_load_IR_keyslices()!\n", fn);
      exit(0);
   }

   char str[1000];
   while (fgets(str, 1000, fd) ) {
      vector<float> *vec_h = new vector<float> ();
      float a, b, c, d;
      assert(sscanf(str, "%f %f %f %f", &a, &b, &c, &d) == 4);
      vec_h->push_back(a);
      vec_h->push_back(b);
      vec_h->push_back(c);
      vec_h->push_back(d);
      z_arr.push_back(vec_h);
   }
   
   fclose(fd);

   // fill up the points and height for the extruded keyslices
   {
      int pre_h = 0;
      for ( int i = 0; i < vec_keys.size(); i ++ ) {

         // push the first one ( base polygon )
         {
            // load from IR file
            char ir_fn[1000];

            char *folder = dirname(fn);

            sprintf(ir_fn, "%s/bpa_keyslices/bpa_image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);
            if ( !file_exist(ir_fn)) {
               sprintf(ir_fn, "%s/bpa_keyslices/HT_BPA_image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);
               if ( !file_exist(ir_fn)) {
                  sprintf(ir_fn, "%s/bpa_keyslices/image_slice_%d_%d_dumped_0.txt", folder, pre_h, vec_keys[i]);

                  // 10.5.2010 - this is for paper writing of generating extrusion model
                  if ( !file_exist(ir_fn) ) {
                     char *ds = digit_string(4, vec_keys[i]);
                     sprintf(ir_fn, "%s/bpa_keyslices/bpa_image_slice_%s_dumped_0.txt", folder, ds);
                     free(ds);
                     if ( !file_exist(ir_fn)) {
                        printf("ERROR: file %s is not exist!\n", ir_fn);
                        assert(0);
                     }
                  }
               }
            }

            vector<int> all_lines;
            vector<int> *regular_ir = new vector<int> ();
            load_lines_from_BPA_dump(all_lines, ir_fn, image_height, image_width);
            int pre_pt = -1;
            for (int j = 0; j < all_lines.size(); j += 4 ) {
               int x0 = all_lines[j];
               int y0 = all_lines[j+1];
               int x1 = all_lines[j+2];
               int y1 = all_lines[j+3];

               if ( j == 0 )
                  regular_ir->push_back(index(x0, y0));

               if ( j != 0 && pre_pt != index(x0, y0) ) // a new segment starting here.
               {
                  regular_ir->push_back(-1);
                  regular_ir->push_back(index(x0, y0));
               }
                  
               
               regular_ir->push_back(index(x1, y1));

               
               pre_pt = index(x1, y1);
            }
            return_vec->push_back(regular_ir);

         }

         pre_h = vec_keys[i];
         
      }
   }

   return return_vec;
   
}

void ca_apply_BPA_on_keyslices(char *folder, char *prefix_dumping,  vector<int> &vec_keys, int total_slices, int i_seg, int trans_id = 0)
{
   vector<BYTE **> vec_ims;
   vector<char *>  vec_fns;
   vector<char *>  vec_fns_bpa;
   vector<vector<int> *> *return_vec = new vector<vector<int> *> ();

   char bpa_folder[1000], cmd[1000];
   {
#ifndef LINUX
      sprintf(bpa_folder, "%s_%d\\bpa_keyslices", prefix_dumping, i_seg);
#else
      sprintf(bpa_folder, "%s_%d/bpa_keyslices", prefix_dumping, i_seg);
#endif   
      if ( !file_exist( bpa_folder ) ) {
         printf("Creating folder %s...\n", bpa_folder);
         sprintf(cmd, "mkdir %s", bpa_folder);
         system(cmd);
      }
   }

   int pre_int = 0;
   {
      // contruct image array;
      int h, w;
      for (int i = 0; i < vec_keys.size(); i ++ ) {
         char *fn = (char *) malloc(1000);
         sprintf(fn, "%s/image_slice_%d_%d.png", bpa_folder, pre_int, vec_keys[i]);
         vec_fns.push_back(fn);

         BYTE **im = load_image_array(fn, h, w);
         vec_ims.push_back(im);
         
         fn = (char *) malloc(1000);
         sprintf(fn, "%s/bpa_image_slice_%d_%d.png", bpa_folder, pre_int, vec_keys[i]);
         vec_fns_bpa.push_back(fn);

         pre_int = vec_keys[i];

         if ( file_exist(fn) ) {
            free_image(im);
            free(fn);
            printf("BPA has been applied on keyslices!\n");
            return;
         }
         
      }
      assert(vec_fns.size() == vec_ims.size());
   }

   
   int is_quadrangle = 0;
   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
      ca_load_aux_for_each_unit(tmp);
      if ( readRunTimeFlag("ca_aux_is_quadrangle", &tmp_value) ) {
         is_quadrangle = atoi(tmp_value);
      }
   }

   // apply BPA on generated image
   {
      int h = image_height;
      int w = image_width;
      for (int i = 0; i < vec_keys.size(); i ++ )
      {
         char *fn  = vec_fns[i];
         BYTE **im = vec_ims[i];
         image_height = h;
         image_width = w;
         
         {

            // set the parameters for BPA
            {
               if ( !is_quadrangle ) 
                  gbl_opts->BPA_need_do_refinement = 1;
               else 
                  gbl_opts->BPA_need_do_refinement = 0;
               
               gbl_opts->BPA_need_do_HT_BPA_combination = 1;
               // gbl_opts->radius = radius_im;
               gbl_opts->radius = 64;
               gbl_opts->radius_min = 4;
               //gbl_opts->BPA_debug_mode = 0;
               //gbl_opts->BPA_debug_image_interval = 100;
               gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
               //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
               gbl_opts->BPA_do_not_check_turning_around = 1;
               gbl_opts->BPA_starting_point_sweeping_dir = 1;  // 2 from top, 1 from left
               //gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
               gbl_opts->BPA_simple_starting_point = 1;       // this is to assume a simple case.
               gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
               gbl_opts->BPA_dump_the_vectors = 1;
               //gbl_opts->BPA_turning_around_angle = 50;
               //gbl_opts->BPA_merge_boundary_points = 1;
               output_fn = strdup(fn); // for generating vector file

            }

            // check config file
            char config_fn[1000];
            sprintf(config_fn, "%s_%d/param.ini", prefix_dumping, i_seg);
            if ( file_exist(config_fn) ) {
               printf("INFO: load configuration file %s\n", config_fn);
               load_parameter(config_fn);
            }
            
            array_t *boundary_array = array_alloc(deque<int> *, 0);
            printf("Applying BPA on %s...\n", output_fn);
            BPA_boundary_image(im, boundary_array);

            char *fn_bpa = vec_fns_bpa[i];
            draw_boundary_image(boundary_array, NULL, gbl_opts->radius, fn_bpa);
            
         }

         free_image(im);
         free(vec_fns[i]);
         free(vec_fns_bpa[i]);
      }
   }

   // Load IR to image, and apply BPA on this IR image to get straight lines.
   int previous_one = 0;
   for (int i = 0; i < vec_keys.size(); i ++ )
   {
      int cur_one = vec_keys[i];
      
      if ( is_quadrangle == 1)
      {
         char bpa_ir_fn[1000], ir_fn[1000], fn[1000];
         sprintf(fn, "%s/bpa_image_slice_%d_%d_dumped_0.png", bpa_folder, previous_one, cur_one);
         sprintf(bpa_ir_fn, "%s/bpa_image_slice_%d_%d_dumped_0.txt", bpa_folder, previous_one, cur_one);
         sprintf(ir_fn, "%s/image_slice_%d_%d_dumped_0.txt", bpa_folder, previous_one, cur_one);
         vector<int> all_lines;
         load_lines_from_BPA_dump(all_lines, ir_fn, image_height, image_width);
         BYTE **orig_im = get_image_from_vec_lines(all_lines, image_height, image_width);

         // BPA to get 4 lines
         int w = image_width;
         int h = image_height;
         int line_num = 0;
         int pdetect;
         int tetadetect;
         vector<int> temp;      
         vector<int> line_set; // line segment vector: x1, y1, x2, y2  ASSERT(line_set.size() % 4 == 0);
         BYTE **Imbinary = copy_image(orig_im, h, w);
         gbl_opts->BPA_clear_data_mask = 4;
         while (true)
         {
            my_HT(Imbinary, h, w, pdetect, tetadetect);
         
            // draw line on the image
            HT_get_two_points(pdetect, tetadetect, h, w, Imbinary, line_set);
            // printf("line_set.size() at iteration %d: %d\n", line_num, line_set.size());
         
            temp = find(*Imbinary,h*w, BLACK);
            if (temp.size() == 0) break;

            if ( ++ line_num >= 4 ) break;
         }

         // compute the 4 intersection points 
         assert(line_set.size() == 16);
         int total_intersect_pts = 0;
         vector<int> vec_intersect_pts;      /* the new intersection points */
         vector<int> vec_intersect_lines;    /* the line # intersected at the corresponding intersection point */
         for ( int i_line = 0; i_line < line_set.size() - 4; i_line += 4) {
            vector<int> *vec_l1 = new vector<int>();
            vector<int> *vec_l2 = new vector<int>();
            for (int k = 0; k < 4; k ++ )
               vec_l1->push_back(line_set[i_line+k]);

            for ( int sec_line = i_line + 4; sec_line < line_set.size(); sec_line += 4 ) {
               vec_l2->clear();
               for (int k = 0; k < 4; k ++ )
                  vec_l2->push_back(line_set[sec_line+k]);

               vector<int> *share_pt = ca_compute_intersection_point(vec_l1, vec_l2);
               /* 10.19.2010 debug information.
               if ( share_pt ) {
                  printf("DEBUG: LINE %d|%d is: %d, %d.\n", i_line/4, sec_line/4, (*share_pt)[0], (*share_pt)[1] );
                  printf("DEBUG: [%d,%d] - [%d,%d].\n", (*vec_l1)[0],(*vec_l1)[1],(*vec_l1)[2],(*vec_l1)[3]);
                  printf("DEBUG: [%d,%d] - [%d,%d].\n", (*vec_l2)[0],(*vec_l2)[1],(*vec_l2)[2],(*vec_l2)[3]);
               }
               */
               
               if ( share_pt && valid_pixel((*share_pt)[0], (*share_pt)[1]) ) {
                  int x = (*share_pt)[0];
                  int y = (*share_pt)[1];
                  int pt = index(x, y);

                  printf("The %dth intersection point: LINE %d|%d is: %d, %d.\n", total_intersect_pts, i_line/4, sec_line/4, x, y );
                  vec_intersect_pts.push_back(pt);
                  vec_intersect_lines.push_back(i_line/4);
                  vec_intersect_lines.push_back(sec_line/4);
                  total_intersect_pts ++;
               }
            }

            // printf("Total %d intersection points found for LINE %d.\n", total_intersect_pts, i_line/4);

            delete vec_l1;
            delete vec_l2;
         }
      
         // compute the order of the intersection point
         assert(vec_intersect_pts.size() == 4);
         assert(vec_intersect_lines.size() == 8);
         vector<int> vec_pts_order;     /* the order for boundary generation (only 4 points ) */
         for (int i_pts = 0; i_pts < vec_intersect_pts.size(); i_pts ++ ) {
            int line1 = vec_intersect_lines[i_pts*2];
            int line2 = vec_intersect_lines[i_pts*2+1];
            for (int k = i_pts + 1; k < vec_intersect_pts.size(); k ++ ) {
               int nl1 = vec_intersect_lines[k*2];
               int nl2 = vec_intersect_lines[k*2+1];
               if ( nl1 == line1 || nl1 == line2 || nl2 == line1 || nl2 == line2 ) {
                  vec_pts_order.push_back(k);
                  if ( vec_pts_order.size() == 1)
                     vec_pts_order.push_back(0);

               } // end of if

               if ( vec_pts_order.size() == 4 )
                  break;
            
            } // end of for

            if ( vec_pts_order.size() == 4 )
               break;
         }

         assert( vec_pts_order.size() >= 4 );

         FILE *fd = fopen(bpa_ir_fn, "w");
         assert(fd);

         fprintf(fd, "ImageSize %dx%d\nBEGIN POLYGON\n", image_width, image_height);
         printf("Boundary of this quadrangle is:");
         for (int i = 0; i <= 4; i ++ ) {
            int x = x_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            int y = y_axis(vec_intersect_pts[vec_pts_order[i%4]]);
            printf("P%d: (%d, %d), ", i, x, y );
            fprintf(fd, "%d %d\n", x, y );
         }
         printf("\n");      

         fprintf(fd, "END POLYGON\n");
         fclose(fd);

         all_lines.clear();
         load_lines_from_BPA_dump(all_lines, bpa_ir_fn, image_height, image_width);
         write_lines_to_bw_image(fn, all_lines,  image_height, image_width);
      } else {

         vector<int> all_lines;
         char bpa_ir_fn[1000], ht_bpa_fn[1000];
         sprintf(bpa_ir_fn, "%s/image_slice_%d_%d_dumped_0.txt", bpa_folder, previous_one, cur_one);
         sprintf(ht_bpa_fn, "%s/HT_BPA_image_slice_%d_%d_dumped_0.txt", bpa_folder, previous_one, cur_one);
         ca_compute_merge_HT_on_BPA_result(bpa_ir_fn, ht_bpa_fn);
      
      }

      previous_one = cur_one;

   }

   // fill up the points and height for the extruded keyslices
   {
      int pre_h = 0;
      vector<vector<float> *> z_arr;
      for ( int i = 0; i < vec_keys.size(); i ++ ) {

         vector<float> *vec_h = new vector<float> ();
         vec_h->push_back(0); // 0: extruded 1: tapered
         vec_h->push_back(pre_h);
         vec_h->push_back(vec_keys[i]); // c: converge height; d. actual top height.
         vec_h->push_back(vec_keys[i]);
         z_arr.push_back(vec_h);
         pre_h = vec_keys[i];

      }
      char IR_z[1000];
      sprintf(IR_z, "%s/../IR_z_info.txt", folder);
      ca_dump_IR_keyslices(IR_z, z_arr);
   }
   
}

/*
 FUNCTION: ca_taper_refine_simple_structures

 This is to infer taper-to-point or taper-to-line structures.
 We need to know this in that the converging method described in ksd_taper_compute_converge()
 can only handle the case where all points converge to the same point.
 If points are converging to 2 points (no 3, 4, ... pts ), we have to do differently.

 To distinguish to taper-to-line or to-point, we can do the similar thing as described in
 ksd_taper_compute_type(). That is, dilation and matching with landing.
 
*/

vector<vector<int> *> * ca_taper_refine_simple_structures(char *old_folder, vector<int> *vec_keys, vector<vector<float> *> &z_arr, int slices, int seg_idx)
{
   vector<vector<int> *> *return_vec = NULL;

#ifdef LINUX
   char *folder = str_replace(old_folder, "\\", "/", 0, -1);
   printf("before [%s], after replace [%s].\n", old_folder, folder);
#else
   char *folder = old_folder;
#endif   
   
   // we want to locate taper structure location, and replace multiple key slices with the taper structure.
   // Also, we have to find a way to represent this taper structure:
   // for taper-to-point (TTP) and taper-to-line (TTL), the uniform representation would be:
   // TAPER: base, top, height
   // 
   // TWO ASSUMPTIONS:
   // For TTL, we assume that the underline geometry MUST be a SiBianXing - Quadrangle
   // For Taper, we assume it is the end part of the segment (we may not need this).
   
   vector<int> *vec_taper = ca_taper_infer_location(vec_keys);
   int type = ca_taper_infer_ttl_or_ttp(folder, vec_taper); // 0: TTP, 1: TTL

   vector<float> *vec_height = new vector<float> ();
   vector<int> *vec_tt_contour;
   if ( type == 1 ) // must be a quadrangle
   {
      // compute the 4 control points.

      vec_tt_contour = ca_taper_compute_ttl(folder, vec_taper, vec_height);
      
   } else {

      // compute the base and converging point.
      // if the converging point is not part of the structure, compute it by centroid.
      // the centroid should be the same for all keyslices, the height can be computed
      // by average distance from control pts to centroid for each keyslice and base keyslice.
      // the height is the ratio from each keyslice to base keyslice.

      vec_tt_contour = ca_taper_compute_ttp(folder, vec_taper, vec_height);
   }


   // the return 2D array data structure:
   // 1. each vector<int> * contains the closed form IR contour
   //    1.5. if the type is tapered structure, <p1|p1'>, p1' is the tapered point of p1 in vector<int> *.
   // 2. each vector<float> * contains a. type (0: TTP, 1: TTL); b. base height; c. converge height; d. actual top height.

   // apply BPA to get IR on 2D image
   // assume the taper structure is the end of the list
   vector<int> vec_extrude_layers;
   for (int i = 0; i < vec_keys->size(); i ++ ) {
      if ( vec_keys->at(i) <= vec_taper->at(0) )
         vec_extrude_layers.push_back(vec_keys->at(i));
      else
         break;
   }

   // regenerate the image based on the segmented data

   // push extruded contour
   char *prefix_dumping = NULL;
   if ( !readRunTimeFlag("result_segment_roof_prefix", &prefix_dumping) ) {
      prefix_dumping = "point_cloud_region";
   }
   return_vec = ca_taper_compute_contour_for_segments(folder, prefix_dumping, vec_extrude_layers, slices, seg_idx, z_arr);

   // push tapered contour
   return_vec->push_back(vec_tt_contour);
   z_arr.push_back(vec_height);


   return return_vec;
}

/* Function: ca_compute_projected_point

   compute the projected point from a point to a line
*/

float * ca_compute_projected_point(POINT_3D p[])
{
   float *return_p = (float *)malloc(3*sizeof(float));
   // compute the vertical line using dot_product
   float x0 = p[0].x;
   float y0 = p[0].y;
   float x1 = p[1].x;
   float y1 = p[1].y;
   float x2 = p[2].x;
   float y2 = p[2].y;
   float x3 = p[3].x;
   float y3 = p[3].y;

   if ( x1 == x0 ) {
      return_p[0] = x2;
      return_p[1] = y3;
      return return_p;
   }

   if ( y1 == y0 ) {
      return_p[0] = x3;
      return_p[1] = y2;
      return return_p;
   }

   float a1 = (y1 - y0)/(x1 - x0);
   float a2 = 1/a1;

   float b1 = y2 - a1 * x2;
   float b2 = y3 - a2 * x3;
   
   return_p[0] = (b1 - b2)/(a2 - a1);
   return_p[1] = a1 * return_p[0] + b1;
   return_p[2] = 0.0;

   return return_p;
}

void ca_infer_keyslices_computation(int mode)
{
   char *value;
   char *result_fn, *result_fn_flag;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      result_fn             = "result_seg_body_regtypes_2.txt";
      result_fn_flag        = "result_segment_body_reg_types_2";
      prefix_dumping        = "point_cloud_body_region";
   }
   else if ( mode == 1 ) {
      result_fn             = "result_seg_roof_regtypes_2.txt";
      result_fn_flag        = "result_segment_roof_reg_types_2";
      prefix_dumping        = "point_cloud_roof_region";
   }
   else {
      result_fn             = "result_seg_ledger_regtypes_2.txt";
      result_fn_flag        = "result_segment_ledger_reg_types_2";
      prefix_dumping        = "point_cloud_ledger_region";
   }

   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   // now let's transform the data back to 3D coordinates
   // for bottom-up model, transform them into 3D coordinates directly.
   // for extrusion from other sides, transform them into 3D coordindates first, then, apply matrix transform.

   {

      char *reg_type_fn;
      if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
         reg_type_fn = result_fn;

      vector<vector<int> * > vec_segments;
      ca_load_variable_length_info(reg_type_fn, vec_segments, true);
         
      for (int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
      {
         int type_slice = 200; 
         
         vector<int> *vec_faces = vec_segments[i_seg];

         char folder_name[1000], cmd[1000], sub_folder[1000];
         char *key_str, all_key_fn[1000];
         if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
            key_str = "key_slices.txt";
         sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);

         // ignore if key_slices.txt exists!
         if ( file_exist(all_key_fn) )
            continue;
            
         
         
         float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
         
         // if this is a taper unit, we should generate IR for this unit now.
         if ( vec_faces->at(0)  == 1 ) {
            printf("Segment %d is Taper.\n", i_seg);
            
#ifdef LINUX
            sprintf(sub_folder, "%s_%d/slice_for_taper", prefix_dumping, i_seg);
#else
            sprintf(sub_folder, "%s_%d\\slice_for_taper", prefix_dumping, i_seg);
#endif
            
            vector<double> data_pts;

            {
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_taper
            
               char data_fn[1000];
               sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
               sprintf(folder_name, "%s/image_slice_0000.png", sub_folder);

               // keep this, since the data will be projected into images.
               if (  !file_exist(folder_name) ) {
                  vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
               }

               {
                  char tmp[1000], *tmp_value;
                  sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
                  ca_load_aux_for_each_unit(tmp);
                  assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

                  assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               }
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;

               printf("IMAGE SIZE: w - %d, h - %d\n", image_width, image_height);

               // dump the data into image


               // let use 10% for imaging
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
               
            }
            
            if ( !file_exist(folder_name) ) {
               
               sprintf(cmd, "mkdir %s", sub_folder);
               system(cmd);
               
               printf("Creating sub-folder %s\n", sub_folder);

               // project the data to be analyzed
               project_point_cloud_into_image(data_pts, sub_folder,
                                              1, type_slice,
                                              x_min, x_max, y_min, y_max, z_min, z_max);

               // update value
               {
                  int *params = (int *) malloc (sizeof(int) * 1 );
                  params[0] = type_slice;
                  char dir_name[1000];
                  sprintf(dir_name, "%s_%d",  prefix_dumping, i_seg);
                  ca_update_aux_for_each_unit(dir_name, "ca_aux_total_slices", (void *)params, 1);
                  free(params);
               }
               
            }
               

            // compute the taper structure which may contain extrusions also.
            // if no special taper structure found (taper-to-line or taper-to-point), use extrusion.

            vector<int> *vec_keys;
            vec_keys = ca_compute_keyslices(type_slice, sub_folder);
            ca_dump_simple_vector(all_key_fn, vec_keys);
            delete vec_keys;

            
         } // end of  vec_faces->at(0)  == 1
         else { // if this is a extruded unit, we should generate IR for this unit now.

            printf("Segment %d is Extrusion.\n", i_seg);

            vector<double> data_pts;
            char data_fn[1000];
            sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);

            int face_id = -1;
            sprintf(sub_folder, "%s_%d/slice_for_type", prefix_dumping, i_seg);
            
            // for this case, need to update point cloud dataset and image size,
            // if ( vec_faces->size() > 1 && vec_faces->at(1) != 0 ) {
            if ( vec_faces->size() > 1 ) {
               face_id = vec_faces->at(1);
               sprintf(sub_folder, "%s_%d/slice_for_face%d", prefix_dumping, i_seg, face_id+1);

               // need to update point cloud dataset and image size;
               sprintf(data_fn, "%s_%d/%s_trans_%d.txt", prefix_dumping, i_seg, prefix_dumping, face_id);

               vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
               x_min = vec_bounding_box->at(0);
               x_max = vec_bounding_box->at(1);
               y_min = vec_bounding_box->at(2);
               y_max = vec_bounding_box->at(3);
               z_min = vec_bounding_box->at(4);
               z_max = vec_bounding_box->at(5);
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;

               int h, w, t;
               const int LARGE = 1024;
               float scale = diff_x /diff_y;
               if ( scale > 1 )
                  scale = 1 / scale;
               scale = scale * LARGE;
               t = (int) (scale + .5);
               t += ( 8 - (t % 8));
      
               if ( diff_x > diff_y ) {
                  w = LARGE;
                  h = t;
               } else {
                  w = t;
                  h = LARGE;
               }
               printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
               image_width = w;
               image_height = h;

               char folder_name[1000];
               sprintf(folder_name, "%s_%d", prefix_dumping, i_seg);
               // update value
               {
                  float *params = (float *) malloc (sizeof(float) * 6 );
                  params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
                  ca_update_aux_for_each_unit(folder_name, "ca_aux_bounding_box", (void *)params, 6);
                  free(params);
               }

               {
                  int *params = (int *) malloc (sizeof(int) * 2 );
                  params[0] = w; params[1] = h;
                  ca_update_aux_for_each_unit(folder_name, "ca_aux_image_size", (void *)params, 2);
                  free(params);
               }
               
               
            }

            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);

               assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value));
               assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

               assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);

               if (readRunTimeFlag("ca_aux_total_slices", &tmp_value)) {
                  type_slice = atoi(tmp_value);
               }
            }

            // here, let's dump the data into slice_for_extrusion with computed counter.
            // log down the image size in advance.

            // let's compute the # of slices
            // TODO: extrusion for body
            if ( 1 )
            {
               // automatically infer the total # of slices
               // float int_3D_per_slice = (Z - z)/total_slices;

               char tmp_fn[1000];
               char *ds = digit_string(4, type_slice - 1);
               sprintf(tmp_fn, "%s/image_slice_%s.png", sub_folder, ds);
               if ( ! file_exist(tmp_fn) ) {

                  if ( data_pts.size() == 0 ) 
                     load_point_cloud_for_bounding_box(data_fn, data_pts);
                  diff_x = x_max - x_min;
                  diff_y = y_max - y_min;

                  // let use 10% for imaging
                  x_min -= diff_x * .1;
                  x_max += diff_x * .1;
                  y_min -= diff_y * .1;
                  y_max += diff_y * .1;

                  // project the data to be analyzed
                  project_point_cloud_into_image(data_pts, sub_folder,
                                                 1, type_slice,
                                                 x_min, x_max, y_min, y_max, z_min, z_max);
                  
                  
               }
            }
            
            vector<int> *vec_keys;
            vec_keys = ca_compute_keyslices(type_slice, sub_folder);
            ca_dump_simple_vector(all_key_fn, vec_keys);
            delete vec_keys;
            
         }
      } // end of for i_seg
   }
}

void ca_infer_body_keyslices_computation()
{
   printf("\n\nMODULE: ca_infer_body_keyslices_computation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_keyslices_computation(0);
}

void ca_infer_roof_keyslices_computation()
{
   printf("\n\nMODULE: ca_infer_roof_keyslices_computation() \n\n");

   ca_infer_keyslices_computation(1);
}

void ca_infer_ledger_keyslices_computation()
{
   printf("\n\nMODULE: ca_infer_ledger_keyslices_computation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_keyslices_computation(2);
}

void ca_infer_bpa_image_generation(int mode)
{
   char *value;
   char *result_fn, *result_fn_flag;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      result_fn             = "result_seg_body_regtypes_2.txt";
      result_fn_flag        = "result_segment_body_reg_types_2";
      prefix_dumping        = "point_cloud_body_region";
   }
   else if ( mode == 1 ) {
      result_fn             = "result_seg_roof_regtypes_2.txt";
      result_fn_flag        = "result_segment_roof_reg_types_2";
      prefix_dumping        = "point_cloud_roof_region";
   }
   else {
      result_fn             = "result_seg_ledger_regtypes_2.txt";
      result_fn_flag        = "result_segment_ledger_reg_types_2";
      prefix_dumping        = "point_cloud_ledger_region";
   }

   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   // now let's transform the data back to 3D coordinates
   // for bottom-up model, transform them into 3D coordinates directly.
   // for extrusion from other sides, transform them into 3D coordindates first, then, apply matrix transform.

   {

      char *reg_type_fn;
      if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
         reg_type_fn = result_fn;

      vector<vector<int> * > vec_segments;
      ca_load_variable_length_info(reg_type_fn, vec_segments, true);
         
      for (int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
      {
         int type_slice = 100; 
         
         vector<int> *vec_faces = vec_segments[i_seg];

         char folder_name[1000], cmd[1000], sub_folder[1000];
         
         // we only consider extrusion unit here.
         if ( vec_faces->at(0)  == 0 ) {

            printf("Segment %d is Extrusion.\n", i_seg);

            // here, let's dump the data into slice_for_extrusion with computed counter.
            // log down the image size in advance.

            int face_id = -1;
            sprintf(sub_folder, "%s_%d/slice_for_type", prefix_dumping, i_seg);

            // if ( vec_faces->size() > 1 && vec_faces->at(1) != 0 ) {
            if ( vec_faces->size() > 1  ) {
               face_id = vec_faces->at(1);
               sprintf(sub_folder, "%s_%d/slice_for_face%d", prefix_dumping, i_seg, face_id+1);
            }

            float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
            vector<double> data_pts;

            {
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_taper
            
               char data_fn[1000];
               if ( face_id == -1 ) 
                  sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
               else
                  sprintf(data_fn, "%s/../%s_trans_%d.txt", sub_folder, prefix_dumping, face_id);

               {
                  char tmp[1000], *tmp_value;
                  sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
                  ca_load_aux_for_each_unit(tmp);
                  assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
                  sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max);

                  assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
                  
                  if (readRunTimeFlag("ca_aux_total_slices", &tmp_value)) {
                     type_slice = atoi(tmp_value);
                  }
               }

            }
            
            int slices = type_slice;
            vector<vector<float> *> z_arr;
            char *key_str, all_key_fn[1000];
            if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
               key_str = "key_slices.txt";
            sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);
            vector<int> vec_extrude_layers(*ca_load_simple_vector(all_key_fn));
            
            // push extruded contour
            ca_project_keyslices_into_images(sub_folder, prefix_dumping, vec_extrude_layers, slices, i_seg, face_id);

         }
      } // end of for i_seg
   }
}

void ca_infer_body_bpa_image_generation()
{
   printf("\n\nMODULE: ca_infer_body_bpa_image_generation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_bpa_image_generation(0);   
}

void ca_infer_roof_bpa_image_generation()
{
   printf("\n\nMODULE: ca_infer_roof_bpa_image_generation() \n\n");

   ca_infer_bpa_image_generation(1);   
}

void ca_infer_ledger_bpa_image_generation()
{
   printf("\n\nMODULE: ca_infer_ledger_bpa_image_generation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_bpa_image_generation(2);   
}

void ca_infer_bpa_IR_computation(int mode)
{
   char *value;
   char *result_fn, *result_fn_flag;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      result_fn             = "result_seg_body_regtypes_2.txt";
      result_fn_flag        = "result_segment_body_reg_types_2";
      prefix_dumping        = "point_cloud_body_region";
   }
   else if ( mode == 1 ) {
      result_fn             = "result_seg_roof_regtypes_2.txt";
      result_fn_flag        = "result_segment_roof_reg_types_2";
      prefix_dumping        = "point_cloud_roof_region";
   }
   else {
      result_fn             = "result_seg_ledger_regtypes_2.txt";
      result_fn_flag        = "result_segment_ledger_reg_types_2";
      prefix_dumping        = "point_cloud_ledger_region";
   }

   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   // now let's transform the data back to 3D coordinates
   // for bottom-up model, transform them into 3D coordinates directly.
   // for extrusion from other sides, transform them into 3D coordindates first, then, apply matrix transform.

   {

      char *reg_type_fn;
      if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
         reg_type_fn = result_fn;

      vector<vector<int> * > vec_segments;
      ca_load_variable_length_info(reg_type_fn, vec_segments, true);
         
      for (int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
      {
         int type_slice = 100; 
         
         vector<int> *vec_faces = vec_segments[i_seg];

         char folder_name[1000], cmd[1000], sub_folder[1000];
         
         // we only consider extrusion unit here.
         if ( vec_faces->at(0)  == 0 ) {

            printf("Segment %d is Extrusion.\n", i_seg);

            // here, let's dump the data into slice_for_extrusion with computed counter.
            // log down the image size in advance.

            int face_id = -1;
            sprintf(sub_folder, "%s_%d/slice_for_type", prefix_dumping, i_seg);

            // if ( vec_faces->size() > 1 && vec_faces->at(1) != 0 ) {
            if ( vec_faces->size() > 1  ) {
               face_id = vec_faces->at(1);
               sprintf(sub_folder, "%s_%d/slice_for_face%d", prefix_dumping, i_seg, face_id+1);
            }

            sprintf(folder_name, "%s/image_slice_0000.png", sub_folder);

            float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
            vector<double> data_pts;

            {
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_taper
            
               char data_fn[1000];
               if ( face_id == -1 ) 
                  sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
               else
                  sprintf(data_fn, "%s/../%s_trans_%d.txt", sub_folder, prefix_dumping, face_id);

            }

            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
               sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max);

               assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               
               if (readRunTimeFlag("ca_aux_total_slices", &tmp_value)) {
                  type_slice = atoi(tmp_value);
               }
            }

            
            int slices = type_slice;
            vector<vector<float> *> z_arr;
            char *key_str, all_key_fn[1000];
            if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
               key_str = "key_slices.txt";
            sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);
            vector<int> vec_extrude_layers(*ca_load_simple_vector(all_key_fn));
            
            // push extruded contour
            ca_apply_BPA_on_keyslices(sub_folder, prefix_dumping, vec_extrude_layers, slices, i_seg, face_id);

         }
      } // end of for i_seg
   }
}

void ca_infer_body_bpa_IR_computation()
{
   printf("\n\nMODULE: ca_infer_body_bpa_IR_computation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_bpa_IR_computation(0);
}

void ca_infer_roof_bpa_IR_computation()
{
   printf("\n\nMODULE: ca_infer_roof_bpa_IR_computation() \n\n");

   ca_infer_bpa_IR_computation(1);
}

void ca_infer_ledger_bpa_IR_computation()
{
   printf("\n\nMODULE: ca_infer_ledger_bpa_IR_computation() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_infer_bpa_IR_computation(2);
}

vector<vector<int> *> *ca_load_window_info( char *value )
{
   FILE *fd = fopen(value, "r");
   assert (fd );

   vector<vector<int> *> *return_vec = new vector<vector<int> *> ();
   
   char win_info_str[1000];
   int pre_id = -1, id, start, end;
   vector<int> *new_face;
   while (fgets(win_info_str, 1000, fd ) ) {
      if ( sscanf(win_info_str, "%d %d %d", &id, &start, &end) == 3 ) {
         if ( id != pre_id ) {
            pre_id = id;
            new_face = new vector<int> ();
            return_vec->push_back(new_face);
         }
         new_face->push_back(start);
         new_face->push_back(end);
         
      }
   }

   fclose(fd);

   return return_vec;
}

BYTE **ca_integrate_images(char *prefix, int start, int end)
{
   BYTE **im = NULL;
   for (int i = start; i <= end; i ++ )
   {
      char *ds = digit_string(4, i);

      char fn[1000];
      int h, w;
      sprintf(fn, "%s_%s.png", prefix, ds);
      BYTE **new_im = load_image_array(fn, h, w);

      free(ds);
      
      if ( !im ) {
         im = new_im;
         continue;
      } else {
         for (int j = 0; j < h * w; j ++ )
            im[0][j] |= new_im[0][j];

         free_image(new_im);
      }
      
   }

   return im;
}

void ca_compute_body_window_structure ()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   printf("\n\nMODULE: ca_compute_body_window_structure() \n\n");
   
   // dump images for windows detection ???
   // let's use the slices from faceX directory.
   // The drawback is some windows may be very small there.
   // ca_generate_images_from_segments_for_windows(0);  // 0: body, 1: roof
      
   // load information of windows on body
   if ( !readRunTimeFlag("result_body_window_info", &value) )
      value = "result_body_window_info.txt";

   vector<vector<int> *> *vec_body_win_info = ca_load_window_info( value );
   
   // get the roof line
   char *output_fn = NULL;
   if ( !readRunTimeFlag("result_segment_body_roof", &output_fn) )
      output_fn = "result_seg_body_roof.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_ledger_str[1000];
   int index_ledger;
   while (fgets(index_ledger_str, 1000, output_fd ) ) {
      assert(sscanf(index_ledger_str, "%d", &index_ledger ) == 1);
      break;
   }
   fclose(output_fd);
   
   // index_ledger = 652; // for synthetic CU data
   printf("The ledger index_ledger is %d\n", index_ledger);

   // compute the height
   ca_load_aux_top_level("bottom_up");
   assert(readRunTimeFlag("box_bottom_up", &value));

   float x, X, y, Y, z, Z;
   assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

   int total_slices = 1000;
   if (readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);
   
   float cur_z = z + (Z - z)*((float)index_ledger/total_slices); // 3D coord of Z.
   printf("BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);

   char file_name[1000], file_name_debug[1000];
   int total_faces = 5;
   for ( int count = 1; count < total_faces; count ++ )
   {
      vector<int> *win_info = vec_body_win_info->at(count - 1);
      int win_wall_index = 0;
      while ( win_wall_index < win_info->size())
      {
         int start = win_info->at(win_wall_index);
         int end   = win_info->at(win_wall_index+1);
         win_wall_index += 2;

         char *ds_s = digit_string(4, start);
         char *ds_e = digit_string(4, end);
         sprintf(file_name, "face%d/image_slice_%s_%s_o1.png", count, ds_s, ds_e);
         sprintf(file_name_debug, "face%d/image_slice_debug.png", count);
         char fn_trans[1000];
         sprintf(fn_trans, "face%d/trans.txt", count);

         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_P = ca_compute_multi_vec_matrix(0.0, 0.0, cur_z, M);
         float new_y = new_P[1];

         // LOAD 2nd BOX
         sprintf(fn_trans, "face%d", count);
         ca_load_aux_top_level(fn_trans);
         
         sprintf(fn_trans, "box_face%d", count);
         assert(readRunTimeFlag(fn_trans, &value));

         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
         printf("FACE BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);
   
         int h, w;
         char input_fn[1000];
         char prefix[1000];
         BYTE **cur_im;
         
         sprintf(input_fn, "face%d/image_slice_%s_%s.png", count, ds_s, ds_e);
         sprintf(prefix, "face%d/slices/image_slice", count);
         if ( file_exist( input_fn ) ) {
            cur_im = load_image_array(input_fn, h, w);
         } else {
            cur_im = ca_integrate_images(prefix, start, end-1);
            h = image_height;
            w = image_width;
            Save2File(input_fn, cur_im, NULL, w, h, 0, NULL);
         }
         
         float diff_x = X - x;
         float scale = (float)image_width / diff_x;
         int im_y = image_height - (int)((new_y - y) * scale + .5) - 1;

         /* 
            printf("Ledger here: %d\n", im_y);
            for (int y = 0; y < im_y; y ++ ) 
            for (int x = 0; x < w; x ++ ) {
            cur_im[y][x] = WHITE;
            }
            //  debug: Save2File(file_name, cur_im, NULL, w, h, 0, NULL);         
            */
      

         // looking for big trunk data as windows/doors
         const int mask = 8;
         BYTE **new_im = new_image(h, w);

         int backup_image_h = image_height;
         int backup_image_w = image_width;
         array_t *arr_all_boundaries = array_alloc(deque<int> *, 0);
         int total_elements = 0;

         vector<int> trunk_data;
         for (int y = im_y; y < h; y ++ ) {
            for (int x = 0; x < w; x ++ ) {
               if ( cur_im[y][x] == BLACK && new_im[y][x] == WHITE ) {
                  bool found = true;
                  for (int i = y; i < y + mask; i ++ ) {
                     bool is_good = true;
                     for (int j = x; j < x + mask; j ++ )
                        if ( valid_pixel(j, i) && cur_im[i][j] == WHITE ){
                           is_good = false;
                           break;
                        }
                     if ( !is_good ) {
                        found = false;
                        break;
                     }
                  }

                  // do CC/watersheding if found (connect component)
                  trunk_data.clear();
                  int min_x_data = x, max_x_data = x;
                  int min_y_data = y, max_y_data = y;
                  if ( found ) {
                     vector<int> init_pts;
                     init_pts.push_back(index(x, y));
                     while (true ) {

                        vector<int> new_pts(init_pts);
                        init_pts.clear();
                        for (int i = 0; i < new_pts.size(); i ++ )
                        {

                           int x = x_axis(new_pts[i]);
                           int y = y_axis(new_pts[i]);
         
                           if (x<1 || x>w-2 || y<1 || y>h-2 )
                           {
                              continue;
                           }
                           if ( new_im[y][x] == BLACK )
                              continue;
                 

                           new_im[y][x] = BLACK;
                        
                           trunk_data.push_back(index(x, y));
                           if ( y > max_y_data ) max_y_data = y;
                           if ( y < min_y_data ) min_y_data = y;
                           if ( x > max_x_data ) max_x_data = x;
                           if ( x < min_x_data ) min_x_data = x;

                        
                           if ( cur_im[y][x+1] != new_im[y][x+1] )
                              init_pts.push_back(index(x+1, y)) ;
                           if ( cur_im[y][x-1] != new_im[y][x-1] )
                              init_pts.push_back(index(x-1, y));
                           if ( cur_im[y-1][x] != new_im[y-1][x] )
                              init_pts.push_back(index(x, y-1));
                           if ( cur_im[y-1][x+1] != new_im[y-1][x+1] )
                              init_pts.push_back(index(x+1, y-1));
                           if ( cur_im[y-1][x-1] != new_im[y-1][x-1] )
                              init_pts.push_back(index(x-1, y-1));
                           if ( cur_im[y+1][x] != new_im[y+1][x] )
                              init_pts.push_back(index(x, y+1));
                           if ( cur_im[y+1][x+1] != new_im[y+1][x+1] )
                              init_pts.push_back(index(x+1, y+1));
                           if ( cur_im[y+1][x-1] != new_im[y+1][x-1] )
                              init_pts.push_back(index(x-1, y+1));

                        }

                        if (init_pts.size() == 0 )
                           break;
                     
                     } // end of watersheding


                     // do BPA on this CC and save the boundary
                     assert( min_x_data < max_x_data);
                     assert( min_y_data < max_y_data);

                     int im_h = max_y_data - min_y_data + 1;
                     int im_w = max_x_data - min_x_data + 1;
                     BYTE **bpa_im = new_image(im_h, im_w);

                     // update image with vector trunk_data;
                     for (int k = 0; k < trunk_data.size(); k ++ ) {
                        int x_k = x_axis(trunk_data[k]);
                        int y_k = y_axis(trunk_data[k]);
                        bpa_im[y_k - min_y_data][x_k - min_x_data] = BLACK;
                     }
                  
                     // set the parameters for BPA
                     {
                        //gbl_opts->BPA_parameter_file = NULL;
                        gbl_opts->BPA_need_do_refinement = 0;
                        gbl_opts->BPA_need_do_HT_BPA_combination = 0;
                        gbl_opts->radius = 4;
                        gbl_opts->radius_min = 4;
                        //gbl_opts->BPA_debug_mode = 0;
                        //gbl_opts->BPA_debug_image_interval = 100;
                        gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
                        //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
                        gbl_opts->BPA_do_not_check_turning_around = 1;
                        gbl_opts->BPA_starting_point_sweeping_dir = 2;  // 2 from top, 1 from left
                        gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
                        gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
                        //gbl_opts->BPA_dump_the_vectors = 1;
                        gbl_opts->BPA_turning_around_angle = 50;
                        gbl_opts->BPA_merge_boundary_points = 1;
                     }

                     total_elements ++;
                     printf("BPA on element %d on image %s\n", total_elements, file_name_debug );
                  
                     array_t *boundary_array = array_alloc(deque<int> *, 0);

                     // update the image size
                     image_width = im_w;
                     image_height = im_h;
                     //Save2File(file_name_debug, bpa_im, NULL, im_w, im_h, 0, NULL);
                  
                     BPA_boundary_image(bpa_im, boundary_array);
                     assert( array_n(boundary_array) == 1);
                  
                     deque<int> *bnd_pts = array_fetch(deque<int> *, boundary_array, 0);
                     deque<int> *bnd_new_pts = new deque<int> ();
                     int offset = 2 * gbl_opts->radius + 4;
                     int x_back = min_x_data - offset;
                     int y_back = min_y_data - offset;
                     assert( x_back > 0 && y_back > 0 );
                  
                     for (int k = 0; k < bnd_pts->size(); k ++ ) {

                        int x_k = x_axis(bnd_pts->at(k));
                        int y_k = y_axis(bnd_pts->at(k));
                        y_k += y_back;
                        x_k += x_back;
                        bnd_new_pts->push_back(y_k * backup_image_w + x_k);
                     }
                     array_insert_last(deque<int> *, arr_all_boundaries, bnd_new_pts);
                  
                     // draw_boundary_image(boundary_array, NULL, gbl_opts->radius, key_slice_vector_fn);

                     free_image(bpa_im);

                     // restore the image size for each image.
                     image_height = backup_image_h;
                     image_width  = backup_image_w;
                  
                  } // end of if found a big trunk
               } // end of if a black point
            } // end of for x
         } // end of for y

         image_height = backup_image_h;
         image_width  = backup_image_w;

         //Save2File(file_name, new_im, NULL, w, h, 0, NULL);

         // dump the boundaries into IR file
         char ir_fn[1000];
         sprintf(ir_fn, "face%d/image_slice_%s_%s.txt", count, ds_s, ds_e);
         FILE *fp = fopen(ir_fn, "w");
         assert(fp);
         
         // draw boundaries
         int k;
         deque<int> *pts;
         vector<int> line_set;
         arrayForEachItem(deque<int> *, arr_all_boundaries, k, pts) {
            fprintf(fp, "BEGIN POLYGON\n");
            
            int num_pts = pts->size();
            for (int j = 0; j < num_pts ; j ++)
            {
               line_set.push_back(x_axis(pts->at(j)));
               line_set.push_back(y_axis(pts->at(j)));
               line_set.push_back(x_axis(pts->at((j+1)%num_pts)));
               line_set.push_back(y_axis(pts->at((j+1)%num_pts)));
               
               fprintf(fp, "%d %d\n", x_axis(pts->at(j)), y_axis(pts->at(j)));
            }

            fprintf(fp, "END POLYGON\n");
         }
         write_lines_to_bw_image(file_name, line_set, image_height, image_width);
         fclose(fp);
         
         free(ds_s);
         free(ds_e);

      } // end of while
   } // end of each face
}

void ca_compute_roof_window_structure ()
{
   char *value;
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   printf("\n\nMODULE: ca_compute_roof_window_structure() \n\n");

   // dump images for windows detection ???
   // let's use the slices from faceX directory.
   // The drawback is some windows may be very small there.
   // ca_generate_images_from_segments_for_windows(0);  // 0: body, 1: roof
      
   // load information of windows on roof
   if ( !readRunTimeFlag("result_roof_window_info", &value) )
      value = "result_roof_window_info.txt";

   vector<vector<int> *> *vec_body_win_info = ca_load_window_info( value );
   
   // get the roof line
   char *output_fn = NULL;
   if ( !readRunTimeFlag("result_segment_body_roof", &output_fn) )
      output_fn = "result_seg_body_roof.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_ledger_str[1000];
   int index_ledger;
   while (fgets(index_ledger_str, 1000, output_fd ) ) {
      assert(sscanf(index_ledger_str, "%d", &index_ledger ) == 1);
      break;
   }
   fclose(output_fd);
   
   // index_ledger = 652; // for synthetic CU data
   printf("The ledger index_ledger is %d\n", index_ledger);

   // compute the height
   ca_load_aux_top_level("bottom_up");
   assert(readRunTimeFlag("box_bottom_up", &value));

   float x, X, y, Y, z, Z;
   assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

   int total_slices = 1000;
   if (readRunTimeFlag("total_slices", &value) )
      total_slices = atoi(value);
   
   float cur_z = z + (Z - z)*((float)index_ledger/total_slices); // 3D coord of Z.
   printf("BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);

   char file_name[1000], file_name_debug[1000];
   int total_faces = 5;
   for ( int count = 1; count < total_faces; count ++ )
   {
      vector<int> *win_info = vec_body_win_info->at(count - 1);
      int win_wall_index = 0;
      while ( win_wall_index < win_info->size())
      {
         int start = win_info->at(win_wall_index);
         int end   = win_info->at(win_wall_index+1);
         win_wall_index += 2;

         char *ds_s1 = digit_string(4, start);
         char *ds_e = digit_string(4, end);
         char ds_s[1000];
         sprintf(ds_s, "roof_%s", ds_s1);
         sprintf(file_name, "face%d/image_slice_%s_%s_o1.png", count, ds_s, ds_e);
         sprintf(file_name_debug, "face%d/image_slice_debug.png", count);
         char fn_trans[1000];
         sprintf(fn_trans, "face%d/trans.txt", count);

         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_P = ca_compute_multi_vec_matrix(0.0, 0.0, cur_z, M);
         float new_y = new_P[1];

         // LOAD 2nd BOX
         sprintf(fn_trans, "face%d", count);
         ca_load_aux_top_level(fn_trans);
         
         sprintf(fn_trans, "box_face%d", count);
         assert(readRunTimeFlag(fn_trans, &value));

         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
         printf("FACE BOX: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, cur_z: %f\n", x, X, y, Y, z, Z, cur_z);
   
         int h, w;
         char input_fn[1000];
         char prefix[1000];
         BYTE **cur_im;
         
         sprintf(input_fn, "face%d/image_slice_%s_%s.png", count, ds_s, ds_e);
         sprintf(prefix, "face%d/slices/image_slice", count);
         if ( file_exist( input_fn ) ) {
            cur_im = load_image_array(input_fn, h, w);
         } else {
            cur_im = ca_integrate_images(prefix, start, end-1);
            h = image_height;
            w = image_width;
            Save2File(input_fn, cur_im, NULL, w, h, 0, NULL);
         }

         float diff_x = X - x;
         float scale = (float)image_width / diff_x;
         int im_y = image_height - (int)((new_y - y) * scale + .5) - 1;

         /* 
            printf("Ledger here: %d\n", im_y);
            for (int y = 0; y < im_y; y ++ ) 
            for (int x = 0; x < w; x ++ ) {
            cur_im[y][x] = WHITE;
            }
            //  debug: Save2File(file_name, cur_im, NULL, w, h, 0, NULL);         
            */
      

         // looking for big trunk data as windows/doors
         const int mask = 8;
         BYTE **new_im = new_image(h, w);

         int backup_image_h = image_height;
         int backup_image_w = image_width;
         array_t *arr_all_boundaries = array_alloc(deque<int> *, 0);
         int total_elements = 0;

         vector<int> trunk_data;
         for (int y = 0; y < im_y; y ++ ) {  // from top to ledger
            for (int x = 0; x < w; x ++ ) {
               if ( cur_im[y][x] == BLACK && new_im[y][x] == WHITE ) {
                  bool found = true;
                  for (int i = y; i < y + mask; i ++ ) {
                     bool is_good = true;
                     for (int j = x; j < x + mask; j ++ )
                        if ( valid_pixel(j, i) && cur_im[i][j] == WHITE ){
                           is_good = false;
                           break;
                        }
                     if ( !is_good ) {
                        found = false;
                        break;
                     }
                  }

                  // do CC/watersheding if found (connect component)
                  trunk_data.clear();
                  int min_x_data = x, max_x_data = x;
                  int min_y_data = y, max_y_data = y;
                  if ( found ) {
                     vector<int> init_pts;
                     init_pts.push_back(index(x, y));
                     while (true ) {

                        vector<int> new_pts(init_pts);
                        init_pts.clear();
                        for (int i = 0; i < new_pts.size(); i ++ )
                        {

                           int x = x_axis(new_pts[i]);
                           int y = y_axis(new_pts[i]);
         
                           if (x<1 || x>w-2 || y<1 || y>h-2 )
                           {
                              continue;
                           }
                           if ( new_im[y][x] == BLACK )
                              continue;
                 

                           new_im[y][x] = BLACK;
                        
                           trunk_data.push_back(index(x, y));
                           if ( y > max_y_data ) max_y_data = y;
                           if ( y < min_y_data ) min_y_data = y;
                           if ( x > max_x_data ) max_x_data = x;
                           if ( x < min_x_data ) min_x_data = x;

                        
                           if ( cur_im[y][x+1] != new_im[y][x+1] )
                              init_pts.push_back(index(x+1, y)) ;
                           if ( cur_im[y][x-1] != new_im[y][x-1] )
                              init_pts.push_back(index(x-1, y));
                           if ( cur_im[y-1][x] != new_im[y-1][x] )
                              init_pts.push_back(index(x, y-1));
                           if ( cur_im[y-1][x+1] != new_im[y-1][x+1] )
                              init_pts.push_back(index(x+1, y-1));
                           if ( cur_im[y-1][x-1] != new_im[y-1][x-1] )
                              init_pts.push_back(index(x-1, y-1));
                           if ( cur_im[y+1][x] != new_im[y+1][x] )
                              init_pts.push_back(index(x, y+1));
                           if ( cur_im[y+1][x+1] != new_im[y+1][x+1] )
                              init_pts.push_back(index(x+1, y+1));
                           if ( cur_im[y+1][x-1] != new_im[y+1][x-1] )
                              init_pts.push_back(index(x-1, y+1));

                        }

                        if (init_pts.size() == 0 )
                           break;
                     
                     } // end of watersheding


                     // do BPA on this CC and save the boundary
                     assert( min_x_data < max_x_data);
                     assert( min_y_data < max_y_data);

                     int im_h = max_y_data - min_y_data + 1;
                     int im_w = max_x_data - min_x_data + 1;
                     BYTE **bpa_im = new_image(im_h, im_w);

                     // update image with vector trunk_data;
                     for (int k = 0; k < trunk_data.size(); k ++ ) {
                        int x_k = x_axis(trunk_data[k]);
                        int y_k = y_axis(trunk_data[k]);
                        bpa_im[y_k - min_y_data][x_k - min_x_data] = BLACK;
                     }
                  
                     // set the parameters for BPA
                     {
                        //gbl_opts->BPA_parameter_file = NULL;
                        gbl_opts->BPA_need_do_refinement = 0;
                        gbl_opts->BPA_need_do_HT_BPA_combination = 0;
                        gbl_opts->radius = 4;
                        gbl_opts->radius_min = 4;
                        //gbl_opts->BPA_debug_mode = 0;
                        //gbl_opts->BPA_debug_image_interval = 100;
                        gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
                        //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
                        gbl_opts->BPA_do_not_check_turning_around = 1;
                        gbl_opts->BPA_starting_point_sweeping_dir = 2;  // 2 from top, 1 from left
                        gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
                        gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
                        //gbl_opts->BPA_dump_the_vectors = 1;
                        gbl_opts->BPA_turning_around_angle = 50;
                        gbl_opts->BPA_merge_boundary_points = 1;
                     }

                     total_elements ++;
                     printf("BPA on element %d on image %s\n", total_elements, file_name_debug );
                  
                     array_t *boundary_array = array_alloc(deque<int> *, 0);

                     // update the image size
                     image_width = im_w;
                     image_height = im_h;
                     //Save2File(file_name_debug, bpa_im, NULL, im_w, im_h, 0, NULL);
                  
                     BPA_boundary_image(bpa_im, boundary_array);
                     assert( array_n(boundary_array) == 1);
                  
                     deque<int> *bnd_pts = array_fetch(deque<int> *, boundary_array, 0);
                     deque<int> *bnd_new_pts = new deque<int> ();
                     int offset = 2 * gbl_opts->radius + 4;
                     int x_back = min_x_data - offset;
                     int y_back = min_y_data - offset;
                     assert( x_back > 0 && y_back > 0 );
                  
                     for (int k = 0; k < bnd_pts->size(); k ++ ) {

                        int x_k = x_axis(bnd_pts->at(k));
                        int y_k = y_axis(bnd_pts->at(k));
                        y_k += y_back;
                        x_k += x_back;
                        bnd_new_pts->push_back(y_k * backup_image_w + x_k);
                     }
                     array_insert_last(deque<int> *, arr_all_boundaries, bnd_new_pts);
                  
                     // draw_boundary_image(boundary_array, NULL, gbl_opts->radius, key_slice_vector_fn);

                     free_image(bpa_im);

                     // restore the image size for each image.
                     image_height = backup_image_h;
                     image_width  = backup_image_w;
                  
                  } // end of if found a big trunk
               } // end of if a black point
            } // end of for x
         } // end of for y

         image_height = backup_image_h;
         image_width  = backup_image_w;

         //Save2File(file_name, new_im, NULL, w, h, 0, NULL);

         // dump the boundaries into IR file
         char ir_fn[1000];
         sprintf(ir_fn, "face%d/image_slice_%s_%s.txt", count, ds_s, ds_e);
         FILE *fp = fopen(ir_fn, "w");
         assert(fp);
         
         // draw boundaries
         int k;
         deque<int> *pts;
         vector<int> line_set;
         arrayForEachItem(deque<int> *, arr_all_boundaries, k, pts) {
            fprintf(fp, "BEGIN POLYGON\n");
            
            int num_pts = pts->size();
            for (int j = 0; j < num_pts ; j ++)
            {
               line_set.push_back(x_axis(pts->at(j)));
               line_set.push_back(y_axis(pts->at(j)));
               line_set.push_back(x_axis(pts->at((j+1)%num_pts)));
               line_set.push_back(y_axis(pts->at((j+1)%num_pts)));
               
               fprintf(fp, "%d %d\n", x_axis(pts->at(j)), y_axis(pts->at(j)));
            }

            fprintf(fp, "END POLYGON\n");
         }
         write_lines_to_bw_image(file_name, line_set, image_height, image_width);
         fclose(fp);
         
         free(ds_s1);
         free(ds_e);

      } // end of while
   } // end of each face
   
}

void ca_compute_window_load_info (char *fn, vector<vector<int> *> &vec_info)
{
   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("Could not open %s\n", fn);
      assert(0);
   }

   char str_info[1000];
   int a, b, c, d;
   while (fgets(str_info, 1000, fd) ) {
      assert(sscanf(str_info, "%d %d %d %d", &a, &b, &c, &d) == 4);
      vector<int> *vec_new = new vector<int> ();
      vec_new->push_back(a);
      vec_new->push_back(b);
      vec_new->push_back(c);
      vec_new->push_back(d);
      vec_info.push_back(vec_new);
   }

}

void ca_compute_windows_infer_wins(char *fn, char *out_fn, char *file_name = NULL, float w_thresh = -1.0)
{
   printf("\n Compute the windows now .... \n\n");

   {
      float area_thresh = w_thresh == -1.0 ? 1.0/16.0 : w_thresh;
      {
         int w, h;
         BYTE **cur_im = load_image_array(fn, h, w);

         // looking for big trunk data as windows/doors
         const int mask = 16;
         BYTE **new_im = new_image(h, w);
         BYTE **rad_im = new_image(h, w);

         int backup_image_h = image_height;
         int backup_image_w = image_width;
         array_t *arr_all_boundaries = array_alloc(deque<int> *, 0);
         int total_elements = 0;

         vector<int> trunk_data;
         for (int y = 0; y < h; y ++ ) {
            for (int x = 0; x < w; x ++ ) {
               if ( cur_im[y][x] == BLACK && new_im[y][x] == WHITE ) {
                  bool found = true;
                  for (int i = y; i < y + mask; i ++ ) {
                     bool is_good = true;
                     for (int j = x; j < x + mask; j ++ )
                        if ( valid_pixel(j, i) && cur_im[i][j] == WHITE ){
                           is_good = false;
                           break;
                        }
                     if ( !is_good ) {
                        found = false;
                        break;
                     }
                  }

                  bool is_random = true;
                  if (!found && is_random) {
                     if ( rad_im[y][x] == WHITE ) {
                        int data_pts = 0;
                        for ( int i = y; i < y + mask; i ++ )
                           for (int j = x; j < x + mask; j ++ ) {
                              if ( valid_pixel(j, i) )
                                 rad_im[i][j] = BLACK;
                              
                              if ( valid_pixel(j, i) && cur_im[i][j] == BLACK )
                                 data_pts ++;
                           }

                        if ( data_pts/(float)(mask * mask) > 0.1 )
                           found = true;
                     }
                  }
                  
                  // do CC/watersheding if found (connect component)
                  trunk_data.clear();
                  int min_x_data = x, max_x_data = x;
                  int min_y_data = y, max_y_data = y;
                  if ( found ) {
                     vector<int> init_pts;
                     init_pts.push_back(index(x, y));
                     while (true ) {

                        vector<int> new_pts(init_pts);
                        init_pts.clear();
                        for (int i = 0; i < new_pts.size(); i ++ )
                        {

                           int x = x_axis(new_pts[i]);
                           int y = y_axis(new_pts[i]);
         
                           if (x<1 || x>w-2 || y<1 || y>h-2 )
                           {
                              continue;
                           }
                           if ( new_im[y][x] == BLACK )
                              continue;
                 

                           new_im[y][x] = BLACK;
                        
                           trunk_data.push_back(index(x, y));
                           if ( y > max_y_data ) max_y_data = y;
                           if ( y < min_y_data ) min_y_data = y;
                           if ( x > max_x_data ) max_x_data = x;
                           if ( x < min_x_data ) min_x_data = x;


                           /*
                           if ( cur_im[y][x+1] != new_im[y][x+1] )
                              init_pts.push_back(index(x+1, y)) ;
                           if ( cur_im[y][x-1] != new_im[y][x-1] )
                              init_pts.push_back(index(x-1, y));
                           if ( cur_im[y-1][x] != new_im[y-1][x] )
                              init_pts.push_back(index(x, y-1));
                           if ( cur_im[y-1][x+1] != new_im[y-1][x+1] )
                              init_pts.push_back(index(x+1, y-1));
                           if ( cur_im[y-1][x-1] != new_im[y-1][x-1] )
                              init_pts.push_back(index(x-1, y-1));
                           if ( cur_im[y+1][x] != new_im[y+1][x] )
                              init_pts.push_back(index(x, y+1));
                           if ( cur_im[y+1][x+1] != new_im[y+1][x+1] )
                              init_pts.push_back(index(x+1, y+1));
                           if ( cur_im[y+1][x-1] != new_im[y+1][x-1] )
                              init_pts.push_back(index(x-1, y+1));
                           */

                           // range is used to control the separation of windows.
                           // 4 means the minimum distance between two windows should be 4 pixels away.
                           int range = 4;
                           int i_range = 1;
                           while ( i_range <= range ) {
                              
                              for ( int i = y - i_range; i <= y + i_range; i += 2 * i_range )
                                 for ( int j = x - i_range; j <= x + i_range; j ++ )
                                    if ( valid_pixel(j, i) && cur_im[i][j] != new_im[i][j] )
                                       init_pts.push_back(index(j, i));
                              
                              for ( int i = y - i_range; i <= y + i_range; i ++ )
                                 for ( int j = x - i_range; j <= x + i_range; j += 2 * i_range ) 
                                    if ( valid_pixel(j, i) && cur_im[i][j] != new_im[i][j] )
                                       init_pts.push_back(index(j, i));
                              
                              i_range ++;
                           }

                        }

                        if (init_pts.size() == 0 )
                           break;
                     
                     } // end of watersheding


                     // do BPA on this CC and save the boundary
                     // if the size is too big, we may find a framework, instead of a window
                     float area_win = (max_y_data - min_y_data) * (max_x_data - min_x_data);
                     float area_img = backup_image_h * backup_image_w;
                     
                     if ( max_x_data > min_x_data + 4 && max_y_data > min_y_data + 4 &&
                          area_win/area_img < area_thresh ) {

                        int im_h = max_y_data - min_y_data + 1;
                        int im_w = max_x_data - min_x_data + 1;
                        BYTE **bpa_im = new_image(im_h, im_w);

                        // update image with vector trunk_data;
                        for (int k = 0; k < trunk_data.size(); k ++ ) {
                           int x_k = x_axis(trunk_data[k]);
                           int y_k = y_axis(trunk_data[k]);
                           bpa_im[y_k - min_y_data][x_k - min_x_data] = BLACK;
                        }
                  
                        // set the parameters for BPA
                        {
                           //gbl_opts->BPA_parameter_file = NULL;
                           gbl_opts->BPA_need_do_refinement = 0;
                           gbl_opts->BPA_need_do_HT_BPA_combination = 0;
                           gbl_opts->radius = 4;
                           gbl_opts->radius_min = 4;
                           //gbl_opts->BPA_debug_mode = 0;
                           //gbl_opts->BPA_debug_image_interval = 100;
                           gbl_opts->BPA_clear_first_circle_data = 1; // otherwise, seg_fault when copy_image, size is changed.
                           //gbl_opts->BPA_do_not_remove_extra_turning_around_pts = 1; // new option to keep the whole points.
                           gbl_opts->BPA_do_not_check_turning_around = 1;
                           gbl_opts->BPA_simple_starting_point = 1;       // this is to assume a simple case.
                           gbl_opts->BPA_starting_point_sweeping_dir = 2;  // 2 from top, 1 from left
                           gbl_opts->BPA_starting_point_sweeping_cut_off = image_width + (8+gbl_opts->radius*4); //2 * offset (2*rad + 4)
                           gbl_opts->BPA_check_turning_point_for_first_iteration = 0; // check turning around
                           //gbl_opts->BPA_dump_the_vectors = 1;
                           gbl_opts->BPA_turning_around_angle = 50;
                           gbl_opts->BPA_merge_boundary_points = 1;
                        }

                        total_elements++;
                        printf("BPA on element %d on image\n", total_elements);
                  
                        array_t *boundary_array = array_alloc(deque<int> *, 0);

                        // update the image size
                        image_width = im_w;
                        image_height = im_h;
                        Save2File("debug_remove.png", bpa_im, NULL, im_w, im_h, 0, NULL);
                  
                        BPA_boundary_image(bpa_im, boundary_array);
                        assert( array_n(boundary_array) == 1);
                  
                        deque<int> *bnd_pts = array_fetch(deque<int> *, boundary_array, 0);
                        deque<int> *bnd_new_pts = new deque<int> ();
                        int offset = 2 * gbl_opts->radius + 4;
                        int x_back = min_x_data - offset;
                        int y_back = min_y_data - offset;
                        assert( x_back > 0 && y_back > 0 );
                  
                        for (int k = 0; k < bnd_pts->size(); k ++ ) {

                           int x_k = x_axis(bnd_pts->at(k));
                           int y_k = y_axis(bnd_pts->at(k));
                           y_k += y_back;
                           x_k += x_back;
                           bnd_new_pts->push_back(y_k * backup_image_w + x_k);
                        }
                        array_insert_last(deque<int> *, arr_all_boundaries, bnd_new_pts);
                  
                        // draw_boundary_image(boundary_array, NULL, gbl_opts->radius, key_slice_vector_fn);

                        free_image(bpa_im);

                        // restore the image size for each image.
                        image_height = backup_image_h;
                        image_width  = backup_image_w;

                     } // end if not a framework
                  } // end of if found a big trunk
               } // end of if a black point
            } // end of for x
         } // end of for y

         image_height = backup_image_h;
         image_width  = backup_image_w;

         //Save2File(file_name, new_im, NULL, w, h, 0, NULL);

         // dump the boundaries into IR file
         FILE *fp = fopen(out_fn, "w");
         assert(fp);
         
         // draw boundaries
         int k;
         deque<int> *pts;
         vector<int> line_set;
         fprintf(fp, "ImageSize %dx%d\n", image_width, image_height);
         arrayForEachItem(deque<int> *, arr_all_boundaries, k, pts) {
            fprintf(fp, "BEGIN POLYGON\n");
            
            int num_pts = pts->size();
            for (int j = 0; j < num_pts ; j ++)
            {
               line_set.push_back(x_axis(pts->at(j)));
               line_set.push_back(y_axis(pts->at(j)));
               line_set.push_back(x_axis(pts->at((j+1)%num_pts)));
               line_set.push_back(y_axis(pts->at((j+1)%num_pts)));
               
               fprintf(fp, "%d %d\n", x_axis(pts->at(j)), y_axis(pts->at(j)));
            }

            fprintf(fp, "END POLYGON\n");
         }

         if ( file_name )
            write_lines_to_bw_image(file_name, line_set, image_height, image_width);

         fclose(fp);

         free_image(cur_im);
         free_image(new_im);
         free_image(rad_im);
         
      } // end of while
   } // end of each face
}


void ca_compute_window_structure (int mode)
{
   char *fn;
   char *value;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      fn = "result_seg_body_region_faces.txt";
      prefix_dumping = "point_cloud_body_region";
   }
   else {
      fn = "result_seg_roof_region_faces.txt";
      prefix_dumping = "point_cloud_roof_region";
   }

   if ( !file_exist(fn) )
      return;
   
   vector<vector<int> * > vec_segments;
   ca_load_variable_length_info(fn, vec_segments);


   const int type_slice = 100;
   float win_area_thresh = -1.0;
      
   // do slicing for remaining directions.
   for ( int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
   {
      {
         //int face_id = vec_segments[i_seg]->at(j);

         char folder_name[1000], data_fn[1000];
         sprintf(folder_name, "%s_%d", prefix_dumping, i_seg);
         sprintf(data_fn, "%s/window_slices.txt", folder_name);

         // load window information
         if ( file_exist(data_fn) )
         {
            char win_folder[1000];
#ifdef LINUX
            sprintf(win_folder, "%s_%d/bpa_windows", prefix_dumping, i_seg);
#else
            sprintf(win_folder, "%s_%d\\bpa_windows", prefix_dumping, i_seg);
#endif
            if ( !file_exist(win_folder) ) {
               char cmd[1000];
               sprintf(cmd, "mkdir %s", win_folder);
               system(cmd);
            }

            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               
               if (readRunTimeFlag("ca_aux_win_area_thresh", &tmp_value)) {
                  win_area_thresh = atof(tmp_value);
               }
               
            }
            
            vector<vector<int> *> vec_win_info;
            ca_compute_window_load_info(data_fn, vec_win_info);

            for (int i_face = 0; i_face < vec_win_info.size(); i_face ++ ) {
               int face_id = vec_win_info[i_face]->at(0);
               int  dir_id = vec_win_info[i_face]->at(1);
               int start_id = vec_win_info[i_face]->at(2);
               int  end_id = vec_win_info[i_face]->at(3);

               char win_face_fn[1000];
               sprintf(win_face_fn, "%s/window_face%d_%d_%d.png", win_folder, face_id, start_id, end_id);

               if ( !file_exist(win_face_fn) ) {

                  // do integration
                  BYTE **ref_im = NULL;
                  for (int i = start_id; i <= end_id; i ++ ) {
                     char *ds = digit_string(4, i);

                     char im_fn[1000];
                     sprintf(im_fn, "%s/window_%s_slice_for_face%d/image_slice_%s.png",
                             folder_name,
                             dir_id == 1 ? "max" : "min",
                             face_id, ds);
                     BYTE **im = load_image_array(im_fn, image_height, image_width);

                     free(ds);
                     if ( !ref_im ) {
                        ref_im = im;
                        continue;
                     } else {
                        for ( int k = 0; k < image_height * image_width; k ++ )
                           ref_im[0][k] |= im[0][k];
                        free_image(im);
                     }
                  }

                  Save2File(win_face_fn, ref_im, NULL, image_width, image_height, 0, NULL);
                  if ( ref_im ) {
                     free_image(ref_im);
                  }
               }

               // load the integrated image, and do the windows computation
               char win_face_fn_out[1000], debug_fn[1000];
               sprintf(win_face_fn_out, "%s/window_face%d_%d_%d.txt", win_folder, face_id, start_id, end_id);
               sprintf(debug_fn, "%s/window_face%d_%d_%d_o1.png", win_folder, face_id, start_id, end_id);

               if ( !file_exist(win_face_fn_out) )
                  ca_compute_windows_infer_wins(win_face_fn, win_face_fn_out, debug_fn, win_area_thresh);
            }
         }
      }
   }
}


/* FUNCTION: ca_compute_body_mask_for_windows

   Compute the mask images for windows from all directions.

   Read the final part first to see how data structures are computed.

   vec_mask_faces [vector<vector<int> >] : the height of index, maybe overlapped. 
   vec_mask_images        [vector<int> ] : the index of height of the mask image

   we need to compute the width, vec_horizontal_all, for mask image.
   
 */
void ca_compute_body_mask_for_windows ()
{
   char *value;
   char *fn;
   char *prefix_dumping;
   
   if ( readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   printf("\n\nMODULE: ca_compute_body_mask_for_windows() \n\n");

   int mode = -1;

  start_win_mask:

   mode ++;
   if ( mode > 1 )
      return;
   
   if ( mode == 0 ) { // body
      fn = "result_seg_body_region_faces.txt";
      prefix_dumping = "point_cloud_body_region";
   }
   else {
      fn = "result_seg_roof_region_faces.txt";
      prefix_dumping = "point_cloud_roof_region";
   }
   
   if ( !file_exist(fn) ) {
      goto start_win_mask;
   }

   int i_seg = 1;

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value);
   
   int total_slices = 100;

   // load information of windows on body
   char folder_name[1000], data_fn[1000];
   sprintf(folder_name, "%s_%d", prefix_dumping, i_seg);
   sprintf(data_fn, "%s/window_slices.txt", folder_name);
   char mask_dir[1000];
   sprintf(mask_dir, "%s_%d/bpa_windows", prefix_dumping, i_seg);


   int type_slice = 100;
   float project_ratio = 0.1;
   
   // loading settings
   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
      ca_load_aux_for_each_unit(tmp);
      if ( readRunTimeFlag("ca_aux_window_slices", &tmp_value) && !strcmp(tmp_value, "") == 0) {
         type_slice = atoi(tmp_value);
      }
      if ( readRunTimeFlag("ca_aux_window_ratio", &tmp_value) && !strcmp(tmp_value, "") == 0) {
         project_ratio = atof(tmp_value);
      }
   }
   
   vector<vector<int> *> vec_win_info;
   ca_compute_window_load_info(data_fn, vec_win_info);
   
   
   vector<vector<int> >  vec_mask_faces;
   vector<vector<vector<int> *> > vec_horizontal_all;
            
   char input_fn[1000];
   
   // draw the mask image based on the face and windows index and window positions.
   // vec_win_info: top level windows info from all directions.
   
   for ( int i_ = 0; i_ < vec_win_info.size(); i_ ++ )
   {
      vector<int> *vec_faces = vec_win_info[i_];
      int i_face = vec_faces->at(0);

      int  dir_id = vec_faces->at(1);
      int  start = vec_faces->at(2);
      int  end = vec_faces->at(3);
      
      {
         char ir_fn[1000];
         char *ds_s = digit_string(4, start);
         char *ds_e = digit_string(4, end);
         sprintf(ir_fn, "%s/window_face%d_%d_%d.txt", mask_dir, i_face, start, end);

         array_t *z_arr;
         array_t *end_points_arr;
         end_points_arr = load_end_points_from_IR(ir_fn, z_arr);

         // only for image size, let's put it into ir file later on
         int h = image_height;
         int w = image_width;

         sprintf(input_fn, "%s/window_face%d_%s_%s_mask.png", mask_dir, i_face, ds_s, ds_e);
         BYTE **cur_im = new_image(h,w);

         // compute each window boundary info
         // vec_horizontal: the range of the [min_x, max_x] for a window 
         // vec_height: the height range [min_y, max_y] for a window
         // vec_horizontal is a linked list in that some windows may be merged.
         
         vector<int> vec_height;
         vector<vector<int> *> vec_horizontal;
         
         int k;
         array_t *end_points;
         arrayForEachItem(array_t *, end_points_arr, k, end_points) {
            int index_pt;
            vector<int> *end_pts;
            int min_x, max_x, min_y, max_y;
            arrayForEachItem(vector<int> *, end_points, index_pt, end_pts) {      
               
               int x = (*end_pts)[0];
               int y = (*end_pts)[1];

               if ( index_pt == 0 ) {
                  min_x = max_x = x;
                  min_y = max_y = y;
                  continue;
               }

               min_x = x < min_x ? x : min_x;
               max_x = x > max_x ? x : max_x;
               min_y = y < min_y ? y : min_y;
               max_y = y > max_y ? y : max_y;
               
            } // end of end_pts

            {  // here, we have take care of insert and merge
               // we don't need to worry about insert and merge for vertical case - it's impossible based on window detection process.
               // BUT, this may not valid for horizontal case.
               bool found = false;
               int  h_index = -1;
               for ( int i = 0; i < vec_height.size(); i += 2 ) {
                  if ( min_y < vec_height[i+1] ) {
                     vec_height[i] = vec_height[i] > min_y ? min_y : vec_height[i];
                     vec_height[i+1] = vec_height[i+1] < max_y ? max_y : vec_height[i+1];
                     found = true;
                     h_index = i / 2;
                     break;
                  }
               }

               if ( !found ) {
                  vec_height.push_back(min_y);
                  vec_height.push_back(max_y);
               }

               // update the horizontal
               if ( !found ) {
                  vector<int> *vec_h = new vector<int> ();
                  vec_h->push_back(min_x);
                  vec_h->push_back(max_x);
                  vec_horizontal.push_back(vec_h);
               } else {
                  vector<int> *vec_h = vec_horizontal[h_index];
                  {
                     bool found = false;
                     // we have to take care of merge process
                     for ( int i = 0; i < vec_h->size(); i += 2 ) {
                        if ( min_x < vec_h->at(i+1) && max_x > vec_h->at(i) ) {
                           vec_h->at(i)   = vec_h->at(i)   > min_x ? min_x : vec_h->at(i);
                           vec_h->at(i+1) = vec_h->at(i+1) < max_x ? max_x : vec_h->at(i+1);
                           found = true;

                           // check any possible merginig
                           if ( i + 2 < vec_h->size() ) {
                              int ii = i + 2;
                              while ( ii < vec_h->size() ) {
                                 if ( max_x > vec_h->at(ii) ) {
                                    int max_value = vec_h->at(ii + 1);
                                    vec_h->erase(vec_h->begin() + ii, vec_h->begin() + ii + 2);
                                    vec_h->at(i+1) = vec_h->at(i+1) < max_value ? max_value : vec_h->at(i+1);
                                 } else {
                                    break;
                                 }
                              }
                           }
                           
                           break;
                        }
                        else if ( min_x < vec_h->at(i+1) && max_x < vec_h->at(i) ) {
                           // insert a new one

                           vec_h->insert(vec_h->begin() + i, max_x);
                           vec_h->insert(vec_h->begin() + i, min_x);
                           found = true;
                           break;
                        }
                        
                     }

                     if ( !found ) {
                        vec_h->push_back(min_x);
                        vec_h->push_back(max_x);
                     }
                  }
               }
            }
            
         } // end of end_points_arr

         // make sure the horizontal windows are linked with the same vertical region.
         assert(vec_height.size() / 2 == vec_horizontal.size());
         
         // draw the mask image in window slice, NOT bottom-up slice;
         // this is only used for debugging.
         if ( 0 )
         {
            for (int i = 0; i < vec_height.size(); i +=2 ) {
               int h_lo = vec_height[i];
               int h_hi = vec_height[i+1];

               // get the boundary of windows.
               vector<int> *vec_h = vec_horizontal[i/2];
               for ( int k = 0; k < vec_h->size(); k += 2) {
                  for ( int x = vec_h->at(k); x <= vec_h->at(k+1); x ++ ) {
                     cur_im[h_lo][x] = BLACK;
                     cur_im[h_hi][x] = BLACK;
                     if ( x == vec_h->at(k) || x == vec_h->at(k+1) ) {
                        for ( int kk = h_lo+1;  kk < h_hi; kk ++ )
                           cur_im[kk][x] = BLACK;
                     }
                  }
               }
            }

            // save the image
            Save2File(input_fn, cur_im, NULL, w, h, 0, NULL);
         }

         // for future use
         vec_horizontal_all.push_back(vec_horizontal);
         
         // update the mask image for key-slice detection.
         // transform this side to bottom-up image
         {
            // transformation
            float M[9];
            if ( i_face != -1 ) {
               char trans_back_fn[1000];
               sprintf(trans_back_fn, "face%d/trans_back.txt", i_face);
               ca_load_trans_matrix(trans_back_fn, M);
            }

            float x, y, z, X, Y, Z, x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               sprintf(tmp, "ca_aux_bounding_box_face%d", i_face);
               if ( !readRunTimeFlag(tmp, &tmp_value) ) {
                  // reload the data and store the information.

                  char data_fn[1000];
                  sprintf(data_fn, "%s_%d/%s_trans_%d.txt", prefix_dumping, i_seg, prefix_dumping, i_face - 1);

                  vector<double> data_pts;
                  vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
                  x_min = vec_bounding_box->at(0);
                  x_max = vec_bounding_box->at(1);
                  y_min = vec_bounding_box->at(2);
                  y_max = vec_bounding_box->at(3);
                  z_min = vec_bounding_box->at(4);
                  z_max = vec_bounding_box->at(5);

                  diff_x = x_max - x_min;
                  diff_y = y_max - y_min;
                  
                  int h, w, t;
                  const int LARGE = 1024;
                  float scale = diff_x /diff_y;
                  if ( scale > 1 )
                     scale = 1 / scale;
                  scale = scale * LARGE;
                  t = (int) (scale + .5);
                  t += ( 8 - (t % 8));
                  
                  if ( diff_x > diff_y ) {
                     w = LARGE;
                     h = t;
                  } else {
                     w = t;
                     h = LARGE;
                  }
                  
                  image_width = w;
                  image_height = h;

                  // update value
                  {
                     float *params = (float *) malloc (sizeof(float) * 6 );
                     params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 6);
                     free(params);
                  }
                  
                  {
                     sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                     int *params = (int *) malloc (sizeof(int) * 2 );
                     params[0] = w; params[1] = h;
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 2);
                     free(params);
                  }
               
               } else {
                  assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
                  sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                  assert(readRunTimeFlag(tmp, &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               }

               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               diff_z = z_max - z_min;
               
               if ( dir_id == 1 ) { // max side
                  z_min = z_max - diff_z * project_ratio;
                  z_max = z_max;
               } else { // min side
                  z_min = z_min;
                  z_max = z_min + diff_z * project_ratio;
               }               
            }
            float scale = (double)image_width / diff_x;

            {
               assert(readRunTimeFlag("ca_aux_bounding_box", &value) == 1);
               assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);
            }
            float y_bottom = z;
            float y_top = Z;
            float y_bu_diff = y_top - y_bottom;


            vector<int> vec_3D_h;
            for (int i = 0; i < vec_height.size(); i +=2 ) {
               int h_lo = vec_height[i];
               int h_hi = vec_height[i+1];
               float y_3D_lo = y_min + (image_height - h_lo - 1)/scale;
               float y_3D_hi = y_min + (image_height - h_hi - 1)/scale;
               float x_3D = x_min;
               float z_3D = z_min;
               float *new_pLo = ca_compute_multi_vec_matrix(x_3D, y_3D_lo, z_3D, M);
               float *new_pHi = ca_compute_multi_vec_matrix(x_3D, y_3D_hi, z_3D, M);
               float y_bu_lo = new_pLo[2];
               float y_bu_hi = new_pHi[2];
               free(new_pLo);
               free(new_pHi);
               vec_3D_h.push_back((int) ((y_bu_lo - y_bottom)/y_bu_diff*total_slices));
               vec_3D_h.push_back((int) ((y_bu_hi - y_bottom)/y_bu_diff*total_slices));
               printf("Face %d: slice range: [%d - %d]\n", i_face, (int) ((y_bu_lo - y_bottom)/y_bu_diff*total_slices),
                      (int)((y_bu_hi - y_bottom)/y_bu_diff*total_slices));
            }
            vec_mask_faces.push_back(vec_3D_h);
            
         } // end of cut-off detection for key-slice
      } // end of walls for each face
   } // end of faces

   // obtain global key-slice index for the mask images
   // printf("size: %d, total_FACE:%d\n", vec_mask_faces.size(), total_faces);
   assert( vec_mask_faces.size() == total_faces );

   // update each face the mask index for close ones.
   int offset_thresh = 4;
   vector<int> vec_gbl;
   for ( int i_face = 1; i_face <= total_faces; i_face ++ )
   {
      vector<int> &vec_face = vec_mask_faces[i_face-1];

      // order the index of the masks.
      for ( int i = vec_face.size() - 1; i > -1; i -- ) {
         if ( i_face == 1 )
            vec_gbl.push_back(vec_face[i]);
         else {
            bool found = false;
            for (int j = 0; j < vec_gbl.size(); j ++ ) {
               if ( vec_face[i] <= vec_gbl[j] ) {
                  if ( vec_face[i] + offset_thresh >= vec_gbl[j] ) {
                     vec_face[i] = vec_gbl[j];
                  }
                  else if ( j > 0 && vec_face[i] - offset_thresh <= vec_gbl[j-1] ) {
                     vec_face[i] = vec_gbl[j-1];
                  }
                  else {
                     vec_gbl.insert(vec_gbl.begin() + j, vec_face[i] );
                  }
                  break;
               }
            }
         }
      }
   }

   // compute the maks images and ranges
   printf("ORDER:");
   for ( int i = 0 ; i < vec_gbl.size(); i ++ ) {
      printf(" %d", vec_gbl[i]);
   }
   printf("\n");

   for ( int i_face = 1; i_face <= total_faces; i_face ++ ) {
      vector<int> vec_face = vec_mask_faces[i_face-1];
      
      for ( int j = vec_face.size() - 1; j > -1; j -=2) {
         printf("FACE %d: [%d - %d]\n", i_face, vec_face[j], vec_face[j-1]);
      }
   }
         

   vector<int> vec_mask_images;
   vector<vector<int> > vec_mask_faces_index;

   int mode_end = 0; // # of faces regarding this as end point
   for ( int i = 1 ; i < vec_gbl.size(); i ++ ) {
      int cur_index = vec_gbl[i];
      int pre_index = vec_gbl[i-1];

      vector<int> vec_mask_faces_link;
      for ( int i_face = 1; i_face <= total_faces; i_face ++ ) {
         vector<int> &vec_face = vec_mask_faces[i_face-1];

         for ( int j = vec_face.size() - 1; j > -1; j -= 2) {
            // vec_face[j-1] > vec_face[j]
            // cur_index > pre_index
            if ( vec_face[j] <= pre_index && vec_face[j-1] >= cur_index ) {

               vec_mask_faces_link.push_back(i_face);
               vec_mask_faces_link.push_back(j / 2);

               break;
            }
         }
      }

      vec_mask_images.push_back(pre_index);
      vec_mask_images.push_back(cur_index);
      vec_mask_faces_index.push_back(vec_mask_faces_link);

   }

   printf("vec_mask_faces_index size: %d, vec_mask_images size: %d\n", vec_mask_faces_index.size(), vec_mask_images.size());

   // generate the mask images
   // COMMENT: assert(vec_height.size() / 2 == vec_horizontal.size());
   //          vec_link[j+1] ---> vec_height[]
   //          vec_horizontal ----> windows

   vector<float *> vec_pts_3D;
      
   char mask_result_fn[1000];
   sprintf(mask_result_fn, "%s/result_body_mask_info.txt", mask_dir);

   FILE *fd_mask = fopen(mask_result_fn, "w");
   assert(fd_mask);
   
   for ( int i = 0; i < vec_mask_images.size(); i += 2 ) {

      char mask_fn[1000];

      int bu_index_s = vec_mask_images[i];
      int bu_index_e = vec_mask_images[i+1];
      printf("MASK [%d - %d]:\n", bu_index_s, bu_index_e);
      sprintf(mask_fn, "%s/image_slice_%s_%s.png", mask_dir, digit_string(4, bu_index_s), digit_string(4, bu_index_e));

      vector<int> &vec_link = vec_mask_faces_index[i/2];
      for (int j = 0; j < vec_link.size(); j +=2 ) {

         int i_face = vec_link[j];

         printf("    FACE %d: height: %d\n", vec_link[j], vec_link[j+1]);
         vector<vector<int> *> &vec_horizontal = vec_horizontal_all[i_face -1];
         vector<int> *vec_h = vec_horizontal[vec_link[j+1]];

         // get the width 
         vector<int> *vec_faces = vec_win_info[i_face-1];

         // assume only ONE wall exists
         int dir_id = vec_faces->at(1);
         int start = vec_faces->at(2);
         int end   = vec_faces->at(3);

         {
            float M[9];
            if ( i_face != -1 ) {
               char trans_back_fn[1000];
               sprintf(trans_back_fn, "face%d/trans_back.txt", i_face);

               ca_load_trans_matrix(trans_back_fn, M);
            }

            float x, y, z, X, Y, Z, x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               sprintf(tmp, "ca_aux_bounding_box_face%d", i_face);
               if ( !readRunTimeFlag(tmp, &tmp_value) ) {
                  // reload the data and store the information.

                  char data_fn[1000];
                  sprintf(data_fn, "%s_%d/%s_trans_%d.txt", prefix_dumping, i_seg, prefix_dumping, i_face - 1);

                  vector<double> data_pts;
                  vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
                  x_min = vec_bounding_box->at(0);
                  x_max = vec_bounding_box->at(1);
                  y_min = vec_bounding_box->at(2);
                  y_max = vec_bounding_box->at(3);
                  z_min = vec_bounding_box->at(4);
                  z_max = vec_bounding_box->at(5);

                  diff_x = x_max - x_min;
                  diff_y = y_max - y_min;
                  
                  int h, w, t;
                  const int LARGE = 1024;
                  float scale = diff_x /diff_y;
                  if ( scale > 1 )
                     scale = 1 / scale;
                  scale = scale * LARGE;
                  t = (int) (scale + .5);
                  t += ( 8 - (t % 8));
                  
                  if ( diff_x > diff_y ) {
                     w = LARGE;
                     h = t;
                  } else {
                     w = t;
                     h = LARGE;
                  }
                  
                  image_width = w;
                  image_height = h;

                  // update value
                  {
                     float *params = (float *) malloc (sizeof(float) * 6 );
                     params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 6);
                     free(params);
                  }
                  
                  {
                     sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                     int *params = (int *) malloc (sizeof(int) * 2 );
                     params[0] = w; params[1] = h;
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 2);
                     free(params);
                  }
               
               } else {
                  assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
                  sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                  assert(readRunTimeFlag(tmp, &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               }

               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               diff_z = z_max - z_min;

               if ( dir_id == 1 ) { // max side
                  z_min = z_max - diff_z * project_ratio;
                  z_max = z_max;
               } else { // min side
                  z_min = z_min;
                  z_max = z_min + diff_z * project_ratio;
               }

               sprintf(tmp, "ca_aux_image_size_face%d", i_face);
               assert(readRunTimeFlag(tmp, &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               
            }

            int h = image_height;
            int w = image_width;

            // temp setting
            float z_height_lo = z_min + start/(float)total_slices * (z_max - z_min);
            float z_height_hi = z_min + end/(float)total_slices * (z_max - z_min);
            float scale = (double)image_width / diff_x;

            for (int i = 0; i < vec_h->size(); i += 2) {
               int x_s = vec_h->at(i);
               int x_e = vec_h->at(i+1);

               float x_3D_1 = x_min + diff_x/image_width * x_s;
               float x_3D_2 = x_min + diff_x/image_width * x_e;
               float y_3D = y_min + (image_height - 0 - 1)/scale;
               float z_3D_1 = z_height_lo;
               float z_3D_2 = z_height_hi;

               float *p1 = ca_compute_multi_vec_matrix(x_3D_1, y_3D, z_3D_1, M);
               float *p2 = ca_compute_multi_vec_matrix(x_3D_2, y_3D, z_3D_1, M);
               float *p3 = ca_compute_multi_vec_matrix(x_3D_2, y_3D, z_3D_2, M);
               float *p4 = ca_compute_multi_vec_matrix(x_3D_1, y_3D, z_3D_2, M);
               
               vec_pts_3D.push_back(p1);
               vec_pts_3D.push_back(p2);
               vec_pts_3D.push_back(p3);
               vec_pts_3D.push_back(p4);
            }
         }
      }

      // If this is a empty region.
      if ( vec_pts_3D.size() == 0 )
         continue;

      // dump the mask info.
      fprintf(fd_mask, "%s %d %d\n", mask_fn, bu_index_s, bu_index_e);
      
      
      // transform 3D points back to 2D bottom-up image
      // draw 3D points on 2D image
      {

         float x, y, z, X, Y, Z, x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
         {
            char tmp[1000], *tmp_value;
            sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
            ca_load_aux_for_each_unit(tmp);
            assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
            assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;

            assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
            assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
         }
         
         int w = image_width;
         int h = image_height;
      
         BYTE **all_im = new_image(image_height, image_width);
      
         float scale = (float)image_width / diff_x;

         x = x_min; y = y_min;
         for (int i = 0; i < vec_pts_3D.size(); i += 4 ) {
            float *new_P1 = vec_pts_3D[i];
            float *new_P2 = vec_pts_3D[i+1];
            float *new_P3 = vec_pts_3D[i+2];
            float *new_P4 = vec_pts_3D[i+3];
         
            int im_y1 = image_height - (int)((new_P1[1] - y) * scale + .5) - 1;
            int im_x1 = (int)(((new_P1[0] - x)/diff_x)*image_width  + .5); // x
            int im_y2 = image_height - (int)((new_P2[1] - y) * scale + .5) - 1;
            int im_x2 = (int)(((new_P2[0] - x)/diff_x)*image_width  + .5); // x
            int im_y3 = image_height - (int)((new_P3[1] - y) * scale + .5) - 1;
            int im_x3 = (int)(((new_P3[0] - x)/diff_x)*image_width  + .5); // x
            int im_y4 = image_height - (int)((new_P4[1] - y) * scale + .5) - 1;
            int im_x4 = (int)(((new_P4[0] - x)/diff_x)*image_width  + .5); // x
         
            draw_line_on_2D_image(all_im, h, w, im_x1, im_y1, im_x2, im_y2);
            draw_line_on_2D_image(all_im, h, w, im_x2, im_y2, im_x3, im_y3);
            draw_line_on_2D_image(all_im, h, w, im_x3, im_y3, im_x4, im_y4);
            draw_line_on_2D_image(all_im, h, w, im_x4, im_y4, im_x1, im_y1);

            free(new_P1);
            free(new_P2);
            free(new_P3);
            free(new_P4);
         }

         Save2File(mask_fn, all_im, NULL, w, h, 0, NULL);
         free_image(all_im);

         vec_pts_3D.clear();
      } // most resources are freeed.

   }

   fclose(fd_mask);

}


/*
  Function: ca_compute_project_point

  Equation for computing the projection point:
  http://www.softsurfer.com/Archive/algorithm_0104/algorithm_0104.htm
*/

float *ca_compute_project_point(float *p0, PLANE_3D *plane)
{
   /*
   float a = plane->A;
   float b = plane->B;
   float c = plane->C;
   float d = plane->D;
   float pt_sum = a * p0[0] + b * p0[1] + c * p0[2] + d;

   printf("p0(%f, %f, %f), a:%f, b: %f, c:%f, d: %f,\n", p0[0],p0[1],p0[2], a, b, c, d);
   float *p = (float *)malloc(3*sizeof(float));
   if ( pt_sum  < 0.00001 ) {
      memcpy(p, p0, sizeof(float) * 3);
      return p;
   }

   float sqrt_sum = a*a + b*b + c*c;
   float scale = pt_sum / sqrt_sum;
   p[0] = p0[0] - scale * plane->N.x;
   p[1] = p0[1] - scale * plane->N.y;
   p[2] = p0[2] - scale * plane->N.z;
   printf("p0(%f, %f, %f) -> p(%f, %f, %f)\n", p0[0],p0[1],p0[2], p[0], p[1], p[2]);
   printf("a:%f,b: %f, c:%f, d: %f, sc: %f, N: %f, %f, %f \n", a, b, c, d, scale, plane->N.x, plane->N.y, plane->N.z);

   return p;
   */

   float sn, sd, sb;

   POINT_3D p1;
   p1.x = p0[0] - plane->V.x;
   p1.y = p0[1] - plane->V.y;
   p1.z = p0[2] - plane->V.z;
   sn = -dot_product( plane->N, p1 );
   sd = dot_product(plane->N, plane->N);
   sb = sn / sd;
   
   float *p = (float *)malloc(3*sizeof(float));
   
   p[0] = p0[0] + sb * plane->N.x;   
   p[1] = p0[1] + sb * plane->N.y;   
   p[2] = p0[2] + sb * plane->N.z;
   // printf("p0(%f, %f, %f) -> p(%f, %f, %f)\n", p0[0],p0[1],p0[2], p[0], p[1], p[2]);

   return p;
}

void ca_load_variable_length_info(char *fn, vector<vector<int> *> &vec_segments, bool ignore_first)
{
   FILE *type_fd = fopen(fn, "r");
   if ( !type_fd ) {
      printf("ERROR: Could not open %s for read.\n", fn);
      assert(type_fd);
   }

   char str[1000];
   while (fgets(str, 1000, type_fd) ) {
      char *seg_name = strtok(str, " ");
      int seg_id;
      char tmp_str[1000];
      assert(sscanf(seg_name, "%s_%d", tmp_str, &seg_id) == 1);

      char *shape_type_str = strtok(NULL, " ");
      vector<int> * vec_faces = new vector<int> ();
      vec_segments.push_back(vec_faces);

      if ( !ignore_first )
         vec_faces->push_back(seg_id);
      
      vec_faces->push_back(atoi(shape_type_str));
      
      char *face_id = strtok(NULL, " ");
      while ( face_id) {
         vec_faces->push_back(atoi(face_id));
         face_id = strtok(NULL, " ");
      }
   }
}

void ca_generate_slices(int mode)
{
   // load the segment info from result_seg_roof_region_faces.txt / result_seg_body_region_faces.txt

   char *fn;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      fn = "result_seg_body_region_faces.txt";
      prefix_dumping = "point_cloud_body_region";
   }
   else {
      fn = "result_seg_roof_region_faces.txt";
      prefix_dumping = "point_cloud_roof_region";
   }

   if ( !file_exist(fn) )
      return;
   
   vector<vector<int> * > vec_segments;
   ca_load_variable_length_info(fn, vec_segments);

   // do slicing for remaining directions.
   for ( int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
   {
      int type_slice = 100;
      float project_ratio = 0.1;
      int max_win_size = -1;

      int region_id = vec_segments[i_seg]->at(0);

      // loading settings
      {
         char tmp[1000], *tmp_value;
         sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
         ca_load_aux_for_each_unit(tmp);
         if ( readRunTimeFlag("ca_aux_window_slices", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            type_slice = atoi(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_window_ratio", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            project_ratio = atof(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_window_size", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            max_win_size = atoi(tmp_value);
         }
      }
      
      for (int j = 1; j < vec_segments[i_seg]->size(); j ++ )
      {
         int face_id = vec_segments[i_seg]->at(j);

         char seg_fn[1000], folder_name[1000], data_fn[1000], trans_matrix[1000], sub_folder[1000];

         sprintf(seg_fn, "%s_%d.txt", prefix_dumping, i_seg);
         sprintf(folder_name, "%s_%d", prefix_dumping, i_seg);
         sprintf(data_fn, "%s/%s_trans_%d.txt", folder_name, prefix_dumping, face_id);
         gbl_opts->input_prefix  = seg_fn;
         gbl_opts->output_prefix = data_fn;

         if ( !file_exist(data_fn) ) {
            sprintf(trans_matrix, "face%d/trans.txt", face_id+1);
            
            printf("compute transformation for %s to %s\n", seg_fn, data_fn);
            compute_trans(trans_matrix);
            
         }


         // create a folder for this face transform
#ifndef LINUX
         sprintf(sub_folder, "%s\\window_min_slice_for_face%d", folder_name, face_id + 1);
#else
         sprintf(sub_folder, "%s/window_min_slice_for_face%d", folder_name, face_id + 1);
#endif               

         char slice_fn[1000];
         sprintf(slice_fn, "%s/image_slice_0000.png", sub_folder);
         if ( !file_exist( slice_fn ) ) {
            char cmd[1000];
            sprintf(cmd, "mkdir %s", sub_folder);
            system(cmd);
         } else {
            continue;
         }

         // do the slicing

         // 1. get the range of [x X], [y Y].
         // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
         // 3. dump the image in folder_name/slice_for_type
         vector<double> data_pts;
         vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
         float x_min = vec_bounding_box->at(0);
         float x_max = vec_bounding_box->at(1);
         float y_min = vec_bounding_box->at(2);
         float y_max = vec_bounding_box->at(3);
         float z_min = vec_bounding_box->at(4);
         float z_max = vec_bounding_box->at(5);
         float diff_x = x_max - x_min;
         float diff_y = y_max - y_min;
         float diff_z = z_max - z_min;

         int h, w, t;
         int LARGE = 1024;
         if ( max_win_size != -1 )
            LARGE = max_win_size;
         
         float scale = diff_x /diff_y;
         if ( scale > 1 )
            scale = 1 / scale;
         scale = scale * LARGE;
         t = (int) (scale + .5);
         t += ( 8 - (t % 8));
      
         if ( diff_x > diff_y ) {
            w = LARGE;
            h = t;
         } else {
            w = t;
            h = LARGE;
         }
         printf("IMAGE SIZE: w - %d, h - %d  for segment %d of face %d\n", w, h, i_seg, face_id);
         image_width = w;
         image_height = h;

         // dump the data into image


         // let use 10% for imaging
         x_min -= diff_x * .1;
         x_max += diff_x * .1;
         y_min -= diff_y * .1;
         y_max += diff_y * .1;

         float z_min_orig = z_min;
         float z_max_orig = z_max;

         z_min = z_min_orig;
         z_max = z_min_orig + diff_z * project_ratio;
         project_point_cloud_into_image(data_pts, sub_folder,
                                        1, type_slice,
                                        x_min, x_max, y_min, y_max, z_min, z_max);

#ifndef LINUX
         sprintf(sub_folder, "%s\\window_max_slice_for_face%d", folder_name, face_id + 1);
#else
         sprintf(sub_folder, "%s/window_max_slice_for_face%d", folder_name, face_id + 1);
#endif               

         sprintf(slice_fn, "%s/image_slice_0000.png", sub_folder);
         if ( !file_exist( slice_fn ) ) {
            char cmd[1000];
            sprintf(cmd, "mkdir %s", sub_folder);
            system(cmd);
         } else {
            continue;
         }

         z_min = z_max_orig - diff_z * project_ratio;
         z_max = z_max_orig;
         project_point_cloud_into_image(data_pts, sub_folder,
                                        1, type_slice,
                                        x_min, x_max, y_min, y_max, z_min, z_max);
         
      }
   }

}

bool ca_is_qualified_plane(map<int, vector<float> *> &map_plane2box, int i_plane, float * p_base)
{
   vector<float> *vec_box = map_plane2box[i_plane];

   if ( vec_box == NULL ) // top or bottom face
      return true;

   float x = p_base[0];
   float y = p_base[1];
   float z = p_base[2];

   float x3d_min = vec_box->at(0);
   float y3d_min = vec_box->at(1);
   float z3d_min = vec_box->at(2);
   float x3d_max = vec_box->at(3);
   float y3d_max = vec_box->at(4);
   float z3d_max = vec_box->at(5);

   return ( x >= x3d_min && x <= x3d_max &&
            y >= y3d_min && y <= y3d_max &&
            z >= z3d_min && z <= z3d_max );
}

void ca_dump_window_project_model(int mode )
{

   char *fn, *result_fn, *result_fn_flag;
   char *value;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      fn = "result_seg_body_region_faces.txt";
      result_fn = "result_seg_body_regtypes_2.txt";
      result_fn_flag = "result_segment_body_reg_types_2";
      prefix_dumping = "point_cloud_body_region";
   }
   else {
      fn = "result_seg_roof_region_faces.txt";
      result_fn = "result_seg_roof_regtypes_2.txt";
      result_fn_flag = "result_segment_roof_reg_types_2";
      prefix_dumping = "point_cloud_roof_region";
   }

   if ( !file_exist(fn) )
      return;
   
   char *reg_type_fn;
   if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
      reg_type_fn = result_fn;

   vector<vector<int> * > vec_seg_type;
   ca_load_variable_length_info(reg_type_fn, vec_seg_type, true);
   
   vector<vector<int> * > vec_segments;
   ca_load_variable_length_info(fn, vec_segments);


   char *key_str, all_key_fn[1000];
   if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
      key_str = "key_slices.txt";
   
   char *ir_all_fn  = "IR_taper_all.txt";
   FILE *fd = fopen(ir_all_fn, "a");
   assert(fd);

   for ( int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
   {
      int type_slice = 100;
      float project_ratio = 0.1;
      float window_depth = -1.0;
      bool ca_aux_win_extrusion_reverse = false;

      printf("\nSEGMENT: %d ----\n\n", i_seg);
      // loading settings
      {
         char tmp[1000], *tmp_value;
         sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
         ca_load_aux_for_each_unit(tmp);
         if ( readRunTimeFlag("ca_aux_window_slices", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            type_slice = atoi(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_window_ratio", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            project_ratio = atof(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_window_depth_ratio", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            window_depth = atof(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_win_extrusion_reverse", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            ca_aux_win_extrusion_reverse = atoi(tmp_value) == 1 ? true : false;
         }
      }
      

      char win_fn[1000];
      sprintf(win_fn, "%s_%d/window_slices.txt", prefix_dumping, i_seg);
      if ( !file_exist(win_fn) )
         continue;
      
      // for each region/unit, compute all 3D planes
      sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);
      vector<int> *vec_extrude_layers = ca_load_simple_vector(all_key_fn);

      // we may have to transform the extrusion if it is not from buttom-up
      vector<int > *vec_faces = vec_seg_type[i_seg];
      float M[9];
      if ( vec_faces->size() > 1 && vec_faces->at(0) == 0 ) // if extruded, and not from buttom-up
      {
         int face_id = vec_faces->at(1) + 1;
         char trans_back_fn[1000];
         sprintf(trans_back_fn, "face%d/trans_back.txt", face_id);
         printf(" We have to load transformation matrix from %s \n", trans_back_fn);
         
         ca_load_trans_matrix(trans_back_fn, M);
      }
      
      // ASSUMPTION:
      // let's assume the extrusion is the first keyslice for now.
      // the above assumption won't work
      PLANE_3D *plane_3d;
      vector<PLANE_3D *> vec_face_plane;
      map<int, char *> map_plane2info;
      map<int, vector<float> *> map_plane2box;
      int total_extruded_slices = -1;
      char ir_fn[1000], pt_fn[1000];
      float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y, diff_z;
      for ( int i_layer = 0; i_layer < vec_extrude_layers->size(); i_layer ++ ) {

         int pre_h = i_layer == 0 ? 0 : vec_extrude_layers->at(i_layer - 1);
         int cur_h = vec_extrude_layers->at(i_layer);

         if ( mode == 1 && i_layer > 0 )
            continue;
         
         sprintf(ir_fn, "%s_%d/bpa_keyslices/bpa_image_slice_%d_%d_dumped_0.txt", prefix_dumping, i_seg, pre_h, cur_h);
         if ( !file_exist(ir_fn)) {
            sprintf(ir_fn, "%s_%d/bpa_keyslices/HT_BPA_image_slice_%d_%d_dumped_0.txt", prefix_dumping, i_seg, pre_h, cur_h);
            if ( !file_exist(ir_fn)) {
               sprintf(ir_fn, "%s_%d/bpa_keyslices/image_slice_%d_%d_dumped_0.txt", prefix_dumping, i_seg, pre_h, cur_h);
               assert( file_exist(ir_fn));
            }
         }
      
         vector<int> all_lines;
         load_lines_from_BPA_dump(all_lines, ir_fn, image_height, image_width);
         strcpy(pt_fn, "ca_aux_bounding_box");

      
         {
            char tmp[1000], tmp_value;
            sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
            ca_load_aux_for_each_unit(tmp);

            assert( readRunTimeFlag("ca_aux_total_slices", &value) );
            total_extruded_slices = atoi(value);
            assert(total_extruded_slices > 0 );
            
            assert( readRunTimeFlag(pt_fn, &value) );

         }
      
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         diff_x = x_max - x_min;
         diff_y = y_max - y_min;
         x_min -= diff_x * .1;
         x_max += diff_x * .1;
         y_min -= diff_y * .1;
         y_max += diff_y * .1;
      

         POINT_3D p1_3d, p2_3d, p3_3d, p4_3d;
      
         // temp setting
         diff_x = x_max - x_min;
         float z_height_lo = z_min;
         float z_height_hi = z_max;
         float scale = (double)image_width / diff_x;
         vector<int> vec_pt_face;
         for (int i = 0; i < all_lines.size(); i +=4 )
         {
            int x = all_lines[i];
            int y = all_lines[i+1];

            int x1 = all_lines[i+2];
            int y1 = all_lines[i+3];

            // the best way is to sort all line segments, and pick up the first N ones.
            int thresh_plane_len = 20;

            char *len_str = NULL;
            if ( readRunTimeFlag("window_plane_least_line_len", &len_str) ) {
               thresh_plane_len = atoi(len_str);
            }

            if ( abs(x1 - x) + abs(y1 - y) < thresh_plane_len ) 
               continue;

            if ( vec_pt_face.size() < 6) {
               vec_pt_face.push_back(x);
               vec_pt_face.push_back(y);
            }
            
            float y_3D = y_min + (image_height - y - 1)/scale;
            float x_3D = x_min + diff_x/image_width * x;
            float z_3D_lo = z_min + (z_max - z_min) * ((pre_h+1)/(float)total_extruded_slices); // pre_h == 0 ? should be ok.
            float z_3D_hi = z_min + (z_max - z_min) * ((cur_h+1)/(float)total_extruded_slices); // cur_h = 199
            p1_3d.x = x_3D;
            p1_3d.y = y_3D;
            p1_3d.z = z_3D_lo;
            
            p2_3d.x = x_3D;
            p2_3d.y = y_3D;
            p2_3d.z = z_3D_hi;
         
            x = all_lines[i+2];
            y = all_lines[i+3];
            y_3D = y_min + (image_height - y - 1)/scale;
            x_3D = x_min + diff_x/image_width * x;
            p3_3d.x = x_3D;
            p3_3d.y = y_3D;
            p3_3d.z = z_3D_lo;

            p4_3d.x = x_3D;
            p4_3d.y = y_3D;
            p4_3d.z = z_3D_hi;
            
            // compute the plane
            printf("[%d, %d]-->[%d %d], [%f -- %f]\n", all_lines[i], all_lines[i+1], x, y, z_min, z_max);
            if ( vec_faces->size() > 1 && vec_faces->at(0) == 0 ) // if extruded, and not from buttom-up
            {
               float *new_p;
               new_p = ca_compute_multi_vec_matrix(p1_3d.x, p1_3d.y, p1_3d.z, M);
               p1_3d.x = new_p[0];
               p1_3d.y = new_p[1];
               p1_3d.z = new_p[2];
               free(new_p);

               new_p = ca_compute_multi_vec_matrix(p2_3d.x, p2_3d.y, p2_3d.z, M);
               p2_3d.x = new_p[0];
               p2_3d.y = new_p[1];
               p2_3d.z = new_p[2];
               free(new_p);

               new_p = ca_compute_multi_vec_matrix(p3_3d.x, p3_3d.y, p3_3d.z, M);
               p3_3d.x = new_p[0];
               p3_3d.y = new_p[1];
               p3_3d.z = new_p[2];
               free(new_p);
               
               new_p = ca_compute_multi_vec_matrix(p4_3d.x, p4_3d.y, p4_3d.z, M);
               p4_3d.x = new_p[0];
               p4_3d.y = new_p[1];
               p4_3d.z = new_p[2];
               free(new_p);
               
            }
            
            plane_3d = compute_plane_from_3D_pts(p1_3d, p2_3d, p3_3d);
            if ( plane_3d ) {
               vec_face_plane.push_back(plane_3d);
               char str_tmp[1000];
               sprintf(str_tmp, "[%d, %d]-->[%d %d]", all_lines[i], all_lines[i+1], x, y);
               map_plane2info[vec_face_plane.size()-1] = strdup(str_tmp);

               // compute the bounding box of the 3D polygon
               float x3d_min = p1_3d.x;
               float y3d_min = p1_3d.y;
               float z3d_min = p1_3d.z;
               float x3d_max = p1_3d.x;
               float y3d_max = p1_3d.y;
               float z3d_max = p1_3d.z;
               x3d_min = min(p4_3d.x, min(p3_3d.x, min(x3d_min, p2_3d.x)));
               y3d_min = min(p4_3d.y, min(p3_3d.y, min(y3d_min, p2_3d.y)));
               z3d_min = min(p4_3d.z, min(p3_3d.z, min(z3d_min, p2_3d.z)));
               x3d_max = max(p4_3d.x, max(p3_3d.x, max(x3d_max, p2_3d.x)));
               y3d_max = max(p4_3d.y, max(p3_3d.y, max(y3d_max, p2_3d.y)));
               z3d_max = max(p4_3d.z, max(p3_3d.z, max(z3d_max, p2_3d.z)));
               
               vector<float> *vec_box = new vector<float> ();
               vec_box->push_back(x3d_min);
               vec_box->push_back(y3d_min);
               vec_box->push_back(z3d_min);
               vec_box->push_back(x3d_max);
               vec_box->push_back(y3d_max);
               vec_box->push_back(z3d_max);
               map_plane2box[vec_face_plane.size()-1] = vec_box;
            }

         }

         // add 3 more plane, ie. this face itself, this face to z_height_hi, this face to z_height_lo
         {
            if ( vec_pt_face.size() == 6)
            {
               float z_vec[2];
               z_vec[0] = z_height_lo;
               z_vec[1] = z_height_hi;

               for ( int z_index = 0; z_index < 2; z_index ++ )
               {
                  int in = 0;
                  p1_3d.x = x_min + diff_x/image_width * vec_pt_face[in];
                  p1_3d.y = y_min + (image_height - vec_pt_face[in+1] - 1)/scale;
                  p1_3d.z = z_vec[z_index];

                  in ++;
                  p2_3d.x = x_min + diff_x/image_width * vec_pt_face[in];
                  p2_3d.y = y_min + (image_height - vec_pt_face[in+1] - 1)/scale;
                  p2_3d.z = z_vec[z_index];
               
                  in ++;
                  p3_3d.x = x_min + diff_x/image_width * vec_pt_face[in];
                  p3_3d.y = y_min + (image_height - vec_pt_face[in+1] - 1)/scale;
                  p3_3d.z = z_vec[z_index];

                  if ( vec_faces->size() > 1 && vec_faces->at(0) == 0 ) // if extruded, and not from buttom-up
                  {
                     float *new_p;
                     new_p = ca_compute_multi_vec_matrix(p1_3d.x, p1_3d.y, p1_3d.z, M);
                     p1_3d.x = new_p[0];
                     p1_3d.y = new_p[1];
                     p1_3d.z = new_p[2];
                     free(new_p);

                     new_p = ca_compute_multi_vec_matrix(p2_3d.x, p2_3d.y, p2_3d.z, M);
                     p2_3d.x = new_p[0];
                     p2_3d.y = new_p[1];
                     p2_3d.z = new_p[2];
                     free(new_p);

                     new_p = ca_compute_multi_vec_matrix(p3_3d.x, p3_3d.y, p3_3d.z, M);
                     p3_3d.x = new_p[0];
                     p3_3d.y = new_p[1];
                     p3_3d.z = new_p[2];
                     free(new_p);
               
                  }
            
                  plane_3d = compute_plane_from_3D_pts(p1_3d, p2_3d, p3_3d);
                  if ( plane_3d ) {
                     vec_face_plane.push_back(plane_3d);
                     char str_tmp[1000];
                     sprintf(str_tmp, "top or bottom of %s", ir_fn);
                     map_plane2info[vec_face_plane.size()-1] = strdup(str_tmp);
                     map_plane2box[vec_face_plane.size()-1] = NULL;
                  }

               }
               
            }
         }
      }

      printf("Total %d planes are computed for UNIT %d\n", vec_face_plane.size(), i_seg);

      // project the windows on the units

      vector<vector<int> *> vec_win_info;
      ca_compute_window_load_info(win_fn, vec_win_info); 
      for ( int i_face = 0; i_face < vec_win_info.size(); i_face ++ )
      {
         int face_id  = vec_win_info[i_face]->at(0);
         int  dir_id  = vec_win_info[i_face]->at(1);
         int start_id = vec_win_info[i_face]->at(2);
         int  end_id  = vec_win_info[i_face]->at(3);
         
         char ir_fn[1000];
         sprintf(ir_fn, "%s_%d/bpa_windows/window_face%d_%d_%d.txt", prefix_dumping, i_seg, face_id, start_id, end_id);

         array_t *z_arr;
         array_t *end_points_arr;
         end_points_arr = load_end_points_from_IR(ir_fn, z_arr);


         float M[9];
         {
            char trans_back_fn[1000];
            sprintf(trans_back_fn, "face%d/trans_back.txt", face_id);
            printf(" We have to load transformation matrix from %s \n", trans_back_fn);

            ca_load_trans_matrix(trans_back_fn, M);
         }

         sprintf(pt_fn, "%s_%d/%s_trans_%d.txt", prefix_dumping, i_seg, prefix_dumping, face_id-1);
         vector<double> data_pts;
         vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(pt_fn, data_pts);
         x_min = vec_bounding_box->at(0);
         x_max = vec_bounding_box->at(1);
         y_min = vec_bounding_box->at(2);
         y_max = vec_bounding_box->at(3);
         z_min = vec_bounding_box->at(4);
         z_max = vec_bounding_box->at(5);
         if ( 0 )
         {
            char tmp[1000], tmp_value;
            sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
            ca_load_aux_for_each_unit(tmp);
            assert( readRunTimeFlag(pt_fn, &value) );
            assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         }
      
         diff_x = x_max - x_min;
         diff_y = y_max - y_min;
         diff_z = z_max - z_min;

         x_min -= diff_x * .1;
         x_max += diff_x * .1;
         y_min -= diff_y * .1;
         y_max += diff_y * .1;
               
         float z_min_orig = z_min;
         float z_max_orig = z_max;

         if ( dir_id == 1 ) { // max side
            z_min = z_max_orig - diff_z * project_ratio;
            z_max = z_max_orig;
         } else { // min side
            z_min = z_min_orig;
            z_max = z_min_orig + diff_z * project_ratio;
         }

         // temp setting
         diff_x = x_max - x_min;
         float z_height_lo = z_min + start_id/(float)type_slice * (z_max - z_min);
         float z_height_hi = z_min + end_id/(float)type_slice * (z_max - z_min);
         float scale = (double)image_width / diff_x;

         float z_height_lo_trans = z_height_lo;
         float z_height_hi_trans = z_height_hi;
         {
            float *new_p1 = ca_compute_multi_vec_matrix(0.0, 0.0, z_height_lo, M);
            float *new_p2 = ca_compute_multi_vec_matrix(0.0, 0.0, z_height_hi, M);
            
            for ( int i = 0; i < 3; i ++ ) {
               if ( abs(z_height_lo - z_height_hi) == abs(new_p1[i] - new_p2[i])) {
                  z_height_lo_trans = new_p1[i];
                  z_height_hi_trans = new_p2[i];
                  break;
               }
            }
            free(new_p1);
            free(new_p2);
         }
         
         if ( window_depth != -1.0) {
            z_height_hi_trans = z_height_lo_trans + (z_height_hi_trans - z_height_lo_trans) * window_depth;
         }

         // let's exchange low and high for extrusion
         if ( ca_aux_win_extrusion_reverse ) {
            float temp = z_height_lo_trans;
            z_height_lo_trans = z_height_hi_trans;
            z_height_hi_trans = temp;
         }
               
         int k;
         array_t *end_points;
         arrayForEachItem(array_t *, end_points_arr, k, end_points) {

            fprintf(fd, "BEGIN POLYGON\nHEIGHT\n");
            fprintf(fd, "%f %f\nTYPE\n%d\nPOINTS\n", z_height_lo_trans, z_height_hi_trans, 0 );

               
            int x_c0 = 0;
            int y_c0 = 0;

            int index_pt;
            vector<int> *end_pts;

            int min_win_x = 10000, max_win_x = -1;
            int min_win_y = 10000, max_win_y = -1;
            //compute the centroid of this window
            arrayForEachItem(vector<int> *, end_points, index_pt, end_pts) {
               int x = (*end_pts)[0];
               int y = (*end_pts)[1];
               x_c0 += x;
               y_c0 += y;
               min_win_x = min_win_x > x ? x : min_win_x;
               min_win_y = min_win_y > y ? y : min_win_y;
               max_win_x = max_win_x < x ? x : max_win_x;
               max_win_y = max_win_y < y ? y : max_win_y;
            }
            x_c0 = (int)(x_c0 / array_n(end_points));
            y_c0 = (int)(y_c0 / array_n(end_points));

            
            arrayForEachItem(vector<int> *, end_points, index_pt, end_pts) {      

               int x = (*end_pts)[0];
               int y = (*end_pts)[1];

               if ( index_pt == 0 ) // we should update plane_3d every time
               {
                  // compute the plane_3d based on the distance from the center of the image
                  float y_3D = y_min + (image_height - y_c0 - 1)/scale;
                  float x_3D = x_min + diff_x/image_width * x_c0;
                  float z_3D = z_height_hi;
                  float *p_center = ca_compute_multi_vec_matrix(x_3D, y_3D, z_3D, M); // transfer back to legitimacy coord
                  float min_dis = 1000000.0;  // should be ok for a model.
                  int right_plane_index = -1;
                  for ( int i_plane = 0; i_plane < vec_face_plane.size(); i_plane ++ )
                  {
                     float *p_base = ca_compute_project_point(p_center, vec_face_plane[i_plane]);
                     if ( ca_is_qualified_plane(map_plane2box, i_plane, p_base) == false )
                        continue;
                     
                     float dis = sqrt((p_center[0]-p_base[0]) * (p_center[0]-p_base[0]) +
                                      (p_center[1]-p_base[1]) * (p_center[1]-p_base[1]) +
                                      (p_center[2]-p_base[2]) * (p_center[2]-p_base[2]));
                     if ( dis < min_dis ) {
                        min_dis = dis;
                        plane_3d = vec_face_plane[i_plane];
                        right_plane_index = i_plane;
                     }
                  }
                  assert(right_plane_index != -1);
                  printf("\nWINDOW [%d,%d] => [%d, %d] has the plane [%s]\n",
                         min_win_x, min_win_y, max_win_x, max_win_y,
                         map_plane2info[right_plane_index]);
               }               

                  
               // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
               // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
               float y_3D = y_min + (image_height - y - 1)/scale;
               float x_3D = x_min + diff_x/image_width * x;
               float z_3D = z_height_lo;

               {

                  float *new_p1 = ca_compute_multi_vec_matrix(x_3D, y_3D, z_3D, M);
                  float *new_p  = ca_compute_project_point(new_p1, plane_3d);
                  x_3D = new_p[0];
                  y_3D = new_p[1];
                  z_3D = new_p[2];
                  free(new_p);
                  free(new_p1);
                     
               }
               fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);
            }

            fprintf(fd, "EXTRUSION\nEND POLYGON\n");
               
         }
      }
   }

   fclose(fd);

}


/*
  Function: ca_dump_window_on_body

  Equation for computing the projection point:
  http://www.softsurfer.com/Archive/algorithm_0104/algorithm_0104.htm

  P_pi = P_0 - (ax_0 + by_0 + cz_0 + d)/(a^2 + b^2 + c^2) * Normal
  
 */
void ca_dump_window_on_body()
{

   char *value;
   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   if ( !ca_has_body() )
      return;
   
   printf("\n\nMODULE: ca_dump_window_on_body() \n\n");

   // algorithm:

   // 1. Generate image slices from 10% point cloud data from all faces touched by this segmented unit.
   ca_generate_slices( 0 );
   
   // 2. Compute the windows by integrating all window slices.
   ca_compute_window_structure( 0 );

   // 3. projecting the windows using the following code.
   ca_dump_window_project_model( 0 );
}


/*
  Function: ca_dump_window_on_body

  Equation for computing the projection point:
  http://www.softsurfer.com/Archive/algorithm_0104/algorithm_0104.htm

  P_pi = P_0 - (ax_0 + by_0 + cz_0 + d)/(a^2 + b^2 + c^2) * Normal

  Assumptions:
  *. all the sub-unit contours along the boundary are parallel to the boundary line
  *. they are not necessary standing on the boundary lines. It should not be matter
     which point to starting for parallel computing.
  
  Algorithm:
  *. Adjust the contour of the sub-units to be parallel to the boundary.
  *. For each window, locate the correct contour to be pasted.
      1. the window bounding box should be following the range of the contour.
      2. the distance from the bounding box to the line should be small.
  
 */
void ca_dump_window_on_roof()
{

   char *value;
   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   printf("\n\nMODULE: ca_dump_window_on_roof() \n\n");

   // algorithm:

   // 1. Generate image slices from 10% point cloud data from all faces touched by this segmented unit.
   ca_generate_slices( 1 );
   
   // 2. MANUALLY create the windows images by integrating all window slices.
   ca_compute_window_structure( 1 );

   // 3. projecting the windows using the following code.
   ca_dump_window_project_model( 1 );
}

bool ca_dump_ledger_height(float lo, float hi)
{
   FILE *fd = fopen("result_seg_ledger_range.txt", "w");

   if ( !fd ) {
      return false;
   }

   fprintf(fd, "%f\n", lo);
   fprintf(fd, "%f\n", hi);

   fclose(fd);
   return true;
}

bool ca_load_ledger_height(float &lo, float &hi)
{
   FILE *fd = fopen("result_seg_ledger_range.txt", "r");

   if ( !fd ) {
      return false;
   }

   char str[1000];
   int count = 0;
   float value;
   while(fgets(str, 1000, fd) ) {
      assert(sscanf(str, "%f", &value) == 1 );
      if ( count == 0 ) {
         lo = value;
      } else {
         hi = value;
      }
      count ++;
   }
   assert(count == 2);
   
   fclose(fd);
   return true;
}

void ca_3D_model_compute_main_planes(vector<PLANE_3D *> &vec_face_plane)
{

   vector<vector<int> * > vec_segments;
   ca_load_variable_length_info("result_seg_body_regtypes_2.txt", vec_segments, true);

   if ( vec_segments.size() != 3 ) {
      return ;
   }

   // assume the 2nd one is the one
   char *prefix_dumping = "point_cloud_body_region";
   int   i_seg = 1;

   vector<int> all_lines;
   float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y, diff_z;
   {
      char tmp[1000], *tmp_value;
      sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
      ca_load_aux_for_each_unit(tmp);
      assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
      sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max);

      assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
      assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
   }

   diff_x = x_max - x_min;
   diff_y = y_max - y_min;
   
   x_min -= diff_x * .1;
   x_max += diff_x * .1;
   y_min -= diff_y * .1;
   y_max += diff_y * .1;
               
   
   {
      char *key_str, all_key_fn[1000];
      if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
         key_str = "key_slices.txt";
      sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);

      vector<int> *vec_keys = ca_load_simple_vector(all_key_fn);
      vector<vector<float> *> z_arr;
      char IR_z_fn[1000];
      sprintf(IR_z_fn, "%s_%d/IR_z_info.txt", prefix_dumping, i_seg);

      // 10.16.2010 - this is for paper writing of showing extrusion/keyslices
      // in case of taper structure, the IR_z_info.txt was not generated 
      {
         if ( !file_exist(IR_z_fn) ) {
            vector<int> vec_keyslices(*vec_keys);

            // fill up the points and height for the extruded keyslices
            {
               int pre_h = 0;
               vector<vector<float> *> z_arr;
               for ( int i = 0; i < vec_keyslices.size(); i ++ ) {
                        
                  vector<float> *vec_h = new vector<float> ();
                  vec_h->push_back(0); // 0: extruded 1: tapered
                  vec_h->push_back(pre_h);
                  vec_h->push_back(vec_keyslices[i]); // c: converge height; d. actual top height.
                  vec_h->push_back(vec_keyslices[i]);
                  z_arr.push_back(vec_h);
                  pre_h = vec_keyslices[i];
                        
               }
               ca_dump_IR_keyslices(IR_z_fn, z_arr);
            }
                  
         }
      }
            
      vector<vector<int> *> *vec_keys_final = ca_load_IR_keyslices(IR_z_fn, *vec_keys, z_arr);
      vector<int> *vec_pts = vec_keys_final->at(0);
      for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {
         int x = x_axis(vec_pts->at(i_pts));
         int y = y_axis(vec_pts->at(i_pts));
         all_lines.push_back(x);
         all_lines.push_back(y);
         if ( i_pts != 0 && i_pts != vec_pts->size() - 1 ) {
            all_lines.push_back(x);
            all_lines.push_back(y);
         }
      }
         
      printf("INFO (ca_3D_model_compute_main_planes()): total lines/planes are: %d.\n", all_lines.size() - 1);
   }
   
   {
      POINT_3D p1_3d, p2_3d, p3_3d;
      PLANE_3D *plane_3d;
      
      // temp setting
      diff_x = x_max - x_min;
      float z_height_lo = z_min;
      float z_height_hi = z_max;
      float scale = (double)image_width / diff_x;
      for (int i = 0; i < all_lines.size(); i +=4 )
      {
         int x = all_lines[i];
         int y = all_lines[i+1];
         float y_3D = y_min + (image_height - y - 1)/scale;
         float x_3D = x_min + diff_x/image_width * x;
         float z_3D = z_height_lo;
         p1_3d.x = x_3D;
         p1_3d.y = y_3D;
         p1_3d.z = z_3D;
         p2_3d.x = x_3D;
         p2_3d.y = y_3D;
         p2_3d.z = z_height_hi;
         
         x = all_lines[i+2];
         y = all_lines[i+3];
         y_3D = y_min + (image_height - y - 1)/scale;
         x_3D = x_min + diff_x/image_width * x;
         z_3D = z_height_lo;
         p3_3d.x = x_3D;
         p3_3d.y = y_3D;
         p3_3d.z = z_3D;

         // compute the plane
         plane_3d = compute_plane_from_3D_pts(p1_3d, p2_3d, p3_3d);
         if ( plane_3d )
            vec_face_plane.push_back(plane_3d);

      }
   }
   
}

PLANE_3D *ca_model_compute_right_plane_for_projection(vector<PLANE_3D *> &vec_face_plane, float *M)
{
   PLANE_3D *plane_3d = NULL;

   // assume ca_aux_bounding_box has been loaded.
   float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y, diff_z;
   {
      char *tmp_value;
      assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
      sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max);

      assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
      assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
   }

   diff_x = x_max - x_min;
   diff_y = y_max - y_min;
   
   x_min -= diff_x * .1;
   x_max += diff_x * .1;
   y_min -= diff_y * .1;
   y_max += diff_y * .1;
               
   
   // temp setting
   diff_x = x_max - x_min;
   float z_height_lo = z_min;
   float scale = (double)image_width / diff_x;

   {
      // compute the plane_3d based on the distance from the center of the image
      int x_c0 = image_width / 2;
      int y_c0 = image_height / 2;
      float y_3D = y_min + (image_height - y_c0 - 1)/scale;
      float x_3D = x_min + diff_x/image_width * x_c0;
      float z_3D = z_height_lo;
      // float *p_center = ca_compute_multi_vec_matrix(x_3D, y_3D, z_3D, M); // transfer back to legitimacy coord
      float *p_center = (float *) malloc( sizeof(float) * 3);
      p_center[0] = x_3D;
      p_center[1] = y_3D;
      p_center[2] = z_3D;

      float min_dis;
      for ( int i_plane = 0; i_plane < vec_face_plane.size(); i_plane ++ ) {
         float *p_base = ca_compute_project_point(p_center, vec_face_plane[i_plane]);
         float dis = sqrt((p_center[0]-p_base[0]) * (p_center[0]-p_base[0]) +
                          (p_center[1]-p_base[1]) * (p_center[1]-p_base[1]) +
                          (p_center[2]-p_base[2]) * (p_center[2]-p_base[2]));
         if ( i_plane == 0 || dis < min_dis ) {
            min_dis = dis;
            plane_3d = vec_face_plane[i_plane];
         }
      }
   }

   return plane_3d;
   
}

void ca_model_compute_merging_points(PLANE_3D *plane, vector<int> *vec_pts, map<int, float *> &map_,
                                     float diff_x, float x_min, float y_min, float z_height_lo)
{
   assert(vec_pts->size() > 2 );
      
   vector<float> vec_dist;
   vector<float *> vec_pt3D;
   bool multi_seg = false;
   for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

      if ( vec_pts->at(i_pts) == -1 ) { // a new segment starting here.
         multi_seg = true;
         continue;
      }
      
      int x = x_axis(vec_pts->at(i_pts));
      int y = y_axis(vec_pts->at(i_pts));
      
      float scale = (double)image_width / diff_x;
      
      // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
      // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
      float y_3D = y_min + (image_height - y - 1)/scale;
      float x_3D = x_min + diff_x/image_width * x;
      float z_3D = z_height_lo;

      float *p = (float *) malloc ( sizeof(float) * 3);
      p[0] = x_3D, p[1] = y_3D, p[2] = z_3D;
      
      float *p1 = ca_compute_project_point(p, plane);

      float dist = sqrt((p[0]-p1[0])*(p[0]-p1[0]) + (p[1]-p1[1])*(p[1]-p1[1]) + (p[2]-p1[2])*(p[2]-p1[2]) );
      vec_dist.push_back(dist);
      vec_pt3D.push_back(p1);
   }

   vector<float> vec_order(vec_dist);
   sort(vec_dist.begin(), vec_dist.end(), less<float> ());

   if ( !multi_seg )
      assert(vec_order.size() == vec_pts->size());

   for ( int i = 0; i < vec_order.size(); i ++ ) {
      if ( vec_order[i] <= vec_dist[1] ) {
         /*
         printf("THRES: %f, here is %f, point [%d, %d].\n",
                vec_dist[1], vec_order[i], x_axis(vec_pts->at(i)), y_axis(vec_pts->at(i)));
         */
         map_[i] = vec_pt3D[i];
      }
   }

   // assume only two points close to the plane
   if (map_.size() != 2 && map_.size() != 3) {
      printf("ERROR: the points is not equal to 2 or 3, but %d\n", map_.size());
      assert(0);
   }
   
}


void ca_generate_3D_model(int mode)
{
   char *value;
   char *result_fn, *result_fn_flag;
   char *prefix_dumping = NULL;

   if ( mode == 0 ) { // body
      result_fn             = "result_seg_body_regtypes_2.txt";
      result_fn_flag        = "result_segment_body_reg_types_2";
      prefix_dumping        = "point_cloud_body_region";
   }
   else if ( mode == 1 ) {
      result_fn             = "result_seg_roof_regtypes_2.txt";
      result_fn_flag        = "result_segment_roof_reg_types_2";
      prefix_dumping        = "point_cloud_roof_region";
   }
   else {
      result_fn             = "result_seg_ledger_regtypes_2.txt";
      result_fn_flag        = "result_segment_ledger_reg_types_2";
      prefix_dumping        = "point_cloud_ledger_region";
   }

   if (readRunTimeFlag("do_one_time_job", &value ) && strcmp(value, "0") == 0 ) {
      return;
   }

   char *reg_type_fn;
   if ( !readRunTimeFlag(result_fn_flag, &reg_type_fn) )
      reg_type_fn = result_fn;
   
   if ( !file_exist(reg_type_fn) )
      return;
   
   // some pre-processing for body
   vector<PLANE_3D *> vec_body_planes;
   if ( mode == 0 ) {
      ca_3D_model_compute_main_planes(vec_body_planes);
   }
   
   // now let's transform the data back to 3D coordinates
   // for bottom-up model, transform them into 3D coordinates directly.
   // for extrusion from other sides, transform them into 3D coordindates first, then, apply matrix transform.

   {
      FILE *type_fd = fopen(reg_type_fn, "r");
      assert(type_fd);

      vector<vector<int> * > vec_segments;
      ca_load_variable_length_info(reg_type_fn, vec_segments, true);
         
      for (int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
      {
         int type_slice = 200;
         
         vector<int> *vec_faces = vec_segments[i_seg];

         char folder_name[1000], cmd[1000], sub_folder[1000];
         
         float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
         {
            // 1. get the range of [x X], [y Y].
            // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
            // 3. dump the image in folder_name/slice_for_taper
            
#ifdef LINUX
            sprintf(sub_folder, "%s_%d/slice_for_taper", prefix_dumping, i_seg);
#else
            sprintf(sub_folder, "%s_%d\\slice_for_taper", prefix_dumping, i_seg);
#endif
            

            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               if ( !ca_load_aux_for_each_unit(tmp) ) {
                  char data_fn[1000];
                  sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
                  ca_load_aux_dump_data(data_fn, tmp); // this will update flags.
               }
               
               assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

               assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
            }
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;

            printf("IMAGE SIZE: w - %d, h - %d\n", image_width, image_height);

            // dump the data into image


            // let use 10% for imaging
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;
               
         }

         vector<int> *vec_keys = NULL;
         char *key_str, all_key_fn[1000];
         if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
            key_str = "key_slices.txt";
         sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);
         
         // if this is a taper unit, we should generate IR for this unit now.
         if ( vec_faces->at(0)  == 1 && !readRunTimeFlag("do_model_generation_extrusion_only", &value )) {

            printf("Segment %d is Taper.\n", i_seg);

            // if slice_for_taper is not existed, create it
            char taper_fn[1000];
            sprintf(taper_fn, "%s/image_slice_0000.png", sub_folder);
            if ( !file_exist(taper_fn) ) {
               char data_fn[1000];
               sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
               
               vector<double> data_pts;
               vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);

               sprintf(cmd, "mkdir %s", sub_folder);
               system(cmd);
               
               printf("Creating sub-folder %s\n", sub_folder);

               // project the data to be analyzed
               project_point_cloud_into_image(data_pts, sub_folder,
                                              1, type_slice,
                                              x_min, x_max, y_min, y_max, z_min, z_max);
               
            }
            
            vec_keys = ca_load_simple_vector(all_key_fn);
            vector<vector<float> *> z_arr;
            vector<vector<int> *> *vec_keys_final = ca_taper_refine_simple_structures(sub_folder, vec_keys, z_arr, type_slice, i_seg);

            // convert the IR to 3D coordinates.

            // dump the taper to IR_taper_all.txt for now (temporaritly)
            {
               FILE *fd = fopen("IR_taper_all.txt", "a");

               float diff_x = x_max - x_min;
               float diff_y = y_max - y_min;
               float diff_z = z_max - z_min;

               
               int k;
               array_t *end_points;
               
               type_slice --; // 5.24.10 fixed a bug, the range is [0, type_slice - 1]

               for (int i_poly = 0; i_poly < vec_keys_final->size(); i_poly ++ ) {

                  vector<float> *vec_cur_height = z_arr.at(i_poly);
                  vector<int>   *vec_pts = vec_keys_final->at(i_poly);

                  int type_ir = vec_cur_height->at(0) > 0.0 ? 1 : 0; // for all TTP and TTL
                  int type = (int) vec_cur_height->at(0) ;
                  float base_h = vec_cur_height->at(1);
                  float conv_h = vec_cur_height->at(2);
                  float actl_h = vec_cur_height->at(3);

                  // temp setting
                  float z_height_lo = z_min + (base_h/(float)type_slice)*diff_z;
                  float z_height_hi = z_min + (actl_h/(float)type_slice)*diff_z;
                  float z_height_conv = z_min + (conv_h/(float)type_slice)*diff_z;

                  fprintf(fd, "BEGIN POLYGON\nHEIGHT\n");
                  fprintf(fd, "%f %f\nTYPE\n%d\nPOINTS\n", z_height_lo, z_height_hi, type_ir );

                  int index_pt;
                  vector<int> *end_pts;
                  vector<float> vec_3D_pts;
                  if ( type == 2 ) // TTL, let's update the 4th point to make them co-plane
                  {
                     int num_pts = 0;
                     POINT_3D p_3d[4];
                     for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

                        int x = x_axis(vec_pts->at(i_pts));
                        int y = y_axis(vec_pts->at(i_pts));

                        float scale = (double)image_width / diff_x;

                        // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
                        // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
                        float y_3D = y_min + (image_height - y - 1)/scale;
                        float x_3D = x_min + diff_x/image_width * x;
                        float z_3D = z_height_lo;

                        num_pts ++;

                        if ( num_pts != 4 ) {

                           if ( num_pts < 4 ) {
                              p_3d[num_pts-1].x = x_3D;
                              p_3d[num_pts-1].y = y_3D;
                              p_3d[num_pts-1].z = z_3D;
                           }
                           
                        } else {
                           p_3d[3].x = x_3D;
                           p_3d[3].y = y_3D;
                           p_3d[3].z = z_3D;
                           float *p_new = ca_compute_projected_point(p_3d); // compute_dist_point_to_line
                           printf("WWW: [%f, %f, %f] ==> [%f, %f, %f]\n", x_3D, y_3D, z_3D, p_new[0], p_new[1], z_3D);
                           x_3D = p_new[0];
                           y_3D = p_new[1];
                        }

                        vec_3D_pts.push_back(x_3D);
                        vec_3D_pts.push_back(y_3D);
                        vec_3D_pts.push_back(z_3D);

                        if ( num_pts <= 4 ) // for extra points, they are used for converging computation.
                           fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);

                        if ( type != 0 )  // TTP or TTL
                           i_pts ++;
                     }
                     
                  } else {

                     for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

                        int x = x_axis(vec_pts->at(i_pts));
                        int y = y_axis(vec_pts->at(i_pts));

                        float scale = (double)image_width / diff_x;

                        // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
                        // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
                        float y_3D = y_min + (image_height - y - 1)/scale;
                        float x_3D = x_min + diff_x/image_width * x;
                        float z_3D = z_height_lo;

                        fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);

                        if ( type != 0 )  // TTP or TTL
                           i_pts ++;
                     }
                     
                  }

                  if ( type == 0 ) {
                     fprintf(fd, "EXTRUSION\nEND POLYGON\n");
                  } else {
                     fprintf(fd, "TAPER\n");

                     if ( type == 1 ) { // TTP
                        for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

                           int x = x_axis(vec_pts->at(i_pts));
                           int y = y_axis(vec_pts->at(i_pts));

                           int x_prime = x_axis(vec_pts->at(i_pts+1));
                           int y_prime = y_axis(vec_pts->at(i_pts+1));

                           float scale = (double)image_width / diff_x;
                     
                           // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
                           // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
                           float y_3D = y_min + (image_height - y - 1)/scale;
                           float x_3D = x_min + diff_x/image_width * x;
                           float z_3D = z_height_hi;

                           float y_3D_prime = y_min + (image_height - y_prime - 1)/scale;
                           float x_3D_prime = x_min + diff_x/image_width * x_prime;
                           float z_3D_prime = z_height_conv;

                           // This is to ensure the two points are in the same plane
                           if ( actl_h < conv_h ) {

                              float diff_hi_lo = z_height_hi - z_height_lo;
                              float diff_co_lo = z_height_conv - z_height_lo;
                              x_3D = x_3D - (diff_hi_lo/diff_co_lo * (x_3D - x_3D_prime));
                              y_3D = y_3D - (diff_hi_lo/diff_co_lo * (y_3D - y_3D_prime));
                           } else {
                              x_3D = x_3D_prime;
                              y_3D = y_3D_prime;
                              z_3D = z_3D_prime;
                           }

                        
                           fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);

                           if ( type != 0 )  // TTP or TTL
                              i_pts ++;
                        
                        }
                     }
                     else if ( type == 2 ) { // TTL  the first point and second point do not share the same.

                        if ( vec_pts->size() == 14 ) { // the TTL from predefined taper centers
                           int top_p0 = vec_pts->at(10);
                           int top_p1 = vec_pts->at(11);

                           assert(vec_3D_pts.size() / 3 == 7 );
                           // compute the right point to adjust top_p1;
                           POINT_3D p_3d[4];
                           for (int i = 0; i < 2 ; i ++ ) {
                              p_3d[i].x = vec_3D_pts[i*3 + 0];
                              p_3d[i].y = vec_3D_pts[i*3 + 1];
                              p_3d[i].z = vec_3D_pts[i*3 + 2];
                           }
                           for (int i = 2; i < 4 ; i ++ ) {
                              p_3d[i].x = vec_3D_pts[(i+3)*3 + 0];
                              p_3d[i].y = vec_3D_pts[(i+3)*3 + 1];
                              p_3d[i].z = vec_3D_pts[(i+3)*3 + 2];
                           }

                           float *p_new = ca_compute_projected_point(p_3d); // compute_dist_point_to_line
                           p_3d[0].x = vec_3D_pts[5*3 + 0];
                           p_3d[0].y = vec_3D_pts[5*3 + 1];
                           p_3d[0].z = vec_3D_pts[5*3 + 2];
                           p_3d[1].x = p_new[0];
                           p_3d[1].y = p_new[1];
                           p_3d[1].z = vec_3D_pts[5*3 + 2];
                           
                           printf("WWW[14]: [%f, %f, %f] ==> [%f, %f, %f]\n", vec_3D_pts[18], vec_3D_pts[19], vec_3D_pts[20], p_new[0], p_new[1], p_3d[1].z);
                           for ( int i = 0; i < 5; i ++ ) {
                              if ( i == 1 || i == 2 )
                                 fprintf(fd, "%f %f %f\n", p_3d[1].x, p_3d[1].y, z_height_conv);
                              else 
                                 fprintf(fd, "%f %f %f\n", p_3d[0].x, p_3d[0].y, z_height_conv);
                           }
                           
                           
                        } else { // the TTL from simple computed two mid-point centers.
                        
                           float mp0_x, mp0_y, mp1_x, mp1_y;
                           mp0_x = (vec_3D_pts[1*3+0] + vec_3D_pts[2*3+0]) / 2.0;
                           mp0_y = (vec_3D_pts[1*3+1] + vec_3D_pts[2*3+1]) / 2.0;
                           mp1_x = (vec_3D_pts[3*3+0] + vec_3D_pts[4*3+0]) / 2.0;
                           mp1_y = (vec_3D_pts[3*3+1] + vec_3D_pts[4*3+1]) / 2.0;

                           float z_3D = z_height_conv;
                           float x_3D, y_3D;
                           int num_pt = 0;
                           for ( int i = 0; i < vec_3D_pts.size(); i += 3 ) {
                              if ( num_pt == 0 || num_pt == 3 || num_pt == 4 ) {
                                 x_3D = mp1_x;
                                 y_3D = mp1_y;
                              } else {
                                 x_3D = mp0_x;
                                 y_3D = mp0_y;
                              }

                              num_pt ++;
                              fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);
                           }
                        }
                     }
                        
                     fprintf(fd, "END POLYGON\n");
                  }
                  
               }

               fclose(fd);
            }
            
         } // end of  vec_faces->at(0)  == 1
         else {

            bool ca_aux_extrusion_reverse = false;
            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
               
               assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);

               if (readRunTimeFlag("ca_aux_total_slices", &tmp_value)) {
                  type_slice = atoi(tmp_value);
               }
               
               if (readRunTimeFlag("ca_aux_extrusion_reverse", &tmp_value)) {
                  ca_aux_extrusion_reverse = true;
               }
            }
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;

            // let use 10% for imaging
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;

            int face_id = -1;
            sprintf(sub_folder, "%s_%d/slice_for_type", prefix_dumping, i_seg);

            // if ( vec_faces->size() > 1 && vec_faces->at(1) != 0 ) {
            if ( vec_faces->size() > 1  ) {
               face_id = vec_faces->at(1);
               sprintf(sub_folder, "%s_%d/slice_for_face%d", prefix_dumping, i_seg, face_id+1);
            }
            
            // dump the taper to IR_taper_all.txt for now (temporaritly)
            FILE *fd = fopen("IR_taper_all.txt", "a");

            vec_keys = ca_load_simple_vector(all_key_fn);
            vector<vector<float> *> z_arr;
            char IR_z_fn[1000];
            sprintf(IR_z_fn, "%s_%d/IR_z_info.txt", prefix_dumping, i_seg);

            // 10.5.2010 - this is for paper writing of showing extrusion/keyslices
            // in case of taper structure, the IR_z_info.txt was not generated 
            {
               if ( !file_exist(IR_z_fn) ) {
                  vector<int> vec_keyslices(*vec_keys);

                  // fill up the points and height for the extruded keyslices
                  {
                     int pre_h = 0;
                     vector<vector<float> *> z_arr;
                     for ( int i = 0; i < vec_keyslices.size(); i ++ ) {
                        
                        vector<float> *vec_h = new vector<float> ();
                        vec_h->push_back(0); // 0: extruded 1: tapered
                        vec_h->push_back(pre_h);
                        vec_h->push_back(vec_keyslices[i]); // c: converge height; d. actual top height.
                        vec_h->push_back(vec_keyslices[i]);
                        z_arr.push_back(vec_h);
                        pre_h = vec_keyslices[i];
                        
                     }
                     ca_dump_IR_keyslices(IR_z_fn, z_arr);
                  }
                  
               }
            }
            
            vector<vector<int> *> *vec_keys_final = ca_load_IR_keyslices(IR_z_fn, *vec_keys, z_arr);

            float diff_x = x_max - x_min;
            float diff_y = y_max - y_min;
            float diff_z = z_max - z_min;

            float M[9];
            if ( face_id != -1 ) {
               char trans_back_fn[1000];
               sprintf(trans_back_fn, "face%d/trans_back.txt", face_id + 1);
               printf(" We have to load transformation matrix from %s \n", trans_back_fn);
                  
               ca_load_trans_matrix(trans_back_fn, M);
            }
               
            int k;
            array_t *end_points;

            type_slice --; // 5.24.10 fixed a bug, the range is [0, type_slice - 1]

            PLANE_3D *plane_3d_project = NULL;
            
            for (int i_poly = 0; i_poly < vec_keys_final->size(); i_poly ++ ) {
               
               vector<float> *vec_cur_height = z_arr.at(i_poly);
               vector<int>   *vec_pts = vec_keys_final->at(i_poly);

               int type_ir = vec_cur_height->at(0) > 0.0 ? 1 : 0; // for all TTP and TTL
               int type = (int) vec_cur_height->at(0) ;
               float base_h = vec_cur_height->at(1);
               float conv_h = vec_cur_height->at(2);
               float actl_h = vec_cur_height->at(3);

               // temp setting
               float z_height_lo = z_min + (base_h/(float)type_slice)*diff_z;
               float z_height_hi = z_min + (actl_h/(float)type_slice)*diff_z;
               float z_height_conv = z_min + (conv_h/(float)type_slice)*diff_z;

               if ( mode == 0 ) {
                  float ledger_bot, ledger_top;
                  if ( face_id == -1 && ca_load_ledger_height(ledger_bot, ledger_top) ) {
                     if ( i_poly == vec_keys_final->size() - 1 && ledger_bot - z_height_hi < ledger_top - ledger_bot )  // close to ledger
                     {
                        z_height_hi = ledger_bot;
                        printf("\n\nINFO: Update %s_%d to Hi\n\n",prefix_dumping, i_seg);
                     }
                  }
               }
               else if ( mode == 1 ) {
                  float ledger_bot, ledger_top;
                  if ( face_id == -1 && ca_load_ledger_height(ledger_bot, ledger_top) ) {
                     if ( i_poly == 0 && z_height_lo - ledger_top < ledger_top - ledger_bot )  // close to ledger
                     {
                        z_height_lo = ledger_top;
                        printf("\n\nINFO: Update %s_%d to Lo\n\n",prefix_dumping, i_seg);
                     }
                  }
               }
               else if ( mode == 2 ) {
                  ca_dump_ledger_height(z_min, z_max);
               }

               // special treaty for special structure.
               /*
               if ( plane_3d_project && i_poly > 0 ) {
                  z_height_lo = z_min;
               }
               */

               float z_height_lo_trans = z_height_lo;
               float z_height_hi_trans = z_height_hi;
               {
                  if ( face_id != -1) {
                     float *new_p1 = ca_compute_multi_vec_matrix(0.0, 0.0, z_height_lo, M);
                     float *new_p2 = ca_compute_multi_vec_matrix(0.0, 0.0, z_height_hi, M);

                     for ( int i = 0; i < 3; i ++ ) {
                        if ( abs(z_height_lo - z_height_hi) == abs(new_p1[i] - new_p2[i])) {
                           z_height_lo_trans = new_p1[i];
                           z_height_hi_trans = new_p2[i];
                           break;
                        }
                     }
                     free(new_p1);
                     free(new_p2);
                  }
               }

               // let's exchange low and high for extrusion
               if ( ca_aux_extrusion_reverse ) {
                  float temp = z_height_lo_trans;
                  z_height_lo_trans = z_height_hi_trans;
                  z_height_hi_trans = temp;
               }
               
               fprintf(fd, "BEGIN POLYGON\nHEIGHT\n");
               fprintf(fd, "%f %f\nTYPE\n%d\nPOINTS\n", z_height_lo_trans, z_height_hi_trans, type_ir );

               int index_pt;
               vector<int> *end_pts;
               vector<float> vec_3D_pts;
               map<int, float *> map_idx2pt3D;
               int do_merge = 1;
               char *temp_value;
               if ( readRunTimeFlag( "do_model_merge", &temp_value ) && strcmp(temp_value, "0") == 0)
                  do_merge = 0;
               
               {
                  if ( do_merge && mode == 0 &&  i_seg != 1 ) {
                     if ( ! plane_3d_project )
                        plane_3d_project = ca_model_compute_right_plane_for_projection(vec_body_planes, M);

                     ca_model_compute_merging_points(plane_3d_project, vec_pts, map_idx2pt3D,
                                                     diff_x, x_min, y_min, z_height_lo);
                  }

                  for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

                     if ( vec_pts->at(i_pts) == -1 ) { // a new segment starting here.
                        fprintf(fd, "EXTRUSION\nEND POLYGON\n");
                        fprintf(fd, "BEGIN POLYGON\nHEIGHT\n");
                        fprintf(fd, "%f %f\nTYPE\n%d\nPOINTS\n", z_height_lo_trans, z_height_hi_trans, type_ir );
                        continue;
                     }
                     
                     int x = x_axis(vec_pts->at(i_pts));
                     int y = y_axis(vec_pts->at(i_pts));

                     float scale = (double)image_width / diff_x;

                     // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
                     // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
                     float y_3D = y_min + (image_height - y - 1)/scale;
                     float x_3D = x_min + diff_x/image_width * x;
                     float z_3D = z_height_lo;

                     if ( map_idx2pt3D.find(i_pts) != map_idx2pt3D.end() ) {
                        x_3D = map_idx2pt3D[i_pts][0];
                        y_3D = map_idx2pt3D[i_pts][1];
                        z_3D = map_idx2pt3D[i_pts][2];
                        printf("\n ===== %s is merged on body_%d, of keyslice %d, at point %d.\n", mode == 0 ? "body" : "roof",
                               i_seg, i_poly, i_pts);
                     }
                        
                     if ( face_id != -1 ) {

                        float *new_p = ca_compute_multi_vec_matrix(x_3D, y_3D, z_3D, M);

                        /*
                        if ( plane_3d_project ) {
                           float *new_p1 = ca_compute_project_point(new_p, plane_3d_project);
                           free(new_p);
                           new_p = new_p1;
                        }
                        */
                        
                        x_3D = new_p[0];
                        y_3D = new_p[1];
                        z_3D = new_p[2];
                        free(new_p);
                           
                     }
                        

                     fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);

                     if ( type != 0 )  // TTP or TTL
                        i_pts ++;
                  }
                     
               }

               fprintf(fd, "EXTRUSION\nEND POLYGON\n");
                  
            }

            fclose(fd);
 
         } // end of extrusion
      } // end of for i_seg
   }
}

void ca_generate_3D_model_body()
{
   printf("\n\nMODULE: ca_generate_3D_model_body() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_generate_3D_model(0); // 0: body 1: roof
}

void ca_generate_3D_model_roof()
{
   printf("\n\nMODULE: ca_generate_3D_model_roof() \n\n");

   ca_generate_3D_model(1);
}

void ca_generate_3D_model_ledger()
{
   printf("\n\nMODULE: ca_generate_3D_model_ledger() \n\n");

   if ( !ca_has_body() )
      return;
   
   ca_generate_3D_model(2);
}


/* Function: ca_compute_show_windows_lines()

   Show the TWO PARALLEL lines along the windows viewing bottom-up direction.
   
 */
void ca_compute_show_windows_lines()
{
   char *fn;
   char *value;
   char *prefix_dumping = NULL;

   int mode = -1;

  start_win_line:

   mode ++;
   if ( mode > 1 )
      return;
   
   if ( mode == 0 ) { // body
      fn = "result_seg_body_region_faces.txt";
      prefix_dumping = "point_cloud_body_region";
   }
   else {
      fn = "result_seg_roof_region_faces.txt";
      prefix_dumping = "point_cloud_roof_region";
   }
   
   if ( !file_exist(fn) ) {
      goto start_win_line;
   }

   vector<vector<int> * > vec_segments;
   ca_load_variable_length_info(fn, vec_segments);

   for ( int i_seg = 0; i_seg < vec_segments.size(); i_seg ++ )
   {

      /*
      if (i_seg != 1 )
         continue;
      */

      char win_fn[1000];
      sprintf(win_fn, "%s_%d/window_slices.txt", prefix_dumping, i_seg);
      if ( !file_exist(win_fn) )
         continue;

      int total_slices = 100;
      float project_ratio = 0.1;
      
      // loading settings
      char folder_name[1000];
      sprintf(folder_name, "%s_%d", prefix_dumping, i_seg);
      {
         char tmp[1000], *tmp_value;
         sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
         ca_load_aux_for_each_unit(tmp);
         if ( readRunTimeFlag("ca_aux_window_slices", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            total_slices = atoi(tmp_value);
         }
         if ( readRunTimeFlag("ca_aux_window_ratio", &tmp_value) && !strcmp(tmp_value, "") == 0) {
            project_ratio = atof(tmp_value);
         }
      }
      
      vector<vector<int> *> vec_win_info;
      ca_compute_window_load_info(win_fn, vec_win_info); 

      vector<float *> vec_pts_3D;
      for ( int i_ = 0; i_ < vec_win_info.size(); i_ ++ )
      {
         int  i_face  = vec_win_info[i_]->at(0);
         int  dir_id  = vec_win_info[i_]->at(1);
         int start = vec_win_info[i_]->at(2);
         int  end  = vec_win_info[i_]->at(3);
         
         float M[9];
         {
            char trans_back_fn[1000];
            sprintf(trans_back_fn, "face%d/trans_back.txt", i_face);
            printf(" We have to load transformation matrix from %s \n", trans_back_fn);

            ca_load_trans_matrix(trans_back_fn, M);
         }

         // starting drawing the lines
         {
            float x, y, z, X, Y, Z, x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
            {
               char tmp[1000], *tmp_value;
               sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
               ca_load_aux_for_each_unit(tmp);
               sprintf(tmp, "ca_aux_bounding_box_face%d", i_face);
               if ( !readRunTimeFlag(tmp, &tmp_value) ) {
                  // reload the data and store the information.

                  char data_fn[1000];
                  sprintf(data_fn, "%s_%d/%s_trans_%d.txt", prefix_dumping, i_seg, prefix_dumping, i_face - 1);

                  vector<double> data_pts;
                  vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
                  x_min = vec_bounding_box->at(0);
                  x_max = vec_bounding_box->at(1);
                  y_min = vec_bounding_box->at(2);
                  y_max = vec_bounding_box->at(3);
                  z_min = vec_bounding_box->at(4);
                  z_max = vec_bounding_box->at(5);

                  diff_x = x_max - x_min;
                  diff_y = y_max - y_min;
                  
                  int h, w, t;
                  const int LARGE = 1024;
                  float scale = diff_x /diff_y;
                  if ( scale > 1 )
                     scale = 1 / scale;
                  scale = scale * LARGE;
                  t = (int) (scale + .5);
                  t += ( 8 - (t % 8));
                  
                  if ( diff_x > diff_y ) {
                     w = LARGE;
                     h = t;
                  } else {
                     w = t;
                     h = LARGE;
                  }
                  
                  image_width = w;
                  image_height = h;

                  // update value
                  {
                     float *params = (float *) malloc (sizeof(float) * 6 );
                     params[0] = x_min; params[1] = x_max; params[2] = y_min; params[3] = y_max; params[4] = z_min; params[5] = z_max; 
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 6);
                     free(params);
                  }
                  
                  {
                     sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                     int *params = (int *) malloc (sizeof(int) * 2 );
                     params[0] = w; params[1] = h;
                     ca_update_aux_for_each_unit(folder_name, tmp, (void *)params, 2);
                     free(params);
                  }
               
               } else {
                  assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
                  sprintf(tmp, "ca_aux_image_size_face%d", i_face);
                  assert(readRunTimeFlag(tmp, &tmp_value) == 1);
                  assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               }

               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;
               diff_z = z_max - z_min;

               if ( dir_id == 1 ) { // max side
                  z_min = z_max - diff_z * project_ratio;
                  z_max = z_max;
               } else { // min side
                  z_min = z_min;
                  z_max = z_min + diff_z * project_ratio;
               }

               sprintf(tmp, "ca_aux_image_size_face%d", i_face);
               assert(readRunTimeFlag(tmp, &tmp_value) == 1);
               assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
               
            }

            // temp setting
            float z_height_lo = z_min + start/(float)total_slices * (z_max - z_min);
            float z_height_hi = z_min + end/(float)total_slices * (z_max - z_min);
            float scale = (double)image_width / diff_x;

            {
               int x_s = -image_width;
               int x_e = image_width*2;

               float x_3D_1 = x_min + diff_x/image_width * x_s;
               float x_3D_2 = x_min + diff_x/image_width * x_e;
               float y_3D = y_min + (image_height - 0 - 1)/scale;
               float z_3D_1 = z_height_lo;
               float z_3D_2 = z_height_hi;

               float *p1 = ca_compute_multi_vec_matrix(x_3D_1, y_3D, z_3D_1, M);
               float *p2 = ca_compute_multi_vec_matrix(x_3D_2, y_3D, z_3D_1, M);
               float *p3 = ca_compute_multi_vec_matrix(x_3D_1, y_3D, z_3D_2, M);
               float *p4 = ca_compute_multi_vec_matrix(x_3D_2, y_3D, z_3D_2, M);
               
               vec_pts_3D.push_back(p1);
               vec_pts_3D.push_back(p2);
               vec_pts_3D.push_back(p3);
               vec_pts_3D.push_back(p4);
            }
         }
      } // end for each face

      // draw the lines.
      int h, w;
      char im_fn[1000], result_fn[1000];
      sprintf(im_fn, "%s_%d/bpa_windows/image_slice_window.png", prefix_dumping, i_seg);
      sprintf(result_fn, "%s_%d/bpa_windows/image_slice_window_HT.png", prefix_dumping, i_seg);
      BYTE **all_im = load_image_array(im_fn, h, w);

      {

         float x, y, z, X, Y, Z, x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
         {
            char tmp[1000], *tmp_value;
            sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
            ca_load_aux_for_each_unit(tmp);
            assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
            assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;
            x_min -= diff_x * .1;
            x_max += diff_x * .1;
            y_min -= diff_y * .1;
            y_max += diff_y * .1;
            diff_x = x_max - x_min;
            diff_y = y_max - y_min;

            assert(readRunTimeFlag("ca_aux_image_size", &tmp_value) == 1);
            assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
         }
         
         int w = image_width;
         int h = image_height;
      
         float scale = (float)image_width / diff_x;

         x = x_min; y = y_min;
         for (int i = 0; i < vec_pts_3D.size(); i += 2 ) {
            float *new_P1 = vec_pts_3D[i];
            float *new_P2 = vec_pts_3D[i+1];
         
            int im_y1 = image_height - (int)((new_P1[1] - y) * scale + .5) - 1;
            int im_x1 = (int)(((new_P1[0] - x)/diff_x)*image_width  + .5); // x
            int im_y2 = image_height - (int)((new_P2[1] - y) * scale + .5) - 1;
            int im_x2 = (int)(((new_P2[0] - x)/diff_x)*image_width  + .5); // x
         
            draw_line_on_2D_image(all_im, h, w, im_x1, im_y1, im_x2, im_y2);

            free(new_P1);
            free(new_P2);
         }

         Save2File(result_fn, all_im, NULL, w, h, 0, NULL);
         free_image(all_im);

      }
   }
}

/*
  FUNCTION: ca_generate_3D_model_body

  Generated the naked model for body part
  
*/

#if 0
// to be removed
void ca_generate_3D_model_body()
{

   char *value;

   int is_onetimeJobEnabled = 1;
   if ( readRunTimeFlag("do_one_time_job", &value ) ) {
      is_onetimeJobEnabled = atoi(value);
      
      if ( is_onetimeJobEnabled == 0 )
         return;
   }
   
   printf("\n\nMODULE: ca_generate_3D_model_body() \n\n");

   char *prefix_dumping = NULL;
   if ( !readRunTimeFlag("result_segment_body_prefix", &prefix_dumping) ) {
      prefix_dumping = "point_cloud_body_region";
   }

   char folder_name[1000], cmd[1000], sub_folder[1000];

   // now let's transform the data back to 3D coordinates
   // for bottom-up model, transform them into 3D coordinates directly.
   // for extrusion from other sides, transform them into 3D coordindates first, then, apply matrix transform.
   if ( !readRunTimeFlag( "do_body_inference_model_generation", &value ) || strcmp(value, "1") == 0) {

      char *reg_type_fn;
      if ( !readRunTimeFlag("result_segment_body_reg_types_2", &reg_type_fn) )
         reg_type_fn = "result_seg_body_regtypes_2.txt";
      FILE *type_fd = fopen(reg_type_fn, "r");
      assert(type_fd);

      vector<vector<int> * > vec_segments;
      char str[1000];
      while (fgets(str, 1000, type_fd) ) {
         char *seg_name = strtok(str, " ");
         int seg_id;
         assert(sscanf(seg_name, "segment_%d", &seg_id) == 1);
         char *shape_type_str = strtok(NULL, " ");
         vector<int> * vec_faces = new vector<int> ();
         vec_segments.push_back(vec_faces);
         vec_faces->push_back(atoi(shape_type_str));
         
         char *face_id = strtok(NULL, " ");
         while ( face_id) {
            vec_faces->push_back(atoi(face_id));
            face_id = strtok(NULL, " ");
         }
      }


      // get the vector of the image and transform back to 3D coordinates
      int shape_type, face_id;
      const int type_slice = 200; 
      for ( int i_seg = 0; i_seg < vec_segments.size(); i_seg ++)
      {
         vector<int> *vec_faces = vec_segments[i_seg];

         char *prefix_dumping = NULL;
         char folder_name[1000], cmd[1000], sub_folder[1000];
         if ( !readRunTimeFlag("result_segment_body_prefix", &prefix_dumping) ) {
            prefix_dumping = "point_cloud_region";
         }

         { // if this is an extruded unit, we should generate IR for this unit now.

            printf("Segment %d is Extrusion.\n", i_seg);

            // stop here

            int face_id = -1;
            int is_quadrangle = 1;;
            sprintf(sub_folder, "%s_%d/slice_for_type", prefix_dumping, i_seg);

            // if ( vec_faces->size() > 1 && vec_faces->at(1) != 0 ) {
            if ( vec_faces->size() > 1  ) {
               face_id = vec_faces->at(1);
               sprintf(sub_folder, "%s_%d/slice_for_face%d", prefix_dumping, i_seg, face_id+1);
               is_quadrangle = 0;
            }

            float x_min, x_max, y_min, y_max, z_min, z_max, diff_x, diff_y;
            vector<double> data_pts;

            {
               // 1. get the range of [x X], [y Y].
               // 2. set the big one as 1024, the smaller one: 1024 * s -> 2^x
               // 3. dump the image in folder_name/slice_for_taper
            
               char data_fn[1000];
               if ( face_id == -1 ) 
                  sprintf(data_fn, "%s_%d.txt", prefix_dumping, i_seg);
               else
                  sprintf(data_fn, "%s/../%s_trans_%d.txt", sub_folder, prefix_dumping, face_id);
               
               {
                  char tmp[1000], *tmp_value;
                  sprintf(tmp, "%s_%d", prefix_dumping, i_seg);
                  ca_load_aux_for_each_unit(tmp);
                  assert(readRunTimeFlag("ca_aux_bounding_box", &tmp_value) == 1);
                  sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max);
               }
               diff_x = x_max - x_min;
               diff_y = y_max - y_min;

               int h, w, t;
               const int LARGE = 1024;
               float scale = diff_x /diff_y;
               if ( scale > 1 )
                  scale = 1 / scale;
               scale = scale * LARGE;
               t = (int) (scale + .5);
               t += ( 8 - (t % 8));
      
               if ( diff_x > diff_y ) {
                  w = LARGE;
                  h = t;
               } else {
                  w = t;
                  h = LARGE;
               }
               printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
               image_width = w;
               image_height = h;

               // dump the data into image


               // let use 10% for imaging
               x_min -= diff_x * .1;
               x_max += diff_x * .1;
               y_min -= diff_y * .1;
               y_max += diff_y * .1;
               
            }
            
            int slices = type_slice;
            vector<vector<float> *> z_arr;
            char *key_str, all_key_fn[1000];
            if ( !readRunTimeFlag("result_key_slice_index", &key_str) )
               key_str = "key_slices.txt";
            sprintf(all_key_fn, "%s_%d/%s", prefix_dumping, i_seg, key_str);
            vector<int> vec_extrude_layers(*ca_load_simple_vector(all_key_fn));
            
            // push extruded contour
            vector<vector<int> *> *vec_keys_final = ca_taper_compute_contour_for_segments(sub_folder, prefix_dumping, vec_extrude_layers, slices, i_seg, z_arr, face_id, is_quadrangle);


            // dump the taper to IR_taper_all.txt for now (temporaritly)
            {
               char *ir_fn;
               if ( !readRunTimeFlag("result_IR_file_name", &ir_fn) )
                  ir_fn = "IR_all.txt";
               FILE *fd = fopen(ir_fn, "a");

               float diff_x = x_max - x_min;
               float diff_y = y_max - y_min;
               float diff_z = z_max - z_min;

               float M[9];
               if ( face_id != -1 ) {
                  char trans_back_fn[1000];
                  sprintf(trans_back_fn, "face%d/trans_back.txt", face_id + 1);
                  printf(" We have to load transformation matrix from %s \n", trans_back_fn);
                  
                  ca_load_trans_matrix(trans_back_fn, M);
               }
               
               int k;
               array_t *end_points;
               for (int i_poly = 0; i_poly < vec_keys_final->size(); i_poly ++ ) {

                  vector<float> *vec_cur_height = z_arr.at(i_poly);
                  vector<int>   *vec_pts = vec_keys_final->at(i_poly);

                  int type_ir = vec_cur_height->at(0) > 0.0 ? 1 : 0; // for all TTP and TTL
                  int type = (int) vec_cur_height->at(0) ;
                  float base_h = vec_cur_height->at(1);
                  float conv_h = vec_cur_height->at(2);
                  float actl_h = vec_cur_height->at(3);

                  // temp setting
                  float z_height_lo = z_min + (base_h/(float)type_slice)*diff_z;
                  float z_height_hi = z_min + (actl_h/(float)type_slice)*diff_z;
                  float z_height_conv = z_min + (conv_h/(float)type_slice)*diff_z;

                  fprintf(fd, "BEGIN POLYGON\nHEIGHT\n");
                  fprintf(fd, "%f %f\nTYPE\n%d\nPOINTS\n", z_height_lo, z_height_hi, type_ir );

                  int index_pt;
                  vector<int> *end_pts;
                  vector<float> vec_3D_pts;
                  {

                     for (int i_pts = 0; i_pts < vec_pts->size(); i_pts ++ ) {

                        int x = x_axis(vec_pts->at(i_pts));
                        int y = y_axis(vec_pts->at(i_pts));

                        float scale = (double)image_width / diff_x;

                        // z_i = image_height - (int)((slice_data[1] - BOX_MIN_Y) * scale + .5) - 1;
                        // x_i = (int)(((slice_data[2] - BOX_MIN_X)/diff_x)*image_width  + .5); // x
                        float y_3D = y_min + (image_height - y - 1)/scale;
                        float x_3D = x_min + diff_x/image_width * x;
                        float z_3D = z_height_lo;
                        
                        if ( face_id != -1 ) {
                           
                           float *new_p = ca_compute_multi_vec_matrix(x_3D, y_3D, z_3D, M);
                           x_3D = new_p[0];
                           y_3D = new_p[1];
                           z_3D = new_p[2];
                           free(new_p);
                           
                        }
                        

                        fprintf(fd, "%f %f %f\n", x_3D, y_3D, z_3D);

                        if ( type != 0 )  // TTP or TTL
                           i_pts ++;
                     }
                     
                  }

                  {
                     fprintf(fd, "EXTRUSION\nEND POLYGON\n");
                  }
                  
               }

               fclose(fd);
            }
         }
      }
   }
}
#endif

/*
  Preprocess the point-cloud input:

  *. create subfolder of [bottom_up], [face1], [face2], ...
  *. project the data into slices.
  *. update the ca_aux in each of the above folder.
  
 */

void ca_preprocess_original_data(char *data_fn)
{
   char *value;
   char bu_folder[1000], face_folder[1000], cmd[1000];
   strcpy(bu_folder, "bottom_up");

   // if buttom_up/ca_aux.txt && face1/ca_aux.txt have been created, let's return;
   char str_check_pt[1000];
   sprintf(str_check_pt, "%s/slices/image_slice_0000.png", bu_folder);
   /*
   if ( file_exist(str_check_pt) && file_exist("face1/slices/image_slice_0000.png") ) {
      return;
   }
   */

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;

   assert(readRunTimeFlag("maximum_slices", &value));
   int max_slices = atoi(value);

   int total_slice_bottom_up;
   char tmp[1000], *tmp_value;

   if ( !file_exist(str_check_pt) ) {
      
      // load buttom_up data and generate slices.
      if ( !file_exist(bu_folder) ) {
         printf("Creating folder bottom_up....\n");
         sprintf(cmd, "mkdir %s", bu_folder);
         system(cmd);
      }

      // generate slices
      float x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;
      strcpy(tmp, "bottom_up");
      ca_load_aux_for_each_unit(tmp);
      strcpy(tmp, "box_bottom_up");
      vector<double> data_pts;
      vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(data_fn, data_pts);
      if ( !readRunTimeFlag(tmp, &tmp_value) ) {
         // reload the data and store the information.

         x_min = vec_bounding_box->at(0);
         x_max = vec_bounding_box->at(1);
         y_min = vec_bounding_box->at(2);
         y_max = vec_bounding_box->at(3);
         z_min = vec_bounding_box->at(4);
         z_max = vec_bounding_box->at(5);
         diff_x = x_max - x_min;
         diff_y = y_max - y_min;
         diff_z = z_max - z_min;

         int h, w, t;
         const int LARGE = 1024;
         float scale = diff_x /diff_y;
         if ( scale > 1 )
            scale = 1 / scale;
         scale = scale * LARGE;
         t = (int) (scale + .5);
         t += ( 8 - (t % 8));
      
         if ( diff_x > diff_y ) {
            w = LARGE;
            h = t;
         } else {
            w = t;
            h = LARGE;
         }
         printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
         image_width = w;
         image_height = h;

         float max_diff = max(diff_x, diff_y);
         max_diff = max(diff_z, max_diff);
         t = diff_z/max_diff * max_slices;
         t -= t % 4;
         total_slice_bottom_up = t;

      
         // dump the data into image
         // let use 10% for imaging
         float img_ratio = 0.3;
         if ( readRunTimeFlag("project_image_ratio", &value ) ) {
            img_ratio = atof(value);
         }
      
         x_min -= diff_x * img_ratio;
         x_max += diff_x * img_ratio;
         y_min -= diff_y * img_ratio;
         y_max += diff_y * img_ratio;

      } else {
         assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         assert(readRunTimeFlag("slices_bottom_up_dimension", &tmp_value) == 1);
         assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
         assert(readRunTimeFlag("total_slices", &tmp_value) == 1);
         total_slice_bottom_up = atoi(tmp_value);
      }

      {
         char sub_folder[1000];
      
#ifdef LINUX
         sprintf(sub_folder, "%s/slices", bu_folder);
#else      
         sprintf(sub_folder, "%s\\slices", bu_folder);
#endif
         if ( !file_exist(sub_folder) ) {
            printf("Creating folder %s ... \n", sub_folder);
            sprintf(cmd, "mkdir %s", sub_folder);
            system(cmd);
         }
      
         project_point_cloud_into_image(data_pts, sub_folder,
                                        1, total_slice_bottom_up,
                                        x_min, x_max, y_min, y_max, z_min, z_max);
      

         // Note: here we used updated bounding box, so we don't need to load the data and times .1 again.
         {
            char str_value[2048];
            sprintf(str_value, "%f_%f_%f_%f_%f_%f", x_min, x_max, y_min, y_max, z_min, z_max);
            ca_write_aux_for_each_unit(bu_folder, "box_bottom_up", str_value);

            sprintf(str_value, "%dx%d", image_width, image_height);
            ca_write_aux_for_each_unit(bu_folder, "slices_bottom_up_dimension", str_value);
         
            sprintf(str_value, "%d", total_slice_bottom_up);
            ca_write_aux_for_each_unit(bu_folder, "total_slices", str_value);
         
         }
         
      }

   }

   // dump face images
   
   for (int i_face = 1; i_face < total_faces; i_face ++ )
   {

      sprintf(face_folder, "face%d", i_face);
      sprintf(str_check_pt, "%s/slices/image_slice_0000.png", face_folder);
      if ( file_exist(str_check_pt) )
         continue;
      
      if ( !file_exist(face_folder) ) {
         printf("Creating folder %s ... \n", face_folder);
         sprintf(cmd, "mkdir %s", face_folder);
         system(cmd);
      }

      // compute the transformation matrix
      char tmp[1000];
      sprintf(tmp, "normal_face%d", i_face);
      assert(readRunTimeFlag(tmp, &value));
      float n_x, n_y, n_z;
      assert(sscanf(value, "%f_%f_%f", &n_x, &n_y, &n_z) == 3);

      POINT_3D r1 = {0.0, 0.0, 1.0};
      POINT_3D r2, r3;
      r2.x = n_x;
      r2.y = n_y;
      r2.z = n_z;
      
      cross_product(r1, r2, r3);

      float **M = matrix_malloc(3);
      M[0][0] = r3.x; M[0][1] = r3.y; M[0][2] = r3.z;
      M[1][0] = r1.x; M[1][1] = r1.y; M[1][2] = r1.z;
      M[2][0] = r2.x; M[2][1] = r2.y; M[2][2] = r2.z;

      float **MM = compute_inverse_matrix(M, 3);

      // write down this matrix
      sprintf(tmp, "%s/trans.txt", face_folder);
      ca_dump_trans_matrix(tmp, MM);

      sprintf(tmp, "%s/trans_back.txt", face_folder);
      ca_dump_trans_matrix(tmp, M);

      // transform the original point cloud
      sprintf(tmp, "%s/%s_trans.txt", face_folder, face_folder);
      gbl_opts->input_prefix = data_fn;
      gbl_opts->output_prefix = tmp;

      char trans_matrix[1000];
      sprintf(trans_matrix, "%s/trans.txt", face_folder);

      printf("compute transformation for %s to %s\n", data_fn, tmp);
      if ( !file_exist(gbl_opts->output_prefix) )
         compute_trans(trans_matrix);

      // project the data now
      char *face_data_fn = strdup(tmp);
      float x_min, y_min, z_min, x_max, y_max, z_max, diff_x, diff_y, diff_z;

      sprintf(tmp, "face%d", i_face);
      ca_load_aux_for_each_unit(tmp);
      sprintf(tmp, "box_face%d", i_face);
      vector<double> data_pts;
      vector<double> *vec_bounding_box = load_point_cloud_for_bounding_box(face_data_fn, data_pts);
      if ( !readRunTimeFlag(tmp, &tmp_value) ) {
         // reload the data and store the information.
      
         x_min = vec_bounding_box->at(0);
         x_max = vec_bounding_box->at(1);
         y_min = vec_bounding_box->at(2);
         y_max = vec_bounding_box->at(3);
         z_min = vec_bounding_box->at(4);
         z_max = vec_bounding_box->at(5);
         diff_x = x_max - x_min;
         diff_y = y_max - y_min;
         diff_z = z_max - z_min;

         int h, w, t;
         const int LARGE = 1024;
         float scale = diff_x /diff_y;
         if ( scale > 1 )
            scale = 1 / scale;
         scale = scale * LARGE;
         t = (int) (scale + .5);
         t += ( 8 - (t % 8));
      
         if ( diff_x > diff_y ) {
            w = LARGE;
            h = t;
         } else {
            w = t;
            h = LARGE;
         }
         printf("IMAGE SIZE: w - %d, h - %d\n", w, h);
         image_width = w;
         image_height = h;

         float max_diff = max(diff_x, diff_y);
         max_diff = max(diff_z, max_diff);
         t = diff_z/max_diff * max_slices;
         t -= t % 4;
         total_slice_bottom_up = t;

      
         // dump the data into image
         // let use 10% for imaging
         float img_ratio = 0.1;
         if ( readRunTimeFlag("project_image_ratio", &value ) ) {
            img_ratio = atof(value);
         }
      
         x_min -= diff_x * img_ratio;
         x_max += diff_x * img_ratio;
         y_min -= diff_y * img_ratio;
         y_max += diff_y * img_ratio;

      }
      else {
         assert(sscanf(tmp_value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         assert(readRunTimeFlag("slices_face_dimension", &tmp_value) == 1);
         assert(sscanf(tmp_value, "%dx%d", &image_width, &image_height) == 2);
         assert(readRunTimeFlag("face_total_slices", &tmp_value) == 1);
         total_slice_bottom_up = atoi(tmp_value);
      }

      char sub_folder[1000];
      
#ifdef LINUX
      sprintf(sub_folder, "%s/slices", face_folder);
#else      
      sprintf(sub_folder, "%s\\slices", face_folder);
#endif
      if ( !file_exist(sub_folder) ) {
         printf("Creating folder %s ... \n", sub_folder);
         sprintf(cmd, "mkdir %s", sub_folder);
         system(cmd);
      }
      
      project_point_cloud_into_image(data_pts, sub_folder,
                                     1, total_slice_bottom_up,
                                     x_min, x_max, y_min, y_max, z_min, z_max);
      

      // Note: here we used updated bounding box, so we don't need to load the data and times .1 again.
      {
         char str_value[2048], str_key[1000];;
         sprintf(str_value, "%f_%f_%f_%f_%f_%f", x_min, x_max, y_min, y_max, z_min, z_max);

         sprintf(str_key, "box_face%d", i_face);
         ca_write_aux_for_each_unit(face_folder, str_key, str_value);

         sprintf(str_value, "%dx%d", image_width, image_height);
         ca_write_aux_for_each_unit(face_folder, "slices_face_dimension", str_value);
         
         sprintf(str_value, "%d", total_slice_bottom_up);
         ca_write_aux_for_each_unit(face_folder, "face_total_slices", str_value);
         
      }

   }
}

// Function: ca_paper_generate_iv_for_showing_segmentation_planes
//
// Command: Project.exe -z config.ini
// This is to highlight slab of segmented data
// Algorithm:
//   *. just do whatever the segmentation to PCD does.

//   *. for vertical: check result_seg_body_roof.txt
//   *. for facades : check result_seg_roof_units.txt
//   *. for each 3D point cloud, transform it to each facade, and identify the index.
//   *. obtain the global index for the above index.
//
void ca_paper_generate_iv_for_showing_segmentation_planes()
{
   char *value;
   
   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fid = fopen(value, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", value);
      return;
   }

   char str_line[1000];
   char new_file[1000];

   strcpy(new_file, "segments_planes.iv");
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      // this is transfomration parameter, after it, zoom in 4 times?
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 1 0  1.3707\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 0 1  0.2200\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  1 0 0  0.0400\n");
      fprintf(fd_new, "}\n");
      // this is for transformation
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
   }

   // let's count how many segments we have to highlight the data:
   int total_segments = 0;

   // do this later 
   /*
   if ( !readRunTimeFlag("result_segment_body_roof", &value) )
      value = "result_seg_body_roof.txt";
   vector<int> *vec_ledger = ca_load_simple_vector(value);
   if ( vec_ledger->size() > 0 && vec_ledger->at(0) !=  0) {
      total_segments ++;
      printf("There is 1 segment in vertical direction. \n");
   }
   */

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   vector<vector<int> > result_faces(total_faces - 1);

   char *output_fn;
   if ( !readRunTimeFlag("result_segment_roof_only", &output_fn) )
      output_fn = "result_seg_roof_units.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_str[1000];
   int face, im_index, x1, x2, x_w;

   // assume 2 faces, then for 2 x 3 faces, there are 3 x 4 = 12 segments
   int num_seg = 1;
   int total_seg = 1;
   int pre_face = -1;
   while (fgets(index_str, 1000, output_fd ) ) {
      if (sscanf(index_str, "%d %d %d %d %d", &face, &im_index, &x1, &x2, &x_w ) == 5) {
         result_faces[face-1].push_back(im_index);
         result_faces[face-1].push_back(x1);
         result_faces[face-1].push_back(x2);
         result_faces[face-1].push_back(x_w);

         if ( face != pre_face ) {
            if ( pre_face != -1 ) {
               total_seg *= num_seg;
               num_seg = 1;
            }
            pre_face = face;
         }
         
         num_seg ++;
         
      }
   }
   fclose(output_fd);
   total_seg *= num_seg;
   total_segments = total_seg;
   printf("There are total %d segments \n", total_segments);

   // transform each data point now.
   // INVARIANT: for each vector<int> *, the first index of (x, y, z) in data is stored.
   vector<vector<int> *> vec_seg_arr ( total_segments );
   for ( int i = 0; i < total_segments ; i ++ )
      vec_seg_arr[i] = new vector<int> ();
   
   
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   vector<double> data;
   printf("loading data from file...\n");
   int num = 0;
   int down_sampling = 100;
   if ( readRunTimeFlag("do_paper_down_sampling", &value) ) {
      down_sampling = atoi ( value );
   }
   
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         num ++; 
         if ( num % down_sampling != 0 )
            continue;
         
         data.push_back(x);
         data.push_back(y);
         data.push_back(z);
      }
   }
   fclose(fid);

   { // merge start here

      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb 0.31403902 0.99084514 0.79899842\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    DrawStyle {\n");
      fprintf(fd_new, "      style POINTS\n");
      fprintf(fd_new, "      pointSize 1\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");

      int total = 0;
      for (int i = 0; i < data.size() ; i += 3 )
      {
         x = data[i];
         y = data[i+1];
         z = data[i+2];
         if ( i == 0 ) {
            fprintf(fd_new, "      point [ %f %f %f", x, y, z);
            total ++;
         }
         else
         {
            fprintf(fd_new, ",\n          %f %f %f", x, y, z);
            total ++;
         }
         
      }

      fprintf(fd_new," ]\n\n    }\n    PointSet {\n      numPoints %d\n", total);
      //fputs("\n    }\n  }\n}\n", fd_new);
      fprintf(fd_new, "\n    }\n  }\n");

   } // merge end here

   
   
   float x_min, x_max, y_min, y_max, z_min, z_max;

   // computing for each point in data, the index to which its segment belongs
   for (int i = 0; 0 && i < data.size() ; i += 3 )
   {
      x = data[i];
      y = data[i+1];
      z = data[i+2];
      int seg_id = 0;
      int total_segs = 1;

      for ( int i_face = 0; i_face < total_faces - 1; i_face ++ )
      {
         int seg_face_index = 1;

         // compute the transformation point for face i_face.
         char fn_trans[1000];
         sprintf(fn_trans, "face%d/trans.txt", i_face + 1 );
         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_p = ca_compute_multi_vec_matrix(x, y, z, M);

         // compute the slice index for this point on slices folder.
         int slice_index;
         int total_slices;

         sprintf(fn_trans, "face%d", i_face + 1 );
         ca_load_aux_top_level(fn_trans);
         
         assert(readRunTimeFlag("face_total_slices", &value) );
         total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", i_face + 1);
         assert(readRunTimeFlag(fn_trans, &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         slice_index = (int) ((new_p[2] - z_min)/(z_max - z_min) * total_slices);
         assert ( slice_index <= total_slices && slice_index >= 0 );

         // compute the segmentation index of the slice_index.
         vector<int> arr_cur_face = result_faces[i_face];
         for ( int k = 0; k < arr_cur_face.size(); k += 4 ) {
            if ( slice_index >= arr_cur_face[k] )
               seg_face_index ++;
            else
               break;
         }

         // eq: x*A + y*B + z ; where A = total(y) * total(z) , B = total(z)
         seg_id += (seg_face_index - 1) * total_segs ;

         assert ( arr_cur_face.size() % 4 == 0 );
         total_segs *= (arr_cur_face.size() / 4 + 1);

         free (new_p);
      }

      // insert this index to the array of segmentation bin.
      if ( seg_id <= total_segments )
         vec_seg_arr[seg_id - 1]->push_back(i);
      else {
         printf("WARNING: seg_id is %d, which is bigger than total_segments: %d", seg_id, total_segments);
      }
   }

   vector<double> slice_data;
   for (int i = 0; 0 && i < total_segments; i ++)
   {
      printf("\nLoad: Processing segement #%d, ", i);
      // find out the appropriate points
      // CHANGE: BOX_MIN_Y   

      vector<int> *vec_data_index = vec_seg_arr[i];
      if ( vec_data_index->size() == 0 )
         continue;
      
      for (int index = 0; index < vec_data_index->size(); index ++)
      {
         {
            int index_ = vec_data_index->at(index);
            slice_data.push_back(data[index_]);        // x axis
            slice_data.push_back(data[index_+1]);      // y axis
            slice_data.push_back(data[index_+2]);      // z axis
         }
      }
      
      generate_iv_for_slab_set_points(fd_new, slice_data);
      slice_data.clear();
   }

   // generate the planar

   if ( 1 )
   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "    LightModel {\n");
      fprintf(fd_new, "      model PHONG\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Material {\n");
      fprintf(fd_new, "      ambientColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      diffuseColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      emissiveColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      specularColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      shininess     0.5\n");
      fprintf(fd_new, "      transparency  0.5\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n"); // 13, 31, 37, 41

      int num_planes = 0;
      for ( int i_face = 0; i_face < total_faces - 1; i_face ++ )
      {
         char fn_trans[1000];
         // compute the slice index for this point on slices folder.
         int slice_index;
         int total_slices;

         sprintf(fn_trans, "face%d", i_face + 1 );
         ca_load_aux_top_level(fn_trans);
         
         assert(readRunTimeFlag("face_total_slices", &value) );
         total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", i_face + 1);
         assert(readRunTimeFlag(fn_trans, &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

         // compute the transformation point for face i_face.
         sprintf(fn_trans, "face%d/trans_back.txt", i_face + 1 );
         float M[9];
         ca_load_trans_matrix(fn_trans, M);

         // compute the segmentation index of the slice_index.
         vector<int> arr_cur_face = result_faces[i_face];
         //for ( int i_plane = 4; i_plane < arr_cur_face.size() - 4; i_plane += 4 ) {
         for ( int i_plane = 0; i_plane < arr_cur_face.size(); i_plane += 4 ) {
            int cur_index = arr_cur_face[i_plane];
            float ratio = 0.15;
            float z_high = z_min + (cur_index + 1)/(float)(total_slices + 1) * (z_max - z_min);
            /*
            float x_min1 = x_min - (x_max - x_min) * ratio; 
            float x_max1 = x_max + (x_max - x_min) * ratio;
            float y_min1 = y_min - (y_max - y_min) * ratio; 
            float y_max1 = y_max + (y_max - y_min) * ratio;
            */
            // this is the hack for 2Spiker dataset.
            float x_min1 = x_min;
            float x_max1 = x_max;
            float y_min1 = y_min;
            float y_max1 = y_max;
            //float y_max1 = y_max - (y_max - y_min)/2;
            float *new_p;
            new_p = ca_compute_multi_vec_matrix(x_min1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_min1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);

            num_planes ++;
         }

      }
      
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");

      for ( int i = 0; i < num_planes; i ++ ) {
         fprintf(fd_new, "        %d, %d, %d, %d, -1,   \n", i*4+3, i*4+2, i*4+1, i*4);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "  }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);

   
}

void ca_paper_generate_iv_for_showing_segmentation_planes1()
{
   char *value;
   
   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fd = fopen(value, "r");
   if (!fd)
   {
      printf("Could not open the file %s\n", value);
      return;
   }

   char str_line[1000];
   char new_file[1000];

   strcpy(new_file, "segments_planes.iv");
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   int down_sampling = 100;
   if ( readRunTimeFlag("do_paper_down_sampling", &value) ) {
      down_sampling = atoi ( value );
   }

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    BaseColor {\n");
      fprintf(fd_new, "      rgb 0.31403902 0.99084514 0.79899842\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    DrawStyle {\n");
      fprintf(fd_new, "      style POINTS\n");
      fprintf(fd_new, "      pointSize 1\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
   }

   int line_num = 0;
   int total = 0;
   
   char temp_str[1024];
   {
      //   float a, b, c;
      char a[30], b[30], c[30];

      while (fgets(str_line, 1000, fd))
      {
         if (line_num == 10)
         {
            sscanf(str_line, "%s %s %s", a, b,c);
            sprintf(temp_str, "      point [ %s %s %s", a, b, c);
            fputs(temp_str, fd_new);
            total ++;
         }
         else if (line_num > 10) 
         {
            if ( line_num % down_sampling == 0 ) {
               sscanf(str_line, "%s %s %s", a, b,c);
               sprintf(temp_str, ",\n          %s %s %s", a, b, c);
               fputs(temp_str, fd_new);
               total ++;
            }
         }
         
         line_num ++;
      }

      fclose(fd);
   }
   
   sprintf(temp_str," ]\n\n    }\n    PointSet {\n      numPoints %d\n", total);
   fputs(temp_str, fd_new);
   //fputs("\n    }\n  }\n}\n", fd_new);
   fputs("\n    }\n  }\n", fd_new);

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   vector<vector<int> > result_faces(total_faces - 1);

   // generate the planar
   float x_min, x_max, y_min, y_max, z_min, z_max;
   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "    LightModel {\n");
      fprintf(fd_new, "      model PHONG\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Material {\n");
      fprintf(fd_new, "      ambientColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      diffuseColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      emissiveColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      specularColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      shininess     0.5\n");
      fprintf(fd_new, "      transparency  0.5\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n"); // 13, 31, 37, 41

      int num_planes = 0;
      for ( int i_face = 0; i_face < total_faces - 1; i_face ++ )
      {
         char fn_trans[1000];
         // compute the slice index for this point on slices folder.
         int slice_index;
         int total_slices;

         sprintf(fn_trans, "face%d", i_face + 1 );
         ca_load_aux_top_level(fn_trans);
         
         assert(readRunTimeFlag("face_total_slices", &value) );
         total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", i_face + 1);
         assert(readRunTimeFlag(fn_trans, &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

         // compute the transformation point for face i_face.
         sprintf(fn_trans, "face%d/trans_back.txt", i_face + 1 );
         float M[9];
         ca_load_trans_matrix(fn_trans, M);

         // compute the segmentation index of the slice_index.
         vector<int> arr_cur_face = result_faces[i_face];
         for ( int i_plane = 4; i_plane < arr_cur_face.size() - 4; i_plane += 4 ) {
            int cur_index = arr_cur_face[i_plane];
            float ratio = 0.15;
            float z_high = z_min + (cur_index + 1)/(float)(total_slices + 1) * (z_max - z_min);
            float x_min1 = x_min - (x_max - x_min) * ratio; 
            float x_max1 = x_max + (x_max - x_min) * ratio;
            float y_min1 = y_min - (y_max - y_min) * ratio; 
            float y_max1 = y_max + (y_max - y_min) * ratio;
            float *new_p;
            new_p = ca_compute_multi_vec_matrix(x_min1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_min1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);

            num_planes ++;
         }

      }
      
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");

      for ( int i = 0; i < num_planes; i ++ ) {
         fprintf(fd_new, "        %d, %d, %d, %d, -1,   \n", i*4+3, i*4+2, i*4+1, i*4);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "  }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   
   fclose(fd_new);

   /*

   // let's count how many segments we have to highlight the data:
   int total_segments = 0;

   // load roof ledger if any
   int ledger_index = ca_load_ledger_index(1);
   
   // load roof unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag("result_segment_roof_region", &region_fn) )
      region_fn = "result_seg_roof_regions.txt";
   
   vector<vector<int>* > vec_regions;
   ca_load_roof_seg_regions(region_fn, vec_regions);
   total_segments = vec_regions.size();

   st_table *st_pts_2_region_id = st_init_table(st_numcmp, st_numhash);

   for (int i = 0; i < vec_regions.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions[i]), all_pts);
      for (int j = 0; j < all_pts.size(); j ++)
         st_insert(st_pts_2_region_id, (char *)all_pts[j], (char *)i);
   }
   
   if ( !readRunTimeFlag("result_segment_body_region", &region_fn) )
      region_fn = "result_seg_body_regions.txt";
   
   vector<vector<int>* > vec_regions_body;
   ca_load_roof_seg_regions(region_fn, vec_regions_body);
   total_segments += vec_regions_body.size();

   st_table *st_pts_2_body_region_id = st_init_table(st_numcmp, st_numhash);

   for (int i = vec_regions.size(); i < vec_regions.size() + vec_regions_body.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions_body[i - vec_regions.size()]), all_pts);
      for (int j = 0; j < all_pts.size(); j ++)
         st_insert(st_pts_2_body_region_id, (char *)all_pts[j], (char *)i);
   }

   float ledger_height;
   float x, X, y, Y, z, Z;
   if (ledger_index != -1) {
      ca_load_aux_top_level("bottom_up");
      assert(readRunTimeFlag("box_bottom_up", &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      int total_slices = 1000;
      if (readRunTimeFlag("total_slices", &value) )
         total_slices = atoi(value);
      
      assert(readRunTimeFlag("slices_bottom_up_dimension", &value));
      assert(sscanf(value, "%dx%d", &image_width, &image_height) == 2);
      
      ledger_height = z + (Z - z)*((float)ledger_index/total_slices); // 3D coord of Z.
   }

   // transform each data point now.
   // INVARIANT: for each vector<int> *, the first index of (x, y, z) in data is stored.
   printf("total number of segments is %d.\n", total_segments);
   vector<vector<double> > vec_seg_arr ( total_segments );
   
   char x_s[30], y_s[30], z_s[30];
   double x_f, y_f, z_f;
   vector<double> data;
   float diff_x = X - x;
   float scale = image_width / diff_x;
   printf("loading data from file...\n");
   int num = 0;
   int down_sampling = 100;
   if ( readRunTimeFlag("do_paper_down_sampling", &value) ) {
      down_sampling = atoi ( value );
   }
   
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x_f = atof(x_s);
         y_f = atof(y_s);
         z_f = atof(z_s);

         num ++; 
         if ( num % down_sampling != 0 )
            continue;
         
         if ( z_f < ledger_height && vec_regions_body.size() == 1) {
            vec_seg_arr[total_segments - 1].push_back(x_f);
            vec_seg_arr[total_segments - 1].push_back(y_f);
            vec_seg_arr[total_segments - 1].push_back(z_f);
            continue;
         }

         int x_i = (int)(((x_f - x)/diff_x)*image_width  + .5); // x
         int y_i = image_height - (int)((y_f - y) * scale + .5) - 1; // y

         int *rid = 0;
         st_table *st_pts_2_all = z_f < ledger_height ? st_pts_2_body_region_id : st_pts_2_region_id;
         if ( valid_pixel(x_i, y_i) && (st_lookup(st_pts_2_all, (char *)index(x_i, y_i), (char **)&rid) || total_segments <= 2 )) {
            vec_seg_arr[(int)rid].push_back(x_f);
            vec_seg_arr[(int)rid].push_back(y_f);
            vec_seg_arr[(int)rid].push_back(z_f);
         }
         
      }
   }
   fclose(fid);

   vector<double> slice_data;
   for (int i = 0; i < total_segments; i ++)
   {
      printf("\nLoad: Processing segement #%d, ", i);

      slice_data = vec_seg_arr[i];
      if ( slice_data.size() == 0 )
         continue;
      
      generate_iv_for_slab_set_points(fd_new, slice_data);
      slice_data.clear();
   }

   fprintf(fd_new, "\n}\n");
   fclose(fd_new);

   */

   
}

// Function: ca_paper_generate_iv_for_showing_segmentation
//
// Command: Project.exe -z config.ini
// This is to highlight slab of segmented data
// Algorithm:
//   *. just do whatever the segmentation to PCD does.

//   *. for vertical: check result_seg_body_roof.txt
//   *. for facades : check result_seg_roof_units.txt
//   *. for each 3D point cloud, transform it to each facade, and identify the index.
//   *. obtain the global index for the above index.
//
#if 1

void ca_paper_generate_iv_for_showing_segmentation()
{
   char *value;
   
   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fid = fopen(value, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", value);
      return;
   }

   char str_line[1000];
   char new_file[1000];

   strcpy(new_file, "segments.iv");
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      // this is transfomration parameter, after it, zoom in 4 times?
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 1 0  1.3707\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 0 1  0.2200\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  1 0 0  0.0400\n");
      fprintf(fd_new, "}\n");
      // this is for transformation
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
   }


   // let's count how many segments we have to highlight the data:
   int total_segments = 0;

   // load roof ledger if any
   int ledger_index = ca_load_ledger_index(1);
   
   // load roof unit if any
   char *region_fn = NULL;
   if ( !readRunTimeFlag("result_segment_roof_region", &region_fn) )
      region_fn = "result_seg_roof_regions.txt";
   
   vector<vector<int>* > vec_regions;
   ca_load_roof_seg_regions(region_fn, vec_regions);
   total_segments = vec_regions.size();

   st_table *st_pts_2_region_id = st_init_table(st_numcmp, st_numhash);

   for (int i = 0; i < vec_regions.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions[i]), all_pts);
      for (int j = 0; j < all_pts.size(); j ++)
         st_insert(st_pts_2_region_id, (char *)all_pts[j], (char *)i);
   }
   
   if ( !readRunTimeFlag("result_segment_body_region", &region_fn) )
      region_fn = "result_seg_body_regions.txt";
   
   vector<vector<int>* > vec_regions_body;
   ca_load_roof_seg_regions(region_fn, vec_regions_body);
   total_segments += vec_regions_body.size();

   st_table *st_pts_2_body_region_id = st_init_table(st_numcmp, st_numhash);

   for (int i = vec_regions.size(); i < vec_regions.size() + vec_regions_body.size(); i ++) {
      vector<int> all_pts;
      fill_polygon(*(vec_regions_body[i - vec_regions.size()]), all_pts);
      for (int j = 0; j < all_pts.size(); j ++)
         st_insert(st_pts_2_body_region_id, (char *)all_pts[j], (char *)i);
   }

   float ledger_height;
   float x, X, y, Y, z, Z;
   if (ledger_index != -1) {
      ca_load_aux_top_level("bottom_up");
      assert(readRunTimeFlag("box_bottom_up", &value));
      assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x, &X, &y, &Y, &z, &Z) == 6);

      int total_slices = 1000;
      if (readRunTimeFlag("total_slices", &value) )
         total_slices = atoi(value);
      
      assert(readRunTimeFlag("slices_bottom_up_dimension", &value));
      assert(sscanf(value, "%dx%d", &image_width, &image_height) == 2);
      
      ledger_height = z + (Z - z)*((float)ledger_index/total_slices); // 3D coord of Z.
   }

   // transform each data point now.
   // INVARIANT: for each vector<int> *, the first index of (x, y, z) in data is stored.
   printf("total number of segments is %d.\n", total_segments);
   vector<vector<double> > vec_seg_arr ( total_segments );
   
   char x_s[30], y_s[30], z_s[30];
   double x_f, y_f, z_f;
   vector<double> data;
   float diff_x = X - x;
   float scale = image_width / diff_x;
   printf("loading data from file...\n");
   int num = 0;
   int down_sampling = 10;
   if ( readRunTimeFlag("do_paper_down_sampling", &value) ) {
      down_sampling = atoi ( value );
   }
   
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x_f = atof(x_s);
         y_f = atof(y_s);
         z_f = atof(z_s);

         num ++; 
         if ( num % down_sampling != 0 )
            continue;
         
         if ( z_f < ledger_height && vec_regions_body.size() == 1) {
            vec_seg_arr[total_segments - 1].push_back(x_f);
            vec_seg_arr[total_segments - 1].push_back(y_f);
            vec_seg_arr[total_segments - 1].push_back(z_f);
            continue;
         }

         int x_i = (int)(((x_f - x)/diff_x)*image_width  + .5); // x
         int y_i = image_height - (int)((y_f - y) * scale + .5) - 1; // y

         int *rid = 0;
         st_table *st_pts_2_all = z_f < ledger_height ? st_pts_2_body_region_id : st_pts_2_region_id;
         if ( valid_pixel(x_i, y_i) && (st_lookup(st_pts_2_all, (char *)index(x_i, y_i), (char **)&rid) || total_segments <= 2 )) {
            vec_seg_arr[(int)rid].push_back(x_f);
            vec_seg_arr[(int)rid].push_back(y_f);
            vec_seg_arr[(int)rid].push_back(z_f);
         }
         
      }
   }
   fclose(fid);

   vector<double> slice_data;
   for (int i = 0; i < total_segments; i ++)
   {
      printf("\nLoad: Processing segement #%d, ", i);

      slice_data = vec_seg_arr[i];
      if ( slice_data.size() == 0 )
         continue;
      
      generate_iv_for_slab_set_points(fd_new, slice_data);
      slice_data.clear();
   }

   fprintf(fd_new, "\n}\n");
   fclose(fd_new);

   
}

#else

// this function is kept only for later reference of drawing planes.
// rename it for emacs tags
void AAAAAAAAca_paper_generate_iv_for_showing_segmentation()
{
   char *value;
   
   assert(readRunTimeFlag("point_cloud_data_file", &value));
   FILE *fid = fopen(value, "r");
   if (!fid)
   {
      printf("Could not open the file %s\n", value);
      return;
   }

   char str_line[1000];
   char new_file[1000];

   strcpy(new_file, "segments.iv");
   FILE *fd_new = fopen(new_file, "w");
   assert(fd_new);

   {
      fprintf(fd_new, "#Inventor V2.1 ascii\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Separator {\n");
      fprintf(fd_new, "\n");
      // this is transfomration parameter, after it, zoom in 4 times?
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 1 0  1.3707\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  0 0 1  0.2200\n");
      fprintf(fd_new, "}\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "Rotation {\n");
      fprintf(fd_new, "    rotation  1 0 0  0.0400\n");
      fprintf(fd_new, "}\n");
      // this is for transformation
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 1 1.5 0.5\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  DirectionalLight {\n");
      fprintf(fd_new, "    direction 0.30000001 -0.5 2\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
      fprintf(fd_new, "  LightModel {\n");
      fprintf(fd_new, "    model PHONG\n");
      fprintf(fd_new, "\n");
      fprintf(fd_new, "  }\n");
   }


   // let's count how many segments we have to highlight the data:
   int total_segments = 0;

   // do this later 
   /*
   if ( !readRunTimeFlag("result_segment_body_roof", &value) )
      value = "result_seg_body_roof.txt";
   vector<int> *vec_ledger = ca_load_simple_vector(value);
   if ( vec_ledger->size() > 0 && vec_ledger->at(0) !=  0) {
      total_segments ++;
      printf("There is 1 segment in vertical direction. \n");
   }
   */

   assert(readRunTimeFlag("total_faces", &value));
   int total_faces = atoi(value) + 1;
   vector<vector<int> > result_faces(total_faces - 1);

   char *output_fn;
   if ( !readRunTimeFlag("result_segment_roof_only", &output_fn) )
      output_fn = "result_seg_roof_units.txt";
   FILE *output_fd = fopen(output_fn, "r");
   if ( !output_fd ) {
      printf("ERROR: could not open %s\n", output_fn);
      assert(0);
   }
   char index_str[1000];
   int face, im_index, x1, x2, x_w;

   // assume 2 faces, then for 2 x 3 faces, there are 3 x 4 = 12 segments
   int num_seg = 1;
   int total_seg = 1;
   int pre_face = -1;
   while (fgets(index_str, 1000, output_fd ) ) {
      if (sscanf(index_str, "%d %d %d %d %d", &face, &im_index, &x1, &x2, &x_w ) == 5) {
         result_faces[face-1].push_back(im_index);
         result_faces[face-1].push_back(x1);
         result_faces[face-1].push_back(x2);
         result_faces[face-1].push_back(x_w);

         if ( face != pre_face ) {
            if ( pre_face != -1 ) {
               total_seg *= num_seg;
               num_seg = 1;
            }
            pre_face = face;
         }
         
         num_seg ++;
         
      }
   }
   fclose(output_fd);
   total_seg *= num_seg;
   total_segments = total_seg;
   printf("There are total %d segments \n", total_segments);

   // transform each data point now.
   // INVARIANT: for each vector<int> *, the first index of (x, y, z) in data is stored.
   vector<vector<int> *> vec_seg_arr ( total_segments );
   for ( int i = 0; i < total_segments ; i ++ )
      vec_seg_arr[i] = new vector<int> ();
   
   
   char x_s[30], y_s[30], z_s[30];
   double x, y, z;
   vector<double> data;
   printf("loading data from file...\n");
   int num = 0;
   int down_sampling = 10;
   if ( readRunTimeFlag("do_paper_down_sampling", &value) ) {
      down_sampling = atoi ( value );
   }
   
   while (fgets(str_line, 1000, fid))
   {
      if (sscanf(str_line, "%s %s %s", x_s, y_s, z_s) == 3)
      {
         x = atof(x_s);
         y = atof(y_s);
         z = atof(z_s);

         num ++; 
         if ( num % down_sampling != 0 )
            continue;
         
         data.push_back(x);
         data.push_back(y);
         data.push_back(z);
      }
   }
   fclose(fid);

   float x_min, x_max, y_min, y_max, z_min, z_max;

   // computing for each point in data, the index to which its segment belongs
   for (int i = 0; i < data.size() ; i += 3 )
   {
      x = data[i];
      y = data[i+1];
      z = data[i+2];
      int seg_id = 0;
      int total_segs = 1;

      for ( int i_face = 0; i_face < total_faces - 1; i_face ++ )
      {
         int seg_face_index = 1;

         // compute the transformation point for face i_face.
         char fn_trans[1000];
         sprintf(fn_trans, "face%d/trans.txt", i_face + 1 );
         float M[9];
         ca_load_trans_matrix(fn_trans, M);
         float *new_p = ca_compute_multi_vec_matrix(x, y, z, M);

         // compute the slice index for this point on slices folder.
         int slice_index;
         int total_slices;

         sprintf(fn_trans, "face%d", i_face + 1 );
         ca_load_aux_top_level(fn_trans);
         
         assert(readRunTimeFlag("face_total_slices", &value) );
         total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", i_face + 1);
         assert(readRunTimeFlag(fn_trans, &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);
         slice_index = (int) ((new_p[2] - z_min)/(z_max - z_min) * total_slices);
         assert ( slice_index <= total_slices && slice_index >= 0 );

         // compute the segmentation index of the slice_index.
         vector<int> arr_cur_face = result_faces[i_face];
         for ( int k = 0; k < arr_cur_face.size(); k += 4 ) {
            if ( slice_index >= arr_cur_face[k] )
               seg_face_index ++;
            else
               break;
         }

         // eq: x*A + y*B + z ; where A = total(y) * total(z) , B = total(z)
         seg_id += (seg_face_index - 1) * total_segs ;

         assert ( arr_cur_face.size() % 4 == 0 );
         total_segs *= (arr_cur_face.size() / 4 + 1);

         free (new_p);
      }

      // insert this index to the array of segmentation bin.
      if ( seg_id <= total_segments )
         vec_seg_arr[seg_id - 1]->push_back(i);
      else {
         printf("WARNING: seg_id is %d, which is bigger than total_segments: %d", seg_id, total_segments);
      }
   }

   vector<double> slice_data;
   for (int i = 0; i < total_segments; i ++)
   {
      printf("\nLoad: Processing segement #%d, ", i);
      // find out the appropriate points
      // CHANGE: BOX_MIN_Y   

      vector<int> *vec_data_index = vec_seg_arr[i];
      if ( vec_data_index->size() == 0 )
         continue;
      
      for (int index = 0; index < vec_data_index->size(); index ++)
      {
         {
            int index_ = vec_data_index->at(index);
            slice_data.push_back(data[index_]);        // x axis
            slice_data.push_back(data[index_+1]);      // y axis
            slice_data.push_back(data[index_+2]);      // z axis
         }
      }
      
      generate_iv_for_slab_set_points(fd_new, slice_data);
      slice_data.clear();
   }

   // generate the planar

   {
      fprintf(fd_new, "  Separator {\n");
      fprintf(fd_new, "    LightModel {\n");
      fprintf(fd_new, "      model PHONG\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Material {\n");
      fprintf(fd_new, "      ambientColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      diffuseColor  0.5 0.5 0.5\n");
      fprintf(fd_new, "      emissiveColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      specularColor 0.5 0.5 0.5\n");
      fprintf(fd_new, "      shininess     0.5\n");
      fprintf(fd_new, "      transparency  0.5\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    Coordinate3 {\n");
      fprintf(fd_new, "      point [\n"); // 13, 31, 37, 41

      int num_planes = 0;
      for ( int i_face = 0; i_face < total_faces - 1; i_face ++ )
      {
         char fn_trans[1000];
         // compute the slice index for this point on slices folder.
         int slice_index;
         int total_slices;

         sprintf(fn_trans, "face%d", i_face + 1 );
         ca_load_aux_top_level(fn_trans);
         
         assert(readRunTimeFlag("face_total_slices", &value) );
         total_slices = atoi(value);
         
         sprintf(fn_trans, "box_face%d", i_face + 1);
         assert(readRunTimeFlag(fn_trans, &value));
         assert(sscanf(value, "%f_%f_%f_%f_%f_%f", &x_min, &x_max, &y_min, &y_max, &z_min, &z_max) == 6);

         // compute the transformation point for face i_face.
         sprintf(fn_trans, "face%d/trans_back.txt", i_face + 1 );
         float M[9];
         ca_load_trans_matrix(fn_trans, M);

         // compute the segmentation index of the slice_index.
         vector<int> arr_cur_face = result_faces[i_face];
         for ( int i_plane = 4; i_plane < arr_cur_face.size() - 4; i_plane += 4 ) {
            int cur_index = arr_cur_face[i_plane];
            float ratio = 0.15;
            float z_high = z_min + (cur_index + 1)/(float)(total_slices + 1) * (z_max - z_min);
            float x_min1 = x_min - (x_max - x_min) * ratio; 
            float x_max1 = x_max + (x_max - x_min) * ratio;
            float y_min1 = y_min - (y_max - y_min) * ratio; 
            float y_max1 = y_max + (y_max - y_min) * ratio;
            float *new_p;
            new_p = ca_compute_multi_vec_matrix(x_min1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_min1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_max1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);
            new_p = ca_compute_multi_vec_matrix(x_max1, y_min1, z_high, M);
            fprintf(fd_new, "        %.3f %.3f %.3f,\n", new_p[0], new_p[1], new_p[2]);
            free(new_p);

            num_planes ++;
         }

      }
      
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "    IndexedFaceSet {\n");
      fprintf(fd_new, "      coordIndex [\n");

      for ( int i = 0; i < num_planes; i ++ ) {
         fprintf(fd_new, "        %d, %d, %d, %d, -1,   \n", i*4+3, i*4+2, i*4+1, i*4);
      }
      fprintf(fd_new, "        ]\n");
      fprintf(fd_new, "    }\n");
      fprintf(fd_new, "  }\n");
   }
   
   fprintf(fd_new, "\n}\n");
   fclose(fd_new);

   
}

#endif

// Function: draw_plot
// Helper function to plot segmentation for 3DPVT 2011
//
// Usage:
// project -z config.ini -O "-r bottom_up/image_slice -s 940 -e 951"
void ca_compute_plot_for_segmentation()
{
   int start_id = 0;
   int end_id = 0;
   char *read_path  = NULL;
   char *write_path = NULL;
   
   if (global_opts)
   {

      int  argc = 0;
      char *argv[60];
      load_options(global_opts, argc, argv);
      
      char c;
      char *cmdline;
      util_getopt_reset();
      while ((c = util_getopt(argc, argv, "s:e:r:w:")) != EOF)
      {
         switch (c) {
            case 's':
               start_id = atoi(util_optarg);
               break;
            case 'e':
               end_id = atoi(util_optarg);
               break;
            case 'r':
               read_path = strdup(util_optarg);
               break;
            case 'w':
               write_path = strdup(util_optarg);
               break;
            default:
               break;
         }
      }
   }

   assert(end_id > start_id);
   assert(read_path);

#ifndef LINUX
   Bitmap* orig_img = NULL;
#else
   CImg<BYTE> *orig_img = NULL;
#endif

   char *fn_ext;
   {
      char fn[1000];
      sprintf(fn, "%s_0100.tif", read_path);
      if ( !file_exist(fn) ) {
         fn_ext = strdup("png");
      } else {
         fn_ext = strdup("tif");
      }
   }
   
   char fn[1000];
   BYTE **cur_im, **int_im;
   int h, w;
   FILE *fd = fopen("plot.txt", "w");
   assert(fd);
   for (int i = start_id; i < end_id; i++ ) {
      char *ds = digit_string(4, i);
      sprintf(fn, "%s_%s.%s", read_path, ds, fn_ext);
      free(ds);
      printf("Computing %s ...\n", fn);
      
      orig_img = load_image(fn, h, w);
      set_image(cur_im, orig_img);

      int count = 0;
      for (int k = 0; k < h*w; k ++ ) {
         if ( cur_im[0][k] == BLACK )
            count ++;
      }

      fprintf(fd, "%d %d\n", i, count);
      delete orig_img;
      free_image(cur_im);
   }

   fclose(fd);
}


void ca_paper_process()
{
   char *value;
   if ( !readRunTimeFlag( "do_paper_process", &value ) || strcmp(value, "1") != 0) {
      return;
   }

   // generate segmentation iv data.
   if ( readRunTimeFlag( "do_paper_show_segment_result", &value ) && strcmp(value, "1") == 0) {
      ca_paper_generate_iv_for_showing_segmentation();
   }

   // show window detection image
   if ( readRunTimeFlag( "do_paper_show_window_result", &value ) && strcmp(value, "1") == 0) {
      ca_compute_show_windows_lines();                    /* compute window lines */
   }

   // show window mask images
   if ( readRunTimeFlag( "do_paper_show_window_mask", &value ) && strcmp(value, "1") == 0) {
      ca_compute_body_mask_for_windows();                 /* compute the mask image for windows/doors. */
   }

   // show plotting for segmentation
   if ( readRunTimeFlag( "do_paper_plotting", &value ) && strcmp(value, "1") == 0) {
      ca_compute_plot_for_segmentation();                 /* compute the data points for slices. */
   }

   // show plotting planes for segmentation
   if ( readRunTimeFlag( "do_paper_segment_plane", &value ) && strcmp(value, "1") == 0) {
      ca_paper_generate_iv_for_showing_segmentation_planes();  
   }

   
   // let quit if this is paper process.
   exit(0);
}


/*
  FUNCTION: project_compute_all

  Main entry function for model reconstruction.

  Overview Flow:

  *. Infer the ledger if exists for body and roof separation.
  *. Infer sub-units for both body and roof.
  *. For each sub-unit, infer tapered or extruded shape with a big threshold.
  *. For each wall, compute the windows and masks for extrusion.
  *. For each sub-unit, compute the detailed extrusion or tapered structure.
  *. Generate the naked model with above each sub-unit.
  *. Paste windows on each wall.

  TODO:
  *. 3D align/merge adjacent splitted sub-unit to the whole wall by adjusting the end points (projected on the wall line).

  *. set manually control point with parameters of 1. keyslices generation 2. bpa images 3. segmentation 4. window images

  DETAILED INFO:
  *. To control the segmentation, use result_seg_roof_units.txt, 
  *. To redefine the segment type, use result_seg_roof_regtypes_2.txt. In case from extrusion -> taper, remove key_slices.txt
  *. To paste the same part, use photoshop, fill the path, copy the path to other images.
  
 */

void project_compute_all(char *fn)
{
   char *value;

   assert(fn);
   FILE *fd = fopen(fn, "r");
   if ( !fd ) {
      printf("INFO: Could not open the file %s.\n", fn);
   } else {
      load_global_settings(fd);
      fclose(fd);
   }

   ca_paper_process();
   
   assert(readRunTimeFlag("point_cloud_data_file", &value));
   ca_preprocess_original_data(value);
   
   if ( !readRunTimeFlag( "do_segmentation", &value) || strcmp(value, "1") == 0 ) {
      ca_segment_body_roof();                             /* segment the body from roof */
      ca_segment_body_roof_show_result();

      ca_segment_wall_detection();                        /* wall detection for sub-unit segments for both body and roof */

      ca_segment_roof_show_result();                      /* compute the segment boundary in bottom-up image */
      ca_segment_body_show_result();                      /* compute the segment boundary in bottom-up image */

      ca_dump_segmented_body_roof();                      /* dump the segment roof and body data into sub-units */
   }

   if ( !readRunTimeFlag( "do_roof_inference", &value ) || strcmp(value, "1") == 0) {
      ca_infer_roof_structure_inference();                 /* infer the underline structure for each sub unit of roof */

      ca_infer_roof_keyslices_computation();
      ca_infer_roof_bpa_image_generation();
      ca_infer_roof_bpa_IR_computation();
   }

   if ( !readRunTimeFlag( "do_body_inference", &value ) || strcmp(value, "1") == 0) {
      ca_infer_body_structure_inference();                 /* infer the underline structure for each sub unit of body */

      ca_infer_body_keyslices_computation();
      ca_infer_body_bpa_image_generation();
      ca_infer_body_bpa_IR_computation();
   }

   if ( !readRunTimeFlag( "do_ledger_inference", &value ) || strcmp(value, "1") == 0) {
      ca_infer_ledger_structure_inference();                 /* infer the underline structure for each sub unit of ledger */

      ca_infer_ledger_keyslices_computation();
      ca_infer_ledger_bpa_image_generation();
      ca_infer_ledger_bpa_IR_computation();
   }

   if ( !readRunTimeFlag( "do_model_generation", &value ) || strcmp(value, "1") == 0) {
      ca_generate_3D_model_ledger();
      ca_generate_3D_model_body();
      ca_generate_3D_model_roof();
   }

   if ( !readRunTimeFlag( "do_window_process", &value ) || strcmp(value, "1") == 0) {
      // ca_compute_body_window_structure();                 /* infer the windows and doors on the wall of the body part */
      // ca_compute_roof_window_structure();                 /* infer the windows and doors on the wall of the roof part */
      
      // ca_compute_show_windows_lines();                    /* compute window lines */
      // ca_compute_body_mask_for_windows();                 /* compute the mask image for windows/doors. */
      
      ca_dump_window_on_body();                           /* transform the windows onto walls of the body part */
      ca_dump_window_on_roof();                           /* transform the windows onto walls of the roof part */
   }

}


// Function: try_sth
// a helper function to try sth in C/C++
//
extern void hough_plane_cb(char *fn);
void try_sth()
{
   if (gbl_opts->try_sth == 0)
      return;

   // dump window info for paper
   {
      ca_compute_windows_infer_wins("sym_image_0736_0739.png", "out.txt", "sym_image_0736_0739_out.png");    
   }
   
   {
      // temp testing
      vector<double> data;
      load_point_cloud_for_bounding_box("point_cloud_roof_region_2.txt", data);
      exit(0);
   }
       
   {
      printf("Trying Hough Plane...\n");
      hough_plane_cb(gbl_opts->input_prefix);
      exit(0);
   }
      
   {
      int h, w;
      BYTE **orig_img1 = load_image_array("image_slice_0648.png", h, w);
      BYTE **orig_img2 = load_image_array("image_slice_0608.png", h, w);
      for (int i = 0; i < h*w; i ++ )
         orig_img2[0][i] |= orig_img1[0][i];
      Save2File("image_slice_integrated", orig_img2, NULL, w, h, 0, NULL);
      exit(0);
      
   }
   
   {
      char *fn = "aaaa/bb.png";
      char *new_fn = str_cutFromLastSubstring(fn, "/");
      printf("NEW : %s\n", new_fn);
      exit(0);
   }
   
   {
      int h, w;
      BYTE **im = load_image_array("image_slice_0006.png", h, w);
      Save2File("test.png", im, NULL, image_width, image_height, 0, NULL);
      exit(0);
   }

   // try matrix inverse
   {
      float **M = matrix_malloc(3);
      for (int i = 0; i < 3 ; i ++ )
         for (int j = 0; j < 3; j ++)
            M[i][j] = i == j ? 1 : 0;
      float **MM = compute_inverse_matrix(M, 3);
      for (int i = 0; i < 3 ; i ++ )
         for (int j = 0; j < 3; j ++)
            printf("%f%s", MM[i][j], j == 2 ? "\n" : " ");

      exit(0);
   }
   
   // try common ledger
   {
      int mode = 1;
      
      // updating Z on the other size
      if ( mode ) {
         FILE *fd1 = fopen(gbl_opts->input_prefix, "r");
         FILE *fd2 = fopen(gbl_opts->output_prefix, "w");
         char str[1000];
         bool started = false;
         while (fgets(str, 1000, fd1)) {
            if ( strncmp(str, "POINT", 5) == 0) {
               started = true;
               fprintf(fd2, str);
               continue;
            }
            if ( strncmp(str, "EXTRU", 5) == 0) {
               started = false;
               fprintf(fd2, str);
               continue;
            }

            if ( !started ) {
               fprintf(fd2, str);
               continue;
            }

            float f1, f2;
            assert(sscanf(str, "%f %f", &f1, &f2) ==  2);
            fprintf(fd2, "%f %f\n", 45.935740 + ( f1 - 1.122408 ), f2);
         }

         fclose(fd1);
         fclose(fd2);
         exit(0);
            
      }

      if ( !mode )
      {
         // load the lines
         int h = 1024;
         int w = 1024;
         FILE *fd1 = fopen(gbl_opts->input_prefix, "r");
         FILE *fd2 = fopen(gbl_opts->output_prefix, "w");
         char str[1000];
         bool started = false;
         while (fgets(str, 1000, fd1)) {
            if ( strncmp(str, "BEGIN", 5) == 0) {
               started = true;
               fprintf(fd2, str);
               continue;
            }
            if ( strncmp(str, "EXTRU", 5) == 0) {
               started = false;
               fprintf(fd2, str);
               continue;
            }

            if ( !started ) {
               fprintf(fd2, str);
               continue;
            }

            int d1, d2;
            assert(sscanf(str, "%d %d", &d1, &d2) ==  2);
            fprintf(fd2, "%d %d\n", 83 - d1, d2);
         }

         fclose(fd1);
         fclose(fd2);
         exit(0);
      }
   }
   
   // try plane
   {
      POINT_3D p1 = { 26.686516, -1.184091, 20.264357 };
      POINT_3D p2 = { 39.551895, 28.998911, 15.984033 };
      POINT_3D p3 = { 72.915703, -1.120757, 4.883860 };
      POINT_3D p4 = { 86.471840, -0.510335, 46.264164 };
      POINT_3D p5 = { 72.818069, 9.966491, 5.225000 };
      POINT_3D p6 = { 76.239899, -0.967800, 15.509998 };
      PLANE_3D *p3d1 = compute_plane_from_3D_pts(p1, p2, p3);
      PLANE_3D *p3d2 = compute_plane_from_3D_pts(p4, p5, p6);

      POINT_3D P0, P1;
      POINT_3D *vec = compute_intersection_line_from_2_planes(*p3d1, *p3d2, P0, P1);
      if ( p3d1 ) {
         compute_unit_vector(p3d1->N);
         compute_unit_vector(p3d2->N);
         printf("Normal Plane 1 is [%f, %f, %f]\n", p3d1->N.x, p3d1->N.y, p3d1->N.z);
         printf("Normal Plane 2 is [%f, %f, %f]\n", p3d2->N.x, p3d2->N.y, p3d2->N.z);
      }
      printf("INTERSECTION LINE IS P0: [%f, %f, %f]\n",P0.x, P0.y, P0.z);
      printf("INTERSECTION LINE IS P1: [%f, %f, %f]\n",P1.x, P1.y, P1.z);
      if ( vec ) {
         compute_unit_vector(*vec);
         printf("INTERSECTION LINE vector: [%f, %f, %f]\n",vec->x, vec->y, vec->z);
      }

      exit (0);

      {
      POINT_3D p1 = { 0.0, 0.0, 0.0 };
      POINT_3D p2 = { 0.0, 1.0, 0.0 };
      POINT_3D p3 = { 0.0, 0.0, 1.0 };
      POINT_3D p4 = { 1.0, 1.0, 0.0 };
      PLANE_3D *p3d1 = compute_plane_from_3D_pts(p1, p2, p3);
      PLANE_3D *p3d2 = compute_plane_from_3D_pts(p1, p2, p4);

      POINT_3D P0, P1;
      POINT_3D *vec = compute_intersection_line_from_2_planes(*p3d1, *p3d2, P0, P1);
      if ( p3d1 ) {
         compute_unit_vector(p3d1->N);
         compute_unit_vector(p3d2->N);
         printf("Normal Plane 1 is [%f, %f, %f]\n", p3d1->N.x, p3d1->N.y, p3d1->N.z);
         printf("Normal Plane 2 is [%f, %f, %f]\n", p3d2->N.x, p3d2->N.y, p3d2->N.z);
      }
      printf("INTERSECTION LINE IS P0: [%f, %f, %f]\n",P0.x, P0.y, P0.z);
      printf("INTERSECTION LINE IS P1: [%f, %f, %f]\n",P1.x, P1.y, P1.z);
      if ( vec ) {
         compute_unit_vector(*vec);
         printf("INTERSECTION LINE vector: [%f, %f, %f]\n",vec->x, vec->y, vec->z);
      }
      }
      
      exit (0);
   }
   
   {
      // try load image from BPA points
      vector<int> all_lines;
      image_width   = gbl_opts->img_w == 0 ? 1024 : image_width;
      image_height  = gbl_opts->img_h == 0 ?  512 : image_height;
      load_lines_from_BPA_dump(all_lines, "test_ir.txt", image_height, image_width);
      write_lines_to_bw_image("test.png", all_lines,  image_height, image_width);
      exit(0);      
   }      
   {
      image_width = 1024;
      image_height = 512;
      vector<int> vec_poly;
      vector<int> vec_fill;
      {
         FILE *fd = fopen("global_init_dumped_0.txt", "r");
         assert(fd);
         char str_line[100];
         int x, y;
         while (fgets(str_line, 100, fd)) {
            if ( str_line[0] == 'B' || str_line[0] == 'E' )
               continue;
            sscanf(str_line, "%d %d", &x, &y);
            vec_poly.push_back(index(x, y));
         }
         fclose(fd);
      }
      fill_polygon(vec_poly, vec_fill);
      BYTE **im = new_image(image_height, image_width);
      for (int i = 0; i < vec_fill.size(); i ++)
         im[0][vec_fill[i]] = BLACK;
      Save2File("fill_polygon.png", im, NULL, image_width, image_height, 0, NULL);
      return;
   }
   
   {
      graph_cut();
      return;
   }
   
   {
      char *prefix = gbl_opts->input_prefix;
      char fn[1000], out_fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.ply", prefix, ds);

         if ( !file_exist(fn) )
            continue;

         char line[1000];
         sprintf(out_fn, "%s/bbb_image_slice_%s_dumped_0.txt", gbl_opts->output_prefix, ds);
         FILE *fd = fopen(fn, "r");
         FILE *fd_out = fopen(out_fn, "w");
         while ( fgets(line, 1000, fd )) {
            if ( strncmp(line, "POLY", 4) == 0) {
               fprintf(fd_out, "BEGIN POLYGON\n");
            }
            else if ( strncmp(line, "END", 3) == 0 ) {
               fprintf(fd_out, "END POLYGON\n");
            } else {
               fprintf(fd_out, line);
            }
         }
         fclose(fd);
         fclose(fd_out);
         
         printf("Doing file %s\n", fn);
      }

      exit(0);
   }

   {
      int h = 1024;
      int w = 1024;
#ifdef LINUX
      CImg<BYTE> *orig_img = NULL;
#else
      Bitmap *orig_img = NULL;
#endif
      BYTE **cur_im;

      char *prefix = gbl_opts->input_prefix;
      assert(prefix);
      char fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.tif", prefix, ds);

         if ( !file_exist(fn) )
            continue;

         char command[1000];
         sprintf(command, "..\\ras2vec.exe -p -o %s %s  > temp", gbl_opts->output_prefix, fn);
         system(command);
         
         printf("Doing file %s\n", fn);
      }

      exit(0);
   }

   {
      int h = 1024;
      int w = 1024;
#ifdef LINUX
      CImg<BYTE> *orig_img = NULL;
#else
      Bitmap *orig_img = NULL;
#endif
      BYTE **cur_im;

      char *prefix = gbl_opts->input_prefix;
      assert(prefix);
      char fn[1000];
      for (int i = 0; i < 1000; i ++ ) {
         char *ds = digit_string(4, i);
         sprintf(fn, "%s_%s.png", prefix, ds);

         if ( !file_exist(fn) )
            continue;
         
         orig_img = load_image(fn, h, w);
         set_image(cur_im, orig_img);
         sprintf(fn, "%s_%s.tif", prefix, ds);
         Save2File(fn, cur_im, NULL, w, h, 0, NULL);
         free_image(cur_im);
         delete orig_img;

         printf("Converting file %s\n", fn);
      }

      exit(0);
   }
   
   {
      int h = 1024;
      int w = 1024;
      vector<int> r2v_line_set;
      load_lines_from_ras2vec(r2v_line_set, gbl_opts->input_prefix, h, w);
      write_lines_to_image("line_set_R2V.png",r2v_line_set, h, w);
      write_lines_to_bw_image("line_set_R2V_bw.png", r2v_line_set, h, w);
      exit(0);
   }
   
   char *path_name="acc_template_face.tif";
#ifdef LINUX
   CImg<BYTE> *orig_img = NULL;
#else
   Bitmap *orig_img = NULL;
#endif
   int h, w;
   BYTE **cur_im;
   orig_img = load_image(path_name, h, w);
   set_image(cur_im, orig_img);
   Save2File("image_slice_new.png", cur_im, NULL, w, h, 0, NULL);

   exit(0);
   
   image_width = 4096; // could not be too big???? 53109 doesn't work
   image_height = 48;
   BYTE ***im = new_3D_image(image_height, image_width);
   //   for (int i = 0; i < image_height * image_width; i ++)
   //      im[0][i] = (float) i / (image_height * image_width) * 255;
#ifndef LINUX
   Save2File(path_name , NULL, NULL, image_width, image_height, 1, im);
#endif   
   exit(0);
   
   char aaa[1000];
   sprintf(aaa,"result/point_cloud_process/acc_template_1.png");
   printf("1: [%s]\n", aaa);
   sprintf(aaa,"result/point_cloud_process/acc_%d.png", 2);
   printf("2: [%s]\n", aaa);
   sprintf(aaa,"%s.png", aaa);
   printf("3: [%s]\n", aaa);
   exit(0);

   // try load image from BPA points
   vector<int> all_lines;
   image_height  = 392;  // default values
   image_width   = 1024;
   load_lines_from_BPA_dump(all_lines, "global_init_dumped_1.txt", image_height, image_width);
   write_lines_to_bw_image("test.png", all_lines,  image_height, image_width);
   exit(0);

   // try angle between two lines
   int x, y;
   double a1 = compute_angle_between_lines(50,50,40,50,50,50,60,40,x,y);
   double a2 = compute_angle_between_lines(50,50,40,50,50,50,40,40,x,y);
   double a3 = compute_angle_between_lines(50,50,40,50,50,50,60,60,x,y);
   double a4 = compute_angle_between_lines(50,50,40,50,50,50,40,60,x,y);
   printf("angles: %f %f %f %f\n",a1,a2,a3,a4);
   a1 = angle_arc(40,50,50,50,60,40,-1);
   a2 = angle_arc(40,50,50,50,40,40,-1);
   a3 = angle_arc(40,50,50,50,60,60,-1);
   a4 = angle_arc(40,50,50,50,40,60,-1);
   printf("angles: %f %f %f %f\n",a1,a2,a3,a4);
   exit(0);
   
   // try matrix inverse
   CImg<double> A(2, 2, 1, 1, 0.0);
   A(0,0) = 5.0;
   A(1,1) = 5.0;
   A.print();
   A.inverse();
   A.print();
   exit(0);


   // test 3D bounding box
   draw_3D_bounding_box_test();
   exit(0);
   
   //printf("atan(0) : %f - atan(-1000): %f - atan(40000): %f\n", atan(0.0), atan(-1000.0), atan(40000.0));
   printf("acos(180):%f\n", acos((double)(3*3+4*4-7*7)/(2*3*4)));

   exit(0);
}


/*
  command: project -F input_fn.txt -f output_fn.txt -r 10
 */
void down_sample_data_size(int down_ratio)
{
   FILE *fd = fopen(gbl_opts->input_prefix, "r");
   FILE *fd_out = fopen(gbl_opts->output_prefix, "w");

   assert (fd );
   assert (fd_out);

   char str[1000];
   int count = 0;
   while ( fgets(str, 1000, fd ) ) {
      if ( count++ % down_ratio == 0 )
         fprintf(fd_out, "%s", str);
   }

   fclose(fd);
   fclose(fd_out);
}

/* Function: compute_matrix_from_angles

   command: project -Q

   This is to compute Cartesian vector [x, y, z] from Spherical coordinate (theta, phi).
   This is also to compute the 3rd vector based on CROSS product.
   The default vector is [0.0, 0.0, 1.0]

   This is used to adjust the major plane detection:
   1. Run the major plane detection with appropriate parameters, see <hough_plane_cb>
   2. Choose the theta and phi, check wiki for details.
   3. Set 3 to 4 manually value from theta or phi, compute using the func, and put them into config.ini
   4. Check slices generated with these values.

   Note: If the default vector [0 0 1] is not accurate, the slices might be never aligned.
   That is, it is hard to get a slice with all dark regions, maybe 2 - 3 dark regions.

*/
extern int convToCartesian(int theta, int phi, float *x, float *y, float *z);
void compute_matrix_from_angles()
{
   int theta, phi;
   float x, y, z;

   while ( 1 ) {
      printf("Please input theta and phi:\n");
      scanf("%d %d", &theta, &phi);

      if ( theta == -1 )
         break;
      
      convToCartesian(theta, phi, &x, &y, &z);
      
      printf("The result are: %f %f %f\n", x, y, z);
   }

   printf("Do you need to compute the other one (Y/N)?\n");

   char str[10];
   scanf("%s", str);
   if ( str[0] == 'y' || str[0] == 'Y') {
      printf("Please input the 1st vector:\n");
      scanf("%f %f %f", &x, &y, &z);

      POINT_3D p1, p2, p3;
      p1.x = x; p1.y = y; p1.z = z;
      printf("Please input the 2nd vector:\n");
      scanf("%f %f %f", &x, &y, &z);
      p2.x = x; p2.y = y; p2.z = z;
      cross_product(p1, p2, p3);
      printf("The result are: %f %f %f\n", p3.x, p3.y, p3.z);
   }
   
   exit(0);
}

// Function: main
// main function for parameter processing
//
int main (int argc, char **argv)
{
   char c;
   char *cmdline;
   time_t ot, ct;
   int do_preprocess = 0;
   int do_preprocess_2 = 0;
   int do_preprocess_3 = 0;
   int do_preprocess_4 = 0;      
   int do_BPA_boundary = 0;                // use ball-pivot algorithm to obtain boundaries.
   int do_load_point_cloud = 0;            // load 3D point cloud into 2D images
   int do_DP = 0;                          // do the Douglas Peucker line simplification
   int do_key_slices_detect = 0;           // key slices detection for 3D point cloud.
   int do_system_batch = 0;                // system batch command
   int do_generate_dxf = 0;                // generate dxf for google sketchup
   int do_prep_for_key_slices = 0;         // preprocessing for key slice detection.
   int do_taper_image_generation = 0;      // generating tapered images
   int do_taper_structure_infer = 0;       // infer taper structure
   int do_generate_dxf_from_IR = 0;        // load the IR into dxf format
   int do_generate_skp_from_IR = 0;        // convert the IR into SketchUp PlugIns
   int do_load_point_cloud_left_right = 0; // load the pont cloud left to right.
   int do_infer_taper_use_other_dirs = 0;  // infer the taper structure from other directions
   int do_noise_remove = 0;                // remove noise based on mask images
   int do_error_measurement = 0;           // compute the errors and map it on SketchUp
   int do_get_IR_with_extruded_only =0;    // generate IR with extruded structures only
   int do_integrate_images =0;             // integrate images for ACCV 2009 paper.
   int do_generate_iv_from_input = 0;      // generate IV file from BPA sliced ascii files
   int do_sort_IR_on_height = 0;           // sort the IR layers on height
   int do_dataset_rectification = 0;       // rectify the dataset/scans from Prof. Stamos
   int do_IR_sanity_check = 0;             // sanity check on the IR data;
   int do_load_ir_to_image = 0;            // load the IR txt file and save it to image;
   int do_all_together = 0;                // do all tasks in this function call, use avl_lookup to set params

   vector<int> temp;

   project_init();
   util_getopt_reset();
   time(&ot);
   while ((c = util_getopt(argc, argv, "AaB:bC:c:D:d:Ee:F:f:GghH:I:iJjKkl:L:mMnN:O:o:p:P:QqR:r:Ss:Tt:w:W:x:z:Z:12:3:")) != EOF)
   {
      switch (c) {
         case '1':
            compute_simple_symmetry_test();
            break;
         case 'Q':
            compute_matrix_from_angles();
            break;
         case 'r':
            down_sample_data_size(atoi(util_optarg));
            break;
         case 'i':
            generate_iv_from_bpa();
            break;
         case 'J':
            do_integrate_images = 1;
            break;
         case 'z':
            do_all_together = 1;
            cmdline = util_optarg;
            break;
         case 'Z':
            hough_plane_cb(util_optarg);
            break;
         case 'n':
            do_dataset_rectification = 1;
            break;
         case 'q':
            do_load_ir_to_image = 1;
            break;
         case 'N':
            do_IR_sanity_check = atoi(util_optarg);
            break;
         case 'm':
            do_sort_IR_on_height = 1;
            break;
         case 'M':
            do_noise_remove = 1;
            break;
         case 'j':
            do_generate_iv_from_input = 1;
            break;
         case 'h':
            UsagePrint(argv[0]);
            break;
         case 't':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            // write out the test data
            test_data_for_DP(cmdline, 1);
            break;
         case 'F':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            gbl_opts->input_prefix = cmdline;
            break;
         case 'f':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            gbl_opts->output_prefix = cmdline;
            break;
         case 'e':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            set_epsilon(cmdline);
            break;
         case 'l':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            do_load_point_cloud = 1;
            break;
         case 'L':
            gbl_opts->BPA_parameter_file = strdup( util_optarg );
            break;
         case 'b':
            boundary_matching();
            break;
         case 'S':
            do_system_batch = 1;
            break;
         case 'A':
            do_load_point_cloud_left_right = 1;
            break;
         case 'E':
            do_get_IR_with_extruded_only = 1;
            break;
         case 'a':
            do_infer_taper_use_other_dirs = 1;
            break;
         case 'k':
            do_prep_for_key_slices = 1;
            break;
         case 'K':
            do_key_slices_detect = 1;
            break;
         case 'R':
            do_generate_dxf = atoi(util_optarg);
            break;
         case 'g':
            do_taper_image_generation = 1;
            break;
         case 'G':
            do_taper_structure_infer = 1;
            break;
         case 'I':
            do_generate_dxf_from_IR = 1;
            cmdline = util_optarg;
            break;
         case 'C':
            do_generate_skp_from_IR = 1;
            cmdline = util_optarg;
            break;
         case 'D':
            do_error_measurement = 1;
            cmdline = util_optarg;
            break;
         case 'T':
            gbl_opts->try_sth = 1;
            break;
         case 's':
            output_fn = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(output_fn, "%s", util_optarg);
            generate_dxf_for_sketchup();
            break;
         case 'd':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            // write out the test data
            do_DP = 1;
            break;
         case 'o':
            output_fn = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(output_fn, "%s", util_optarg);
            // write out the test data
            break;
         case 'O':
            global_opts = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(global_opts, "%s", util_optarg);
            break;
         case 'P':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            // write out the test data
            do_preprocess = 1;
            break;
         case 'p':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            do_preprocess_2 = 1;
            break;
         case 'B':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            do_BPA_boundary = 1;
            break;
         case 'H':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            hough_transform(cmdline, temp);
            break;
         case 'x':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            write_polyline_2_image(cmdline);
            break;
         case 'c':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            write_BPA_lines_2_image(cmdline);
            break;
         case 'w':
            gbl_opts->img_h = image_height = atoi(util_optarg);
            break;
         case 'W':
            gbl_opts->img_w = image_width = atoi(util_optarg);
            break;
         case '3':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            do_preprocess_3 = 1;
            break;
         case '4':
            cmdline = (char *)calloc(strlen(util_optarg) + 1, sizeof(char));
            sprintf(cmdline, "%s", util_optarg);
            do_preprocess_4 = 1;
            break;
         case '2':
            printf("case 2! -- %s\n", util_optarg);
            
            break;
         default:
            UsagePrint(argv[0]);
      }
   }

   try_sth();

   if ( gbl_opts->BPA_parameter_file )
      load_parameter(gbl_opts->BPA_parameter_file);
      
   if (argc == 1)
      UsagePrint(argv[0]);

   if (do_preprocess)
      preprocess(cmdline);
   if (do_preprocess_2)
      preprocess_2(cmdline);
   if (do_preprocess_3)
      preprocess_3(cmdline);
   if (do_preprocess_4)
      preprocess_4(cmdline);
   if (do_DP)
      my_nonrec_DP(cmdline);
   if (do_BPA_boundary)
      BPA_boundary(cmdline);
   if (do_load_point_cloud)
      load_point_cloud_as_images(cmdline);
   if (do_key_slices_detect)
      key_slices_detection();
   if (do_system_batch)
      system_batch_process();
   if (do_generate_dxf) 
      generate_dxf_from_BPA_dump(do_generate_dxf);
      //generate_dxf_from_ras2vec();
   if (do_prep_for_key_slices)
      key_slices_detection_prep();
   if (do_taper_image_generation)
      taper_image_generation();
   if (do_taper_structure_infer)
      taper_structure_infer();
   if (do_generate_dxf_from_IR)
      generate_dxf_from_IR(cmdline);
   if (do_generate_skp_from_IR)
      generate_skp_from_IR(cmdline);
   if (do_load_point_cloud_left_right)
      load_point_cloud_left_right();
   if (do_infer_taper_use_other_dirs)
      infer_taper_use_other_dirs(); 
   if (do_error_measurement)
      compute_error_for_IR(cmdline);
   if (do_get_IR_with_extruded_only)
      dump_boundary_points_to_IR();
   if (do_integrate_images)
      integrate_images();
   if (do_load_ir_to_image)
      load_ir_to_image();
   if (do_generate_iv_from_input)
      generate_iv_from_input();
   if (do_sort_IR_on_height)
      sort_IR_on_height();
   if (do_noise_remove)
      noise_removal_by_mask();
   if (do_dataset_rectification)
      rectify_scans();
   if (do_IR_sanity_check)
      sanity_check(do_IR_sanity_check);
   if (do_all_together)
      project_compute_all(cmdline);
     

   time(&ct);
   printf("\nTotal time is :%d\n", ct-ot);
   return 0;
}

