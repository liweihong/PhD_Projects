/*
	File: data_recover.c
	
	C code for missing data reconstruction based on symmetry. Click <C_Data_recover.c> to show the source code.

	Algorithms:
		- Compute the symmetry line based on symmetry distance <find_symmetry>, the input is generated by <set_distance_table> to set up a LUT.
		- Recover missing data based on the symmetry line using <miss_data_recover>

*/
#include <mex.h>
#include <windows.h>
#include <stdio.h>
#include <math.h>


#define PI 3.1415926

#define BLACK 1
#define WHITE 0
#define MAXIMUM 1000

typedef int DIST; // In case we want to change the data type for symmetry distance, such as from int to float;

typedef struct _vector
{
	size_t size;
	size_t capacity;
	int *data;
} Vector;

Vector* create_vector()
{
	Vector *node;

	node = (Vector *) malloc(sizeof(Vector));
	node->size = 0;
	node->capacity = 100;
	node->data = (int *)malloc(sizeof(int)*node->capacity);

	return node;
}

void push_back(Vector *vct, int value)
{
	int *tmp;

	if (vct->size == vct->capacity)
	{
		vct->capacity += 100;
		tmp = (int*) malloc (sizeof(int)*vct->capacity);
		memcpy(tmp, vct->data, (vct->capacity - 100)*sizeof(int));
		free(vct->data);
		vct->data = tmp;
	}

	vct->data[vct->size++] = value;

}

/* 
//	Function: set_distance_table
//
//  Set up the distance look up table for symmetry line finding.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return DIST **lut, distance lookup table, to locate the most similiar image.
//
//	Algorithms:
//	- Using watering method for the pixels which are not belong to the image (WHITE)
//	- Set the image to be 3w*h, assuming symmetry line is vertical.
//	- Calculate the Manhanttan distance for each pixel to the nearest pixel, which belongs to the image.
*/
DIST ** set_distance_table(BYTE**image, int img_h, int img_w)
{
	int h = img_h;
	int w = 3 * img_w;
	int x, y;
	size_t i;
	int span_steps;
	int count = 0;
	Vector *temp_node_vector, *node_vector;
	DIST **lut;

	lut = (DIST**)malloc(sizeof(DIST*)*h);
	lut[0] = (DIST*)malloc(sizeof(DIST)*h*w);
	for (y=0; y<h; y++)
		lut[y] = lut[0] + w*y;

	// Init the LUT.
	// use watering method.
	node_vector = create_vector();

	for (y=0; y<h; y++)
		for(x=0; x<w; x++)
		{
			if (x > img_w && x < 2*img_w && image[y][x-img_w] == BLACK)
			{
				lut[y][x] = 0;
				push_back(node_vector,x);
				push_back(node_vector,y);
			}
			else 
				lut[y][x] = MAXIMUM;
		}

	span_steps = 1;
	temp_node_vector = create_vector();
	while (true)
	{
		for (i=0; i<node_vector->size; i=i+2)
		{
			int node_x = (node_vector->data)[i];
			int node_y = (node_vector->data)[i+1];
			int x, y;

			// Ignore the boundary rectangle first!
			if (node_x > 0 && node_x < w - 1 && node_y > 0 && node_y < h - 1)
			{

				y = node_y -1; x = node_x;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y +1; x = node_x;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y -1; x = node_x-1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y; x = node_x-1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y +1; x = node_x-1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y -1; x = node_x+1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y ; x = node_x+1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}
				y = node_y +1; x = node_x+1;
				if (lut[y][x] == MAXIMUM)
				{
					lut[y][x] = span_steps;
					push_back(temp_node_vector, x);
					push_back(temp_node_vector, y);
				}

			}

		}

		span_steps ++;
		//printf("span %d\n", span_steps);

		//// number of new nodes > 0, if == 0, means all pixel has been watered.
		if (temp_node_vector->size == 0)
			break;

		free(node_vector->data);
		free(node_vector);
		node_vector = temp_node_vector;
		temp_node_vector = create_vector();
		//printf("node_vector size is %d", node_vector.size());


	}

	return lut;
}

BYTE** copy_image(BYTE **src, int h, int w)
{
   	//make image from color to gray
	BYTE **dst;
	int y;

	dst = (BYTE**)malloc(sizeof(BYTE*)*h);
	dst[0] = (BYTE*)malloc(sizeof(BYTE)*h*w);
	for (y=0; y<h; y++)
		dst[y] = dst[0] + w*y;

	memcpy(dst[0], src[0], h*w);

	return dst;
}

/* 
//	Function: miss_data_recover
//
//  Recover the data based on the symmetry line.
//
//	Pre-conditions:
//		BYTE **image - image with missing data
//		int sym - symmetry line
//		int h - image height
//		int w - image width
//
//	Algorithm:
//	- Get the reflected pixel based on the symmetry line.
//	- Recover the missing data based on 3x3 kernel.
*/
void miss_data_recover(BYTE **mimio_image, int sym, int h, int w)
{
	// copy the old image to the new image;
   BYTE **new_image = NULL;
   int x, y;

   new_image = copy_image(mimio_image, h, w);

   for (y = 1; y < h-1; y ++)
	   for (x = 1; x < w-1; x ++)
			if (new_image[y][x] == BLACK)
			{
				// Calculate the reflected pixel.
				int x_prime = 2*sym - x; // No matter x > sym or x < sym.
				if (x_prime > w-1 || x_prime < 1) 
					continue;
				// Check the neigbour points of the reflected pixel.
				if (new_image[y][x_prime] == WHITE 
					&& new_image[y-1][x_prime-1] == WHITE && new_image[y][x_prime+1] == WHITE
					&& new_image[y-1][x_prime] == WHITE && new_image[y+1][x_prime-1] == WHITE
					&& new_image[y-1][x_prime+1] == WHITE && new_image[y+1][x_prime] == WHITE
					&& new_image[y][x_prime-1] == WHITE && new_image[y+1][x_prime+1] == WHITE )

					mimio_image[y][x_prime] = BLACK;

			}

}

/* 
//	Function: find_symmetry
//
//  Find the symmetry line on the image.
//
//	Assumptions: 
//		- The image is rectified.
//		- Only translation of X axis for the symmetry line.
//		
//	Pre-conditions:
//		BYTE **image - image to be computed
//		DIST **lut - distance lookup table to located the most similiar image.
//		int h - image height
//		int w - image width
//
//	Post-conditions:
//		return the symmetry line for the image.
//
//	Algorithms:
//	- The distance lookup table, lut, has been calculated for each pixel, refer to <set_distance_table> to details.
//	- Sum up the symmetry distance for each potential symmetry line, and get the least one.
*/
int find_symmetry(DIST **lut, BYTE**image, int h, int img_w)
{
	int start = 40, end = 440;
	int s_value[440];
	int i;
	int x, y;
	int result = 0, max_dis = 500000;

	for (i=start; i < end; i++)
	{
		s_value[i] = 0;
		for (y = 0; y < h; y++)
			for (x = img_w; x < 2*img_w; x++)
			{
				if (image[y][x-img_w] == BLACK)
				{
					if (x >= img_w + i)
					{
						s_value[i] += lut[y][x - 2*(x-img_w-i)];
					}
					else 
					{
						s_value[i] += lut[y][x + 2*(img_w+i - x)];
					}
				}

			}
	}

	for (i=start; i < end; i++)
	{
		if (s_value[i] < max_dis)
		{
			result = i;
			max_dis = s_value[i];
		}
	}

	return result;

}

/* 
//	Function: mexFunction
//
//  Interface function for C and Matlab for preprocessing.
//
//	Notes: 
//		the parameters for returning matrix is unsigned char (BYTE) *im;
//		
//	Algorithms:
//		- Compute the symmetry line based on symmetry distance
//		- Recover missing data based on the symmetry line.
//		
*/
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  BYTE *z;
  unsigned char *im;
  int mrows, ncols;
  int h, w, x, y;
  BYTE **image;
  DIST **distance_LUT;
  int symmetry_value;
  
  /* The input must be a noncomplex scalar double.*/
  mrows = mxGetM(prhs[0]);
  ncols = mxGetN(prhs[0]);

  /* Create matrix for the return argument. */
  plhs[0] = mxCreateNumericMatrix(mrows,ncols, mxUINT8_CLASS, mxREAL);
  //mexPrintf("size of input %f", sin(30.0/180.0*PI));
  //return; 
  
  /* Assign pointers to each input and output. */
  z = mxGetPr(plhs[0]);
  im = (unsigned char*)mxGetPr(prhs[0]);

 
	// convert 1D array to 2D array
	h = mrows, w = ncols;
	image = (BYTE**)malloc(sizeof(BYTE*)*h);
	image[0] = (BYTE*)malloc(sizeof(BYTE)*h*w);
	for (y=0; y<h; y++)
		image[y] = image[0] + w*y;

 
	for (y=0; y<h; y++)
		for (x=0; x<w; x++)
			image[y][x] = 1-im[x*h+y]; // 1D => 2D
 
	// Algorithm
	distance_LUT = set_distance_table(image, h, w);

	// Finding symmetry line
	symmetry_value = find_symmetry(distance_LUT, image, h, w);
	printf("\nThe symmetry line is x = %d\n", symmetry_value);

	miss_data_recover(image, symmetry_value, h, w);

	// Convert 2D to 1D 
	for (y=0; y<h; y++)
	{
		for (x=0; x<w; x++)
		{
			z[x*h+y] = 1- image[y][x]; // 2D => 1D
		}
	}

	
}

